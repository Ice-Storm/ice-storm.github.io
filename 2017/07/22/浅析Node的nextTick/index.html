<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 浅析Node的nextTick · Qin Yuan's blog</title><meta name="description" content="浅析Node的nextTick - Qin Yuan"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="qyuan.top/atom.xml" title="Qin Yuan's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"><span style="font-size: 20px;margin-left: 20px;margin-top: -46px;display: inline-block;vertical-align: middle;">清源的博客~</span></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">文章</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">关于我</a></li><li class="nav-list-item"><a href="https://github.com/Ice-Storm" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">浅析Node的nextTick</h1><div class="post-info"></div><div style="font-size:14px;color:#aaa;">Author: <span style="display:inline-block;margin-left:10px">Qin Yuan</span></div><div style="font-size:14px;color:#aaa;"><span>Date: <span style="display:inline-block;margin-left:21px">Jul 22, 2017</span></span><div>Tag:<span style="display:inline-block;margin-left:21px"></span><a href="/tags/Node" class="post-title-link"><span style="margin-left:10px;color:blue">Node</span></a><a href="/tags/JavaScript" class="post-title-link"><span style="margin-left:10px;color:blue">JavaScript</span></a></div></div><div class="post-content"><p>看thinkjs源码的时候发现下面这段代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cluster.on(<span class="string">'exit'</span>, worker =&gt; &#123;</div><div class="line">  think.log(<span class="keyword">new</span> <span class="built_in">Error</span>(think.locale(<span class="string">'WORKER_DIED'</span>, worker.process.pid)), <span class="string">'THINK'</span>);</div><div class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> cluster.fork());</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>  这段代码的意思很简单，就是cluster挂了以后重新fork一个。<br>  但是注意到其中的<code>process.nextTick(() =&gt; cluster.fork());</code>这行，刚开始想了一下没有理解为什么不直接<code>fork</code>，后面仔细想了一下，发现如果直接<code>fork</code>，在<code>fork</code>的过程中又出现错误导致进程退出，而<code>cluster</code>又监听到<code>exit</code>的事件，就会不断的重复这个过程，阻塞Node进程。<br>  如果使用<code>process.nextTick(() =&gt; cluster.fork());</code>则不会阻塞Node的事件循环，只会在<code>Event Loop</code>的<code>close callbacks</code>阶段执行<code>fork</code>，即使程序一直<code>fork</code>失败也不会导致程序假死。(如果有疑问可以阅读文章末的扩展阅读)。<br>  下面的Demo说明了为什么使用了<code>nextTick</code>不会导致程序假死。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter; </div><div class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> EventEmitter();</div><div class="line"></div><div class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</div><div class="line"></div><div class="line">event.on(<span class="string">'some_event'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </div><div class="line">  count++;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'some_event 事件触发'</span> + count);</div><div class="line">  <span class="keyword">if</span> (count &lt; num) &#123;</div><div class="line">    event.emit(<span class="string">'some_event'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">event.emit(<span class="string">'some_event'</span>); </div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'what ?'</span>)</div></pre></td></tr></table></figure></p>
<p>运行这段代码就会输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">some_event 事件触发1</div><div class="line">some_event 事件触发2</div><div class="line">some_event 事件触发3</div><div class="line">some_event 事件触发4</div><div class="line">some_event 事件触发5</div><div class="line">some_event 事件触发6</div><div class="line">some_event 事件触发7</div><div class="line">some_event 事件触发8</div><div class="line">some_event 事件触发9</div><div class="line">some_event 事件触发10</div><div class="line">what ?</div></pre></td></tr></table></figure></p>
<p>  可以发现 <code>what ?</code> 在最后才输出。如果把num设置的非常大就会报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">internal/process/next_tick.js:148</div><div class="line">    nextTickQueue.push(&#123;</div><div class="line">                 ^</div><div class="line">RangeError: Maximum call stack size exceeded</div></pre></td></tr></table></figure></p>
<p>  V8不断的向事件队列里添加任务，最终导致出现溢出，把<code>event.emit(&#39;some_event&#39;)</code>改写成<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </div><div class="line">  event.emit(<span class="string">'some_event'</span>) </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>  就会发现输出成了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ome_event 事件触发1</div><div class="line">what ?</div><div class="line">some_event 事件触发2</div><div class="line">some_event 事件触发3</div><div class="line">some_event 事件触发4</div><div class="line">some_event 事件触发5</div><div class="line">some_event 事件触发6</div><div class="line">some_event 事件触发7</div><div class="line">some_event 事件触发8</div><div class="line">some_event 事件触发9</div><div class="line">some_event 事件触发10</div></pre></td></tr></table></figure></p>
<p>  <code>what ?</code>并不会被阻塞，而且无论<code>num</code>改成多少，都不会出现栈溢出的错误。<br>  Node的<code>Event loop</code>执行流程如图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">   ┌───────────────────────┐</div><div class="line">┌─&gt;│        timers         │</div><div class="line">│  └──────────┬────────────┘</div><div class="line">|      nextTick（队列执行）</div><div class="line">│  ┌──────────┴────────────┐</div><div class="line">│  │     I/O callbacks     │</div><div class="line">│  └──────────┬────────────┘</div><div class="line">|       nextTick（队列执行）</div><div class="line">│  ┌──────────┴────────────┐</div><div class="line">│  │     idle, prepare     │</div><div class="line">│  └──────────┬────────────┘      </div><div class="line">|      nextTick（队列执行）         ┌───────────────┐</div><div class="line">│  ┌──────────┴────────────┐      │   incoming:   │</div><div class="line">│  │         poll          │&lt;─────┤  connections, │</div><div class="line">│  └──────────┬────────────┘      |               |</div><div class="line">|      nextTick（队列执行）         │   data, etc.  │</div><div class="line">│  ┌──────────┴────────────┐      └───────────────┘</div><div class="line">│  │        check          │</div><div class="line">│  └──────────┬────────────┘</div><div class="line">|       nextTick（队列执行）</div><div class="line">│  ┌──────────┴────────────┐</div><div class="line">└──┤    close callbacks    │</div><div class="line">   └───────────────────────┘</div></pre></td></tr></table></figure></p>
<p>  直接<code>event.emit(&#39;some_event&#39;)</code>的时候，Node不断的把收集到的事件塞到<code>I/O callbacks</code>这个队列，如果有大量的事件塞入就会最终导致溢出，就是上面的<code>Maximum call stack size exceeded</code>错误。<br>  如果加了<code>process.nextTick</code>则会不断的把<code>emit</code>的事件回调加到<code>nextTickQueue</code>队列，在各个主队列切换的时候执行，见上图的 <code>nextTick（队列执行）</code>。上面的那段Demo把<code>event.emit(&#39;some_event&#39;)</code>修改后的执行顺序就是<br>  1、发送事件<br>  2、把事件回调函数添加到<code>nextTickQueue</code>(注意，这个时候<code>nextTickQueue</code>队列里只有一个事件回调函数，如果当前队列尚未执行完毕并且没有发生切换，则<code>nextTickQueue</code>队列里的事件永远不会执行)<br>  3、执行<code>nextTickQueue</code>里的第一个事件回调(当前队列执行完毕或者执行到一定数量发生切换时，事件回调又会重新创建一个新的<code>nextTickQueue</code>队列并添加一个事件回调)<br>  4、然后同上<br>  这样就没有阻塞Node的事件循环，无论num多大都不会撑爆<code>I/O callbacks</code>队列。其实最核心的思想就是将任务拆解到若干次事件循环中，逐步执行。</p>
<p>扩展阅读<br>  <a href="https://github.com/creeperyang/blog/issues/26" target="_blank" rel="external">Node.js的event loop及timer/setImmediate/nextTick</a><br>  <a href="http://www.cnblogs.com/bingooo/p/6720540.html" target="_blank" rel="external">Node.js 原理简介</a><br>  <a href="https://yjhjstz.gitbooks.io/deep-into-node/content/" target="_blank" rel="external">深入理解Node.js：核心思想与源码分析</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/12/30/2017年小结/" class="prev">PREV</a><a href="/2017/07/22/Sinatra扩展机制/" class="next">NEXT</a></div><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
    id: 'Sat Jul 22 2017 14:48:29 GMT+0800',
    owner: 'qyuan',
    repo: 'ice-storm.github.io',
    oauth: {
        client_id: '0dc72a011c85518eff6a',
        client_secret: '0ae5e09dca1b971dad10c7262e669c9a82ebf3f9',
    },
})
gitment.render('container')</script><div class="copyright"><div><h4>Friends</h4><a href="https://www.xuanzhangjiong.top/">TopJohn's Blog</a>&emsp;&emsp;<a href="https://dbarobin.com">Robin</a></div><p>© 2017 - 2019 <a href="qyuan.top">Qin Yuan</a> &emsp;<script src="https://s19.cnzz.com/z_stat.php?id=1263032208&amp;web_id=1263032208" language="JavaScript"></script></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>