<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Qin Yuan&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-24T11:58:43.050Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Qin Yuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>EVM深度分析之数据存储(二)</title>
    <link href="http://yoursite.com/2019/09/24/evm-2/"/>
    <id>http://yoursite.com/2019/09/24/evm-2/</id>
    <published>2019-09-24T12:50:28.000Z</published>
    <updated>2019-09-24T11:58:43.050Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<a href="http://qyuan.top/2019/09/12/evm/" target="_blank" rel="noopener">EVM深度分析之数据存储（一）</a>介绍了EVM中不同的数据存储位置的特点，但是并没有对应到具体的存储位置，这篇文章对Storage中的数据是如何被EVM存储做了简要的分析。</p><a id="more"></a><h3 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h3><p>&emsp;&emsp;Storage初始化的时候是空白的，默认是0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.1;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256 a;</span><br><span class="line">    uint256 b;</span><br><span class="line">    uint256 c;</span><br><span class="line">    uint256 d;</span><br><span class="line">    uint256 e;</span><br><span class="line">    uint256 f;</span><br><span class="line">    function test() public &#123;</span><br><span class="line">      f = 0xc0fefe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;用<code>solc --bin --asm --optimize test.sol</code>编译合约，可以看到；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tag_5:</span><br><span class="line">    /* &quot;test.sol&quot;:167:175 0xc0fefe */</span><br><span class="line">  0xc0fefe</span><br><span class="line">    /* &quot;test.sol&quot;:163:164 f */</span><br><span class="line">  0x5</span><br><span class="line">    /* &quot;test.sol&quot;:163:175 f = 0xc0fefe */</span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这段汇编执行的是<code>sstore(0x5, 0xc0fefe)</code>，把0xc0fefe存储到0x5这个位置，在EVM中声明变量不需要成本，EVM会在编译的时候保留位置，但是不会初始化。</p><blockquote><p>当通过指令<code>sload</code>读取一个未初始化的变量的时候， 不会报错，只会读取到零值0x0。</p></blockquote><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>&emsp;&emsp;结构体的初始化和变量是一样的；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.1;</span><br><span class="line">contract C &#123;</span><br><span class="line">    struct Tuple &#123;</span><br><span class="line">      uint256 a;</span><br><span class="line">      uint256 b;</span><br><span class="line">      uint256 c;</span><br><span class="line">      uint256 d;</span><br><span class="line">      uint256 e;</span><br><span class="line">      uint256 f;</span><br><span class="line">    &#125;</span><br><span class="line">    Tuple t;</span><br><span class="line">    function test() public &#123;</span><br><span class="line">      t.f = 0xC0FEFE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;编译得到；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tag_5:</span><br><span class="line">    /* &quot;test.sol&quot;:219:227 0xC0FEFE */</span><br><span class="line">  0xc0fefe</span><br><span class="line">    /* &quot;test.sol&quot;:213:216 t.f */</span><br><span class="line">  0x5</span><br><span class="line">    /* &quot;test.sol&quot;:213:227 t.f = 0xC0FEFE */</span><br><span class="line">  sstore</span><br><span class="line">    /* &quot;test.sol&quot;:182:234 function test() public &#123;... */</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;分析编译后的汇编发现结果和状态变量的行为是一致的。</p><h3 id="定长数组"><a href="#定长数组" class="headerlink" title="定长数组"></a>定长数组</h3><p>&emsp;&emsp;定长数组EVM很容易知道类型和长度，所以可以依次排列，就像存储状态变量一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.1;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256[6] numbers;</span><br><span class="line">    function test() public &#123;</span><br><span class="line">      numbers[5] = 0xC0FEFE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;编译合约，可以看到一样的汇编。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tag_5:</span><br><span class="line">    /* &quot;test.sol&quot;:110:118 0xC0FEFE */</span><br><span class="line">  0xc0fefe</span><br><span class="line">    /* &quot;test.sol&quot;:105:106 5 */</span><br><span class="line">  0x5</span><br><span class="line">    /* &quot;test.sol&quot;:97:118 numbers[5] = 0xC0FEFE */</span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;但是使用定长数组就会有越界的问题，EVM会在赋值的时候生成汇编检查，具体的内容在下篇合约分析中讨论。</p><p>&emsp;&emsp;固定大小的变量都是尽可能打包成32字节的块然后依次存储的，而一些类型是可以动态扩容的，这个时候就需要更加灵活的存储方式了，这些类型有映射（map），数组（array），字节数组（Byte arrays），字符串(string)。</p><h3 id="映射（map）"><a href="#映射（map）" class="headerlink" title="映射（map）"></a>映射（map）</h3><p>&emsp;&emsp;通过一个简单的合约学习map的存储方式；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.1;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">  mapping(uint256 =&gt; uint256) items;</span><br><span class="line"></span><br><span class="line">  function test() public &#123;</span><br><span class="line">      items[0x01] = 0x42;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这个合约很简单，就是创建了一个key和value都是uint256类型的map，并且在用0x01作为key存储了0x42，用<code>solc --bin --asm --optimize test.sol</code>编译合约，得到如下汇编。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">tag_5:</span><br><span class="line">       /* &quot;test.sol&quot;:119:123 0x01 */</span><br><span class="line">     0x1</span><br><span class="line">       /* &quot;test.sol&quot;:113:118 items */</span><br><span class="line">     0x0</span><br><span class="line">       /* &quot;test.sol&quot;:113:124 items[0x01] */</span><br><span class="line">     swap1</span><br><span class="line">     dup2</span><br><span class="line">     mstore</span><br><span class="line">     0x20</span><br><span class="line">     mstore</span><br><span class="line">       /* &quot;test.sol&quot;:127:131 0x42 */</span><br><span class="line">     0x42</span><br><span class="line">       /* &quot;test.sol&quot;:113:124 items[0x01] */</span><br><span class="line">     0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7d</span><br><span class="line">       /* &quot;test.sol&quot;:113:131 items[0x01] = 0x42 */</span><br><span class="line">     sstore</span><br><span class="line">       /* &quot;test.sol&quot;:82:136 function test() public &#123;... */</span><br><span class="line">     jump // out</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;分析一些这段汇编就会发现0x42并不是存储在key是0x01的位置，取而代之的是<code>0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7d</code>这样一段地址，这段地址是通过<code>keccak256( bytes32(0x01) + bytes32(0x00) )</code>计算得到的，0x01就是key，而0x00表示这个合约存储的第一个storage类型变量。<br>&emsp;&emsp;所以key的计算公式就是<code>keccak256(bytes32(key) + bytes32(position))</code></p><h5 id="多个映射map"><a href="#多个映射map" class="headerlink" title="多个映射map"></a>多个映射map</h5><p>&emsp;&emsp;假设我们的合约有两个map<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.1;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">  mapping(uint256 =&gt; uint256) itemsA;</span><br><span class="line">  mapping(uint256 =&gt; uint256) itemsB;</span><br><span class="line"></span><br><span class="line">  function test() public &#123;</span><br><span class="line">    itemsA[0xAAAA] = 0xAAAA;</span><br><span class="line">    itemsB[0xBBBB] = 0xBBBB;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;编译得到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">tag_5:</span><br><span class="line">        /* &quot;test.sol&quot;:166:172 0xAAAA */</span><br><span class="line">      0xaaaa</span><br><span class="line">        /* &quot;test.sol&quot;:149:163 itemsA[0xAAAA] */</span><br><span class="line">      0x839613f731613c3a2f728362760f939c8004b5d9066154aab51d6dadf74733f3</span><br><span class="line">        /* &quot;test.sol&quot;:149:172 itemsA[0xAAAA] = 0xAAAA */</span><br><span class="line">      sstore</span><br><span class="line">        /* &quot;test.sol&quot;:195:201 0xBBBB */</span><br><span class="line">      0xbbbb</span><br><span class="line">        /* &quot;test.sol&quot;:149:155 itemsA */</span><br><span class="line">      0x0</span><br><span class="line">        /* &quot;test.sol&quot;:178:192 itemsB[0xBBBB] */</span><br><span class="line">      dup2</span><br><span class="line">      swap1</span><br><span class="line">      mstore</span><br><span class="line">        /* &quot;test.sol&quot;:178:184 itemsB */</span><br><span class="line">      0x1</span><br><span class="line">        /* &quot;test.sol&quot;:149:163 itemsA[0xAAAA] */</span><br><span class="line">      0x20</span><br><span class="line">        /* &quot;test.sol&quot;:178:192 itemsB[0xBBBB] */</span><br><span class="line">      mstore</span><br><span class="line">      0x34cb23340a4263c995af18b23d9f53b67ff379ccaa3a91b75007b010c489d395</span><br><span class="line">        /* &quot;test.sol&quot;:178:201 itemsB[0xBBBB] = 0xBBBB */</span><br><span class="line">      sstore</span><br><span class="line">        /* &quot;test.sol&quot;:120:206 function test() public &#123;... */</span><br><span class="line">      jump // out</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;itemsA的位置是0，key是0xAAAA:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># key = 0xAAAA, position = 0</span><br><span class="line">keccak256(bytes32(0xAAAA) + bytes32(0))</span><br><span class="line">&apos;839613f731613c3a2f728362760f939c8004b5d9066154aab51d6dadf74733f3&apos;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;itemsB的位置是1，key是0xBBBB:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># key = 0xBBBB, position = 1</span><br><span class="line">keccak256(bytes32(0xBBBB) + bytes32(1))</span><br><span class="line">&apos;34cb23340a4263c995af18b23d9f53b67ff379ccaa3a91b75007b010c489d395&apos;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;用<code>solc --bin --asm --optimize test.sol</code>编译合约，得到如下汇编。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/* &quot;test.sol&quot;:166:172 0xAAAA */</span><br><span class="line">  0xaaaa</span><br><span class="line">    /* &quot;test.sol&quot;:149:163 itemsA[0xAAAA] */</span><br><span class="line">  0x839613f731613c3a2f728362760f939c8004b5d9066154aab51d6dadf74733f3</span><br><span class="line">    /* &quot;test.sol&quot;:149:172 itemsA[0xAAAA] = 0xAAAA */</span><br><span class="line">  sstore</span><br><span class="line">    /* &quot;test.sol&quot;:195:201 0xBBBB */</span><br><span class="line">  0xbbbb</span><br><span class="line">    /* &quot;test.sol&quot;:149:155 itemsA */</span><br><span class="line">  0x0</span><br><span class="line">    /* &quot;test.sol&quot;:178:192 itemsB[0xBBBB] */</span><br><span class="line">  dup2</span><br><span class="line">  swap1</span><br><span class="line">  mstore</span><br><span class="line">    /* &quot;test.sol&quot;:178:184 itemsB */</span><br><span class="line">  0x1</span><br><span class="line">    /* &quot;test.sol&quot;:149:163 itemsA[0xAAAA] */</span><br><span class="line">  0x20</span><br><span class="line">    /* &quot;test.sol&quot;:178:192 itemsB[0xBBBB] */</span><br><span class="line">  mstore</span><br><span class="line">  0x34cb23340a4263c995af18b23d9f53b67ff379ccaa3a91b75007b010c489d395</span><br><span class="line">    /* &quot;test.sol&quot;:178:201 itemsB[0xBBBB] = 0xBBBB */</span><br><span class="line">  sstore</span><br><span class="line">    /* &quot;test.sol&quot;:120:206 function test() public &#123;... */</span><br><span class="line">  jump // out</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以看到，存储的地址和我们推到的一样。</p><h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><p>&emsp;&emsp;在其他语言中，数组只是连续存储在内存中的一系列相同类型的元素，取值的时候都是采用首地址+偏移量的形式，但是在solidity中，数组是一种映射。数组在存储器中是这样存储的；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x290d...e563</span><br><span class="line">0x290d...e564</span><br><span class="line">0x290d...e565</span><br><span class="line">0x290d...e566</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;虽然看起来像是连续存储的，但实际上访问的时候是通过映射来查找的。增加了数组类型的意义在于多了一些数组的方法，便于我们更好的理解和编写代码，增加的特性有；</p><ul><li>length表示数组的长度，一共有多少元素；</li><li>边界检查，当读取或者写入时索引值大于length就会报错；</li><li>比映射更加复杂的存储打包行为；</li><li>当数组变小时，自动清除未使用的空间；</li><li>bytes和string的特殊优化让短数组（小于32字节）存储更加高效；</li></ul><p>&emsp;&emsp;编译合约<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.1;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256[] chunks;</span><br><span class="line">    function test() public &#123;</span><br><span class="line">      chunks.push(0xAA);</span><br><span class="line">      chunks.push(0xBB);</span><br><span class="line">      chunks.push(0xCC);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;使用<code>remix</code>调试合约可以看到storage部分的存储内容；</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/evm2/1.jpg?raw=true" width="70%" height="50%"></p><p>&emsp;&emsp;因为动态数组在编译期间无法知道数组的长度，提前预留存储空间，所以solidity就用<code>chunks</code>变量的位置存储了动态数组的长度，而具体的数据地址通过计算<code>keccak256(bytes32(0))</code>算得数组首地址，再加数组长度偏移量获得具体的元素。</p><blockquote><p>这里的 0 表示的是chunks变量的位置哦</p></blockquote><h3 id="动态数据打包"><a href="#动态数据打包" class="headerlink" title="动态数据打包"></a>动态数据打包</h3><p>&emsp;&emsp;数组与映射相比，有更加优化的打包行为，编译合约；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.1;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint128[] s;</span><br><span class="line">    function test() public &#123;</span><br><span class="line">        s.length = 4;</span><br><span class="line">        s[0] = 0xAA;</span><br><span class="line">        s[1] = 0xBB;</span><br><span class="line">        s[2] = 0xCC;</span><br><span class="line">        s[3] = 0xDD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;使用<code>remix</code>调试合约可以看到storage部分的存储内容；</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/evm2/2.jpg?raw=true" width="70%" height="50%"></p><p>&emsp;&emsp;可以发现4个元素并没有占据4个插槽，而只有两个，solidity一个插糟的大小是256bit，s的类型是uint128，编译器做了一个优化，对数据进行了更优化的打包策略，可以最大限度的节约Gas。</p><p>&emsp;&emsp;看一些各项操作所花费Gas的表格；</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/evm2/3.png?raw=true" width="70%" height="50%"></p><p>&emsp;&emsp;其中数据的持久化操作<code>sstore</code>是消耗Gas最多的操作，在合适的场景下使用数组可以利用编译器优化节约大量的Gas。</p><h3 id="字节数组和字符串"><a href="#字节数组和字符串" class="headerlink" title="字节数组和字符串"></a>字节数组和字符串</h3><p>&emsp;&emsp;bytes和string是EVM特殊优化的类型；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.1;</span><br><span class="line">contract C &#123;</span><br><span class="line">    bytes s;</span><br><span class="line">    function test() public &#123;</span><br><span class="line">        s.push(0xAA);</span><br><span class="line">        s.push(0xBB);</span><br><span class="line">        s.push(0xCC);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;最后用remix编译得到;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key: 0x0000000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">value: 0xaabbcc0000000000000000000000000000000000000000000000000000000006</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;当bytes和string的长度小于31字节的时候可以这样放到一个插槽里，但是当大于31字节的时候，就采用存储动态数组的方式。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;EVM的存储器就是一个健值数据库，当改变里面的任何一点东西，根节点的校验和也会改变，如果两个根节点拥有相同的校验和，存储的数据就能保持一致。</p>]]></content>
    
    <summary type="html">
    
      EVM以太坊虚拟机
    
    </summary>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="以太坊" scheme="http://yoursite.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
  <entry>
    <title>EVM深度分析之数据存储(一)</title>
    <link href="http://yoursite.com/2019/09/12/evm/"/>
    <id>http://yoursite.com/2019/09/12/evm/</id>
    <published>2019-09-12T10:11:45.000Z</published>
    <updated>2019-09-24T11:50:17.403Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;以太坊虚拟机<code>EVM</code>的作用是将智能合约代码翻译成可以在以太坊上执行的机器码，并且提供一个沙盒运行环境，在运行期间不能访问宿主机的网络，文件，系统，即使不同的合约之间也有有限的访问权限。</p><a id="more"></a><h3 id="EVM的特点"><a href="#EVM的特点" class="headerlink" title="EVM的特点"></a>EVM的特点</h3><p>&emsp;&emsp;官方给出的EVM主要的设计目标如下：</p><ul><li>简单性，操作码尽可能少且低级，数据类型尽可能少，虚拟机的结构尽可能简单。</li><li>确定性，EVM的语句没有产生歧义的空间，结果在不同机器上的执行结果是确定一致的。</li><li>节约空间，EVM的组件尽可能紧凑。</li><li>区块链定制化的，必须可以处理20bytes的账户地址，自定义32bytes密码学算法的等。</li><li>安全模型简单安全，Gas的计价模型应该是简单易行准确的。</li><li>便于优化，以便即时编译（JIT）和VM的性能优化。</li></ul><h3 id="EVM基本信息"><a href="#EVM基本信息" class="headerlink" title="EVM基本信息"></a>EVM基本信息</h3><p>&emsp;&emsp;以太坊是一种基于栈的虚拟机，基于栈的虚拟机数据的存取为先进先出，在后面介绍EVM指令的时候会看到这个特性。同时基于栈的虚拟机实现简单，移植性也不错，这也是以太坊选择基于栈的虚拟机的原因。</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/evm/2.jpg?raw=true" width="70%" height="50%"></p><p>&emsp;&emsp;EVM采用了32字节（256bit）的<code>字长</code>，最多可以容纳2014个<code>字</code>，<code>字</code>为最小的操作单位。</p><h3 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h3><p>&emsp;&emsp;接下来看一下EVM的数据是如何管理的。</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/evm/1.jpg?raw=true" width="70%" height="70%"></p><p>&emsp;&emsp;可以看到code和storage里存储的数据是非易失的，而stack，args，memory里存储的数据是易失的，其中code的数据是智能合约的二进制源码，是非易失的很好理解，部署合约的时候data字段也就是合约内容会存储在EVM的code中。<br>&emsp;&emsp;如果要操作这些存储结构里的数据，就需要用到EVM指令，由于EVM的操作码被限制在一个字以内，所以EVM最多容纳256条指令，目前EVM已经定义了约142条指令，还有100多条用于以后的扩展。这142条指令包括了算法运算，密码学计算，栈操作，memory，storage操作等。</p><p>&emsp;&emsp;接下来看一下各个存储位置的含义；</p><h5 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h5><p>&emsp;&emsp; <code>stack</code>可以免费使用，没有gas消耗，用来保存函数的局部变量，数量被限制在了16个，当在合约里中声明的局部变量超过16个时，再编译合约就会遇到<code>Stack too deep, try removing local variables</code>错误。<br>&emsp;&emsp;介绍几个EVM操作栈的指令，在后面分析合约的时候会用到；</p><ul><li>Pop指令（操作码0x50）用来从栈顶弹出一个元素；</li><li>PushX指令用来把紧跟在后面的1-32字节元素推入栈顶，Push指令一共32条，从Push1（0x60）到Push32（0x7A），因为栈的一个<code>字</code>是256bit，一个字节8bit，所以Push指令最多可以把其后32字节的元素放入栈中而不溢出。</li><li>DupX指令用来复制从栈顶开始的第1-16个元素，复制后把元素在推入栈顶，Dup指令一共16条，从Dup1（0x80）到Dup16（0x8A）。</li><li>SwapX指令把栈顶元素和从栈顶开始数的第1-16个元素进行交换，Swap指令一共16条，从Swap1（0x01）一直到Swap16（0x9A）。</li></ul><h5 id="Args"><a href="#Args" class="headerlink" title="Args"></a>Args</h5><p>&emsp;&emsp;<code>args</code>也叫<code>calldata</code>，是一段只读的可寻址的保存函数调用参数的空间，与栈不同的地方的是，如果要使用calldata里面的数据，必须手动指定偏移量和读取的字节数。<br>&emsp;&emsp;EVM提供的用于操作calldata的指令有三个：</p><ul><li><code>calldatasize</code>返回calldata的大小。</li><li><code>calldataload</code>从calldata中加载32bytes到stack中。</li><li><code>calldatacopy</code>拷贝一些字节到内存中。</li></ul><p>&emsp;&emsp;通过一个合约来看一下如何使用<code>calldata</code>，假如我们要写一个合约，合约有一个add的方法，用来把传入的两个参数相加，通常会这样写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.1;</span><br><span class="line"></span><br><span class="line">contract Calldata &#123;</span><br><span class="line">  function add(uint256 a, uint256 b) public view returns (uint256) &#123;</span><br><span class="line">      return a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;当然我们也可以用内联汇编的形式这样写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract Calldata &#123;</span><br><span class="line">  function add(uint256 a, uint256 b) public view returns (uint256) &#123;</span><br><span class="line">    assembly &#123;</span><br><span class="line">      let a := mload(0x40)</span><br><span class="line">      let b := add(a, 32)</span><br><span class="line">      calldatacopy(a, 4, 32)</span><br><span class="line">      calldatacopy(b, add(4, 32), 32)</span><br><span class="line">      result := add(mload(a), mload(b))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;首先我们我们加载了0x40这个地址，这个地址EVM存储空闲memory的指针，然后我们用a重命名了这个地址，接着我们用b重命名了a偏移32字节以后的空余地址，到目前为止这个地址所指向的内容还是空的。<br>&emsp;&emsp;<code>calldatacopy(a, 4, 32)</code>这行代码把calldata的从第4字节到第36字节的数据拷贝到了a中，同样<code>calldatacopy(b, add(4, 32), 32)</code>把36到68字节的数据拷贝到了b中，接着<code>add(mload(a), mload(b))</code>把栈中的a，b加载到内存中相加。最后的结果等价于第一个合约。<br>&emsp;&emsp;而为什么<code>calldatacopy(a, 4, 32)</code>的偏移要从4开始呢？在EVM中，前四位是存储函数指纹的，计算公式是bytes4(keccak256(“add(uint256, uint256)”))，从第四位开始才是args。</p><h5 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h5><p>&emsp;&emsp;Memory是一个易失性的可以读写修改的空间，主要是在运行期间存储数据，将参数传递给内部函数。内存可以在字节级别寻址，一次可以读取32字节。<br>&emsp;&emsp;EVM提供的用于操作memory的指令有三个：</p><ul><li>Mload加载一个字从stack到内存；</li><li>Mstore存储一个值到指定的内存地址，格式mstore（p，v），存储v到地址p；</li><li>Mstore8存储一个byte到指定地址 ；</li></ul><p>&emsp;&emsp;当我们操作内存的时候，总是需要加载0x40，因为这个地址保存了空闲内存的指针，避免了覆盖已有的数据。</p><h5 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h5><p>&emsp;&emsp;Storage是一个可以读写修改的持久存储的空间，也是每个合约持久化存储数据的地方。Storage是一个巨大的map，一共2^256个插槽，一个插糟有32byte。<br>&emsp;&emsp;EVM提供的用于操作storage的指令有两个：</p><ul><li>Sload用于加载一个字到stack中；</li><li>Sstore用于存储一个字到storage中；</li></ul><p>&emsp;&emsp;solidity将定义的状态变量，映射到插糟内，对于静态大小的变量从0开始连续布局，对于动态数组和map则采用了其他方法，下篇文章在讲 (<em>╹▽╹</em>)</p>]]></content>
    
    <summary type="html">
    
      EVM以太坊虚拟机
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="以太坊" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="以太坊" scheme="http://yoursite.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
  <entry>
    <title>详解实用拜占庭协议Pbft（三）</title>
    <link href="http://yoursite.com/2019/09/03/pbft-3/"/>
    <id>http://yoursite.com/2019/09/03/pbft-3/</id>
    <published>2019-09-03T11:10:21.000Z</published>
    <updated>2019-09-03T11:34:50.332Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主动恢复"><a href="#主动恢复" class="headerlink" title="主动恢复"></a>主动恢复</h3><p>&emsp;&emsp;集群在运行过程中，可能出现网络抖动、磁盘故障等原因，会导致部分节点的执行速度落后大多数节点，而传统的PBFT拜占庭共识算法并没有实现主动恢复的功能，因此需要添加主动恢复的功能才能参与后续的共识流程，主动恢复会索取网络中其他节点的视图，最新的区块高度等信息，更新自身的状态，最终与网络中其他节点的数据保持一致。<br>&emsp;&emsp;在<code>Raft</code>中采用的方式是主节点记录每个跟随者提交的日志编号，发送心跳包时携带额外信息的方式来保持同步，在<code>Pbft</code>中采用了<code>视图协商（NegotiateView）</code>的机制来保持同步。<br>&emsp;&emsp;一个节点落后太多，这个时候它收到主节点发来的消息时，对消息<code>水线（water mark）</code>的检查会失败，这个时候计时器超时，发送<code>view-change</code>的消息，但是由于只有自己发起<code>view-change</code>达不到<code>2f+1</code>个节点的数量，本来正常运行的节点就退化为一个拜占庭节点，尽管是非主观的原因，为了尽可能保证集群的稳定性，所以加入了<code>视图协商（NegotiateView）</code>机制。<br>&emsp;&emsp;当一个节点多次<code>view-change</code>失败就触发<code>NegotiateView</code>同步集群数据，流程如下；</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/pbft3/1.png?raw=true" width="70%" height="70%"></p><ul><li>新增节点<code>Replica 4</code>发起<code>NegotiateView</code>消息给其他节点；</li><li>其余节点收到消息以后，返回自己的视图信息，节点ID，节点总数N；</li><li><code>Replica 4</code>收到<code>2f+1</code>个相同的消息后，如果quorum个视图编号和自己不同，则同步view和N；</li><li><code>Replica 4</code>同步完视图后，发送<code>RevoeryToCheckpoint</code>的消息，其中包含自身的<code>checkpoint</code>信息；</li><li>其余节点收到<code>RevoeryToCheckpoint</code>后将自身最新的检查点信息返回给<code>Replica 4</code>;</li><li><code>Replica 4</code>收到quorum个消息后，更新自己的检查点到最新，更新完成以后向正常节点索要pset、qset和cset的信息（即PBFT算法中pre-prepare阶段、prepare阶段和commit阶段的数据）同步至全网最新状态；</li></ul><h3 id="增删节点"><a href="#增删节点" class="headerlink" title="增删节点"></a>增删节点</h3><p>&emsp;&emsp;<code>Replica 5</code>新节点加入的流程如下图所示；</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/pbft3/2.jpg?raw=true" width="70%" height="70%"></p><ul><li>新节点启动以后，向网络中其他节点建立连接并且发送<code>AddNode</code>消息；</li><li>当集群中的节点收到<code>AddNode</code>消息后，会广播<code>AgreeAdd</code>的消息；</li><li>当一个节点收到<code>2f+1</code>个<code>AgreeAdd</code>的消息后，会发送<code>AgreeAdd</code>的消息给<code>Replica 5</code></li><li><code>Replica 5</code>会从收到的消息中，挑选一个节点同步数据，具体的过程在主动恢复中有说明，同步完成以后发送<code>JoinNet</code></li><li>当集群中其他节点收到<code>JoinNet</code>之后重新计算视图view，节点总数N，同时将PQC信息封装到<code>AgreeJoinOrExit</code>中广播</li><li>当收到<code>2f+1</code>个有效的<code>AgreeJoinOrExit</code>后，新的主节点广播<code>UpdateNet</code>消息完成新增节点流程</li></ul><p>&emsp;&emsp;删除节点的流程和新增节点的过程类似：</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/pbft3/3.jpg?raw=true" width="70%" height="70%"></p><h3 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h3><p>Q：为什么<code>PBFT</code>算法需要三个阶段？<br>A：假如简化为两个阶段<code>pre-prepare</code>和<code>prepare</code>，当一个节点A收到<code>2f+1</code>个相同的<code>prepare</code>后执行请求，一部分节点B发生<code>view-change</code>，在<code>view-change</code>的过程中是拒收<code>prepare</code>消息的，所以这一部分节点的状态机会少执行一个请求，当<code>view-change</code>切换成功后重放<code>prepare</code>消息，在重放的过程中，节点A也完成了<code>view-change</code>，这个时候A就会面临重放的<code>prepare</code>已经执行过了，是否需要再次执行？会导致状态机出现二义性。</p><hr><p>Q：view-change阶段集群会不可用么？<br>A：view-change阶段集群会出现短暂的不可用，一般在实践的时候都会实现一个缓冲区来减少影响，实现参考 <a href="http://qyuan.top/2019/06/02/txpool/" target="_blank" rel="noopener">以太坊TXpool分析</a>。</p><hr><p>Q：Pbft算法的时间复杂度？<br>A：Pbft算法的时间复杂度O(n^2)，在<code>prepare</code>和<code>commit</code>阶段会将消息广播两次，一般而言，Pbft集群中的节点都不会超过100。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;主动恢复&quot;&gt;&lt;a href=&quot;#主动恢复&quot; class=&quot;headerlink&quot; title=&quot;主动恢复&quot;&gt;&lt;/a&gt;主动恢复&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;集群在运行过程中，可能出现网络抖动、磁盘故障等原因，会导致部分节点的执行速度落后大多数节点，而传统的
      
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>详解实用拜占庭协议Pbft（二）</title>
    <link href="http://yoursite.com/2019/08/25/pbft-2/"/>
    <id>http://yoursite.com/2019/08/25/pbft-2/</id>
    <published>2019-08-25T11:12:59.000Z</published>
    <updated>2019-08-25T11:16:41.512Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<a href="http://qyuan.top/2019/08/13/pbft-1/" target="_blank" rel="noopener">「详解实用拜占庭协议Pbft（一)」</a>中介绍了<code>Pbft</code>算法的正常流程，但是还有一些可用性方面的问题没有解决，比如日志无限增长，主节点故障，增删节点。</p><a id="more"></a><h3 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h3><p>&emsp;&emsp;<code>Pbft</code>算法在运行的过程中，日志会不断累积的，但是在实际的系统中，无论是从日志占用的磁盘空间，还是新节点加入集群，同步日志的网络消耗来看，日志都不能无限的增长。</p><p>&emsp;&emsp;<code>Pbft</code>采用<code>检查点（checkpoint）</code>机制来压缩日志，其本质和<code>Raft</code>算法采用快照的形式清理日志是一样的，只是实现的方式不同。</p><p>&emsp;&emsp;为每一次操作创建一个集群中稳定检查点，代价是非常昂贵的，<code>Pbft</code>为常数个操作创建一次稳定检查点，比如每100个操作创建一次检查点，而这个检查点就是<code>checkpoint</code>，当这个<code>checkpoint</code>得到集群中多数节点认可以后，就变成了稳定检查点<code>stable checkpoint</code>。</p><p>&emsp;&emsp;当节点<code>i</code>生成<code>checkpoint</code>后会广播消息<code>&lt;CHECKPOINT, n, d, i&gt;</code>其中<code>n</code>是最后一次执行的消息序号，<code>d</code>是<code>n</code>执行后的状态机状态的摘要。每个节点收到<code>2f+1</code>个相同<code>n</code>和<code>d</code>的<code>checkpoint</code>消息以后，<code>checkpoint</code>就变成了<code>stable checkpoint</code>。同时删除本地序号小于等于<code>n</code>的消息。</p><p>&emsp;&emsp;同时<code>checkpoint</code>还有一个提高<code>水线（water mark）</code>的作用，当一个<code>stable checkpoint</code>被创建的时候，水线<code>h</code>被修改为<code>stable checkpoint</code>的<code>n</code>，水线<code>H</code>为<code>h + k</code>而<code>k</code>就是之前用到创建<code>checkpoint</code>的那个常数。</p><h3 id="视图切换（View-Change）"><a href="#视图切换（View-Change）" class="headerlink" title="视图切换（View-Change）"></a>视图切换（View-Change）</h3><p>&emsp;&emsp;在正常流程中，可以看到所有客户端发来的消息<code>m</code>都是由主节点<code>p</code>广播到集群的，但是当主节点突然宕机，又怎么保证集群的可用性呢？</p><p>&emsp;&emsp;<code>view-change</code>提供了一种当主节点宕机以后依然可以保证集群可用性的机制。<code>view-change</code>通过计时器来进行切换，避免副本长时间的等待请求。<br>&emsp;&emsp;当副本收到请求时，就启动一个计时器，如果这个时候刚好有定时器在运行就重置（reset）定时器，但是<code>主节点</code>宕机的时候，副本<code>i</code>就会在当前<code>视图</code>v中超时，这个时候副本<code>i</code>就会触发<code>view-change</code>的操作，将视图切换为<code>v+1</code>。</p><ul><li>副本<code>i</code>会停止接收除了<code>checkpoint</code>，<code>view-change</code>和<code>new view-change</code>以外的请求，同时广播消息<code>&lt;VIEW-CHANGE, v+1, n, C, P, i&gt;</code>的消息到集群。<ol><li><code>n</code>是节点<code>i</code>知道的最后一个<code>stable checkpoint</code>的消息序号。</li><li><code>C</code>是节点<code>i</code>保存的经过<code>2f+1</code>个节点确认<code>stable checkpoint</code>消息的集合。</li><li><code>P</code>是一个保存了<code>n</code>之后所有已经达到<code>prepared</code>状态消息的集合。</li></ol></li><li>当在视图( v+1 )中的主节点<code>p1</code>接收到<code>2f</code>个有效的将视图变更为<code>v+1</code>的消息以后，<code>p1</code>就会广播一条消息<code>&lt;NEW-VIEW, v+1, V, Q&gt;</code><ol><li><code>V</code>是<code>p1</code>收到的，包括自己发送的<code>view-change</code>的消息集合。</li><li><code>Q</code>是<code>PRE-PREPARE</code>状态的消息集合，但是这个<code>PRE-PREPARE</code>消息是从<code>PREPARE</code>状态的消息转换过来的。</li></ol></li><li>从节点接收到<code>NEW-VIEW</code>消息后，校验签名，<code>V</code>和<code>Q</code>中的消息是否合法，验证通过，主节点和副本都 进入视图<code>v+1</code>。</li></ul><p>&emsp;&emsp;当<code>p1</code>在接收到<code>2f+1</code>个<code>VIEW-CHANGE</code>消息以后，可以确定<code>stable checkpoint</code>之前的消息在视图切换的过程中不会丢，但是当前检查点之后，下一个检查点之前的已经<code>PREPARE</code>可能会被丢弃，在视图切换到<code>v+1</code>后，<code>Pbft</code>会把旧视图中已经<code>PREPARE</code>的消息变为<code>PRE-PREPARE</code>然后新广播。</p><ul><li>如果集合<code>P</code>为空，广播<code>&lt;PRE-PREPARE, v+1, n, null&gt;</code>，接收节点就什么也不做。</li><li>如果集合<code>P</code>不为空，广播<code>&lt;PRE-PREPARE, v+1, n,d&gt;</code></li></ul><p>&emsp;&emsp;总结一下，在<code>view-change</code>中最为重要的就是<code>C</code>，<code>P</code>，<code>Q</code>三个消息的集合，<code>C</code>确保了视图变更的时候，<code>stable checkpoint</code>之前的状态安全。<code>P</code>确保了视图变更前，已经<code>PREPARE</code>的消息的安全。<code>Q</code>确保了视图变更后<code>P</code>集合中的消息安全。回想一下<code>pre-prepare</code>和<code>prepare</code>阶段最重要的任务是保证，同一个<code>主节点</code>发出的请求在同一个<code>视图（view）</code>中的顺序是一致的，而在视图切换过程中的<code>C</code>，<code>P</code>，<code>Q</code>三个集合就是解决这个问题的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;&lt;a href=&quot;http://qyuan.top/2019/08/13/pbft-1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;「详解实用拜占庭协议Pbft（一)」&lt;/a&gt;中介绍了&lt;code&gt;Pbft&lt;/code&gt;算法的正常流程，但是还有一些可用性方面的问题没有解决，比如日志无限增长，主节点故障，增删节点。&lt;/p&gt;
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>详解实用拜占庭协议Pbft（一)</title>
    <link href="http://yoursite.com/2019/08/13/pbft-1/"/>
    <id>http://yoursite.com/2019/08/13/pbft-1/</id>
    <published>2019-08-13T13:40:19.000Z</published>
    <updated>2019-08-14T13:01:29.965Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<code>PBFT</code>算法和<code>Raft</code>算法解决的核心问题都是在分布式环境下如何保持集群状态的一致性，简而言之就是一组服务，给定一组操作，最后得到一致的结果。</p><a id="more"></a><p>&emsp;&emsp;<code>PBFT</code>算法假设的环境又比<code>Raft</code>算法更加的’恶劣‘，<code>Raft</code>算法只支持容错故障节点，而<code>PBFT</code>算法除了需要支持容错故障节点之外，还需要容忍作恶节点。</p><blockquote><p>作恶节点节点是指可能对接收到的消息作出截然相反的回复，甚至伪造消息。</p></blockquote><p>&emsp;&emsp;<code>PBFT</code>算法中节点只有两种角色，<code>主节点（primary）</code>和<code>副本（replica）</code>，两种角色之间可以相互转换。两者之间的转换又引入了<code>视图（view）</code>的概念，<code>视图</code>在<code>PBFT</code>算法中起到逻辑时钟的作用。</p><p>&emsp;&emsp;为了更多的容错性，<code>PBFT</code>算法最大的容错节点数量<code>( n - 1 ) / 3</code>，也就是是说4个节点的集群最多只能容忍一个节点作恶或者故障。而<code>Raft</code>算法的最大容错节点是<code>( n - 1) / 2</code>，5个节点的集群可以容忍2个节点故障。</p><h3 id="为什么PBFT算法只能容忍（n-1-3个作恶节点？"><a href="#为什么PBFT算法只能容忍（n-1-3个作恶节点？" class="headerlink" title="为什么PBFT算法只能容忍（n-1)/3个作恶节点？"></a>为什么<code>PBFT</code>算法只能容忍<code>（n-1)/3</code>个作恶节点？</h3><p>&emsp;&emsp; 节点总数是<code>n</code>，其中作恶节点有<code>f</code>，那么剩下的正确节点为<code>n - f</code>，意味着只要收到<code>n - f</code>个消息就能做出决定，但是这<code>n - f</code>个消息有可能由<code>f</code>个是由作恶节点冒充的，那么正确的消息就是<code>n - f - f</code>个，为了多数一致，正确消息必须占多数，也就是<code>n - f - f &gt; f</code>但是节点必须是整数个，所以n最少是<code>3f+1</code>个。<br>&emsp;&emsp;或者可以这样理解，假定<code>f</code>个节点是故障节点，<code>f</code>个节点是作恶，那么达成一致需要的正确节点最少就是<code>f+1</code>个，当然这是最坏的情况，如果故障节点集合和拜占庭节点集合有重复，可以不需要<code>f+1</code>个正确节点，但是为了保证最坏的情况算法还能正常运行，所以必须保证正确节点数量是<code>f+1</code>个。</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>&emsp;&emsp;在算法开始阶段，<code>主节点</code>由 <code>p = v mod n</code>计算得出，随着<code>v</code>的增长可以看到<code>p</code>不断变化，论文里目前还是轮流坐庄的方法，这里是一个优化点。</p><p>&emsp;&emsp;首先客户端发送消息<code>m</code>给主节点<code>p</code>，主节点就开始了<code>PBFT</code>三阶段协议，三个阶段分别是<code>预准备（pre-prepare）</code>，<code>准备（prepare）</code>，<code>提交（commit）</code>。<br>&emsp;&emsp;其中<code>pre-prepare</code>和<code>prepare</code>阶段最重要的任务是保证，同一个<code>主节点</code>发出的请求在同一个<code>视图（view）</code>中的顺序是一致的，<code>prepare</code>和<code>commit</code>阶段最重要的任务是保证请求在不同<code>视图</code>之间的顺序是一致的。</p><ul><li>主节点收到客户端发送来的消息后，构造<code>pre-prepare</code>消息结构体<code>&lt; &lt;PRE-PREPARE, v, n, d&gt;, m &gt;</code>广播到集群中的其它节点。<ol><li><code>PRE-PREPARE</code>标识当前消息所处的协议阶段。</li><li><code>v</code>标识当前视图编号。</li><li><code>n</code>为主节点广播消息的一个唯一递增序号。</li><li><code>d</code>为<code>m</code>的消息摘要。</li><li><code>m</code>为客户端发来的消息。</li></ol></li><li><p><code>副本(backup)</code>收到主节点请求后，会对消息进行检查，检查通过会存储在本节点。当节点收到<code>2f+1</code>（包括自己）个相同的消息后，会进入<code>PREPARE</code>状态，广播消息<code>&lt; &lt;PREPARA, v, n, d, i&gt; &gt;</code>，其中<code>i</code>是本节点的编号。对消息的有效性有如下检查：</p><ol><li>检查收到的消息体中摘要<code>d</code>，是否和自己对<code>m</code>生成的摘要一致，确保消息的完整性。</li><li>检查<code>v</code>是否和当前视图<code>v</code>一致。</li><li>检查序号<code>n</code>是否在水线<code>h</code>和<code>H</code>之间，避免快速消耗可用序号。</li><li>检查之前是否接收过相同序号<code>n</code>和<code>v</code>，但是不同摘要<code>d</code>的消息。</li></ol></li><li><p><code>副本</code>收到<code>2f+1</code>（包括自己）个一致的<code>PREPARE</code>消息后，会进入<code>COMMIT</code>阶段，并且广播消息<code>&lt; COMMIT, v, n, D(m), i &gt;</code>给集群中的其它节点。在收到<code>PREPARE</code>消息后，副本同样也会对消息进行有效性检查，检查的内容是上文<code>1, 2, 3</code>。</p></li><li><p><code>副本</code>收到<code>2f+1</code>（包括自己）个一致的<code>COMMIT</code>个消息后执行<code>m</code>中包含的操作，其中，如果有多个<code>m</code>则按照序号<code>n</code>从小到大执行，执行完毕后发送执行成功的消息给客户端。</p></li></ul><p>下面就是算法的流程图：</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/pbft1/pbft-1.jpeg?raw=true" width="70%" height="70%"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;&lt;code&gt;PBFT&lt;/code&gt;算法和&lt;code&gt;Raft&lt;/code&gt;算法解决的核心问题都是在分布式环境下如何保持集群状态的一致性，简而言之就是一组服务，给定一组操作，最后得到一致的结果。&lt;/p&gt;
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分布式一致性协议之Raft(三)</title>
    <link href="http://yoursite.com/2019/08/03/raft-2/"/>
    <id>http://yoursite.com/2019/08/03/raft-2/</id>
    <published>2019-08-03T14:27:56.000Z</published>
    <updated>2019-08-03T15:10:44.569Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在前两篇文章中已经介绍了<code>Raft</code>算法的正常流程和对异常的处理，但是还有一些问题没有解决，比如当集群中有新的节点加入或者退出的时候，集群又该如何保证安全的提供服务呢？</p><a id="more"></a><h3 id="增删集群节点"><a href="#增删集群节点" class="headerlink" title="增删集群节点"></a>增删集群节点</h3><p>&emsp;&emsp;最容易想到的方法就是暂停整个集群，更新配置，然后重启集群。但是问题显而易见，在更新配置期间集群是不可用的，而手工操作配置文件，而且是操作多个节点的配置文件，也会造成很大的风险。为了避免发生这些风险，<code>Raft</code>算法添加了自动化配置变更的内容。<br>&emsp;&emsp;从旧的配置直接变更到新的配置的各种方法都是不安全的，其中最大的问题就是容易出现<code>脑裂</code>集群分裂，举个例子；</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/raft2/1.png?raw=true" width="70%" height="70%"></p><p>&emsp;&emsp;旧配置有 1， 2， 3号节点，<code>候选人</code>只需要两张选票就可以变为<code>领导者</code>，除了自己的一张选票，还需要等待一个节点投票给自己即可，但是当集群增加2个节点的时候，旧节点之间是无法感知有几个节点加入网络的，所以还会按照旧配置投票，即收集到两张选票就可以成为候选人。而新节点是可以感知到集群中是有5个节点的，所以新节点要成为领导者需要3张选票，必然有一个时间点，既可满足旧节点的候选人选举要求，又可满足新节点的选举要求，<code>脑裂</code>就这样发生了。</p><p>&emsp;&emsp;显而易见，出现<code>脑裂</code>的问题是由于同一时间新旧配置节点各自单方面的作出了选<code>领导者</code>的决定。</p><p>&emsp;&emsp;停集群，更新配置，重启集群其实目的就是保证了同一时间只有一种状态，为了解决集群的可用性，<code>Raft</code>采取了两段提交来保证安全的变更日志。</p><h4 id="配置变更流程"><a href="#配置变更流程" class="headerlink" title="配置变更流程"></a>配置变更流程</h4><p>&emsp;&emsp;首先当一个<code>领导者</code>收到一个改变配置从<code>C-old</code>到<code>C-new</code>的请求时，它会<code>merge(C-old, C-new)</code>并且保存到自己的日志中，然后复制到集群中的其他节点，在<code>C-new</code>提交之前，所有节点的决定都会基于<code>C-old,new</code>的配置做决定。<br>&emsp;&emsp;在<code>C-old, new</code>被提交以后，<code>领导者</code>创建一条<code>C-new</code>的配置复制到集群，当<code>C-new</code>被提交以后，就旧配置指定的节点就无关紧要了，在集群中不可见了，可以从集群移除。</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/raft2/2.png?raw=true" width="70%" height="70%"></p><h4 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h4><h5 id="节点宕机"><a href="#节点宕机" class="headerlink" title="节点宕机"></a>节点宕机</h5><p>&emsp;&emsp;但是在这个过程中还是会有节点宕机的异常情况发生，<code>Raft</code>又是如何保证整个增删节点过程的安全性呢？<br>&emsp;&emsp;如果领导者在复制包含配置文件的日志时候崩溃了，跟随者节点只有两种配置状态，<code>C-old,new</code>或者<code>C-old</code>，主要观察<code>C-old,new</code>是否能被复制到了大多数节点。但是无论哪种状态，<code>C-new</code>都不会单方面做出决定。</p><h5 id="空白节点加入"><a href="#空白节点加入" class="headerlink" title="空白节点加入"></a>空白节点加入</h5><p>&emsp;&emsp;当一个新的服务器加入集群，新服务器本身是没有存储任何日志，是无法提交集群中的任何一条日志的，需要一段时间来追赶，<code>Raft</code>为了避免这种可用性的时间间隔太长，采取了节点静默加入集群，但是没有投票权，只是同步日志，当新节点已经可以跟上集群日志的时候再投票加入集群。</p><h5 id="旧节点干扰"><a href="#旧节点干扰" class="headerlink" title="旧节点干扰"></a>旧节点干扰</h5><p>&emsp;&emsp;当<code>C-new</code>被提交以后，就需要移除不在<code>C-new</code>中的节点。在<code>C-new</code>被提交后，需要移除的节点就接收不到<code>领导者</code>的心跳消息，这个时候这些节点认为<code>领导者</code>可能出现了故障，会发起选举，正常执行的<code>领导者</code>收到投票请求后会退回到<code>跟随者</code>状态等待新<code>领导者</code>被选出，虽然最终正确的<code>领导者</code>会被选出，但是频繁的选举流程会扰乱集群的可用性。<br>&emsp;&emsp;为了避免这个问题，<code>Raft</code>采用了<code>最小选举超时时间</code>的机制，当服务器在当前最小选举超时时间内收到一个请求投票 RPC，他不会更新当前的任期号或者投出选票，这样就避免了频繁的状态切换。</p><h5 id="领导者不在新集群中"><a href="#领导者不在新集群中" class="headerlink" title="领导者不在新集群中"></a>领导者不在新集群中</h5><p>&emsp;&emsp;还有一种可能是<code>领导者</code>不在新集群中，当配置文件从<code>C-old,new</code>变更到<code>C-new</code>时，领导者不在<code>C-new</code>中，这个时候就会在一段时间内发生旧节点管理新集群的情况。<br>&emsp;&emsp;<code>Raft</code>中解决方法很简单，当提交<code>C-new</code>成功的时候，自己的状态变为<code>跟随者</code>，这样<code>领导者</code>节点就只能在新集群中选出。</p><h3 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h3><p>&emsp;&emsp;<code>Raft</code>算法在运行的过程中，日志是不断累积的，但是在实际的系统中，无论是从日志占用的磁盘空间，还是新节点加入集群，同步日志的网络消耗来看，日志都不能无限的增长。<br>&emsp;&emsp;<code>Raft</code>采用快照的方法来压缩日志，快照时间点前的日志全部丢弃。</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/raft2/3.png?raw=true" width="70%" height="70%"></p><p>&emsp;&emsp;每个服务器根据已经提交的日志，独立创建快照，快照中包含；</p><ul><li>状态机最后应用的日志；</li><li>状态机最后应用日志的任期号；</li><li>状态机最后应用的配置文件内容；</li></ul><p>&emsp;&emsp;<code>领导者</code>周期性的发送一些快照给<code>跟随者</code>，与<code>领导者</code>，保持同步的节点已经提交了快照的内容，会直接丢弃，而运行缓慢或者新加入集群的服务器则不会有这个条目，就会接受并且应用的自己的状态机中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;在前两篇文章中已经介绍了&lt;code&gt;Raft&lt;/code&gt;算法的正常流程和对异常的处理，但是还有一些问题没有解决，比如当集群中有新的节点加入或者退出的时候，集群又该如何保证安全的提供服务呢？&lt;/p&gt;
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分布式一致性协议之Raft(二)</title>
    <link href="http://yoursite.com/2019/07/16/raft-1/"/>
    <id>http://yoursite.com/2019/07/16/raft-1/</id>
    <published>2019-07-16T12:29:09.000Z</published>
    <updated>2019-07-16T12:37:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在<a href="http://qyuan.top/2019/07/14/raft/" target="_blank" rel="noopener">「分布式一致性协议之Raft（一）」</a>中，描述了<code>Raft</code>在正常情况下的算法流程，但当节点崩溃的情况下会有一些异常，影响状态机顺序的执行相同的指令。</p><a id="more"></a><h3 id="领导人选举安全（Election-safety）"><a href="#领导人选举安全（Election-safety）" class="headerlink" title="领导人选举安全（Election safety）"></a>领导人选举安全（Election safety）</h3><p>&emsp;&emsp;选举安全性，即在一个任期内最多一个<code>领导人</code>被选出，如果有多余的领导人被选出，则被称为<code>脑裂（brain split）</code>，如果出现<code>脑裂</code>会导致数据的丢失或者覆盖。<code>Raft</code>通过下面两点保证了不会出现<code>脑裂的情况</code>；</p><ul><li>一个节点某一任期内最多只能投一票；</li><li>只有获得大多数选票才能成为领导人；</li></ul><p>&emsp;&emsp;通过增加约束避免了<code>脑裂</code>的情况出现，保证了同一时间集群中只有一个<code>领导者</code>。但是当一个节点崩溃了一段时间，他的状态机已经落后其他节点很多，突然他重启恢复被选举为<code>领导者</code>，这个时候，客户端发来的请求再经由他复制给其他节点的状态机执行，就会出现集群状态机状态不一致的问题。<br>&emsp;&emsp;其他算法可能会同步落后的日志给领导者，然后在由领导者复制日志给其他节点，但是<code>Raft</code>认为这样会增加算法的复杂性，直接放弃了这种方法，而是采用<code>拒绝</code>投票给那些日志没有自己新的节点。<br>&emsp;&emsp;通过比较两份日志中，最后一条日志条目的索引值和任期号，来定义谁的日志比较新。如果两份日志最后的条目的任期号不同，那么任期号大的日志更新。如果两份日志最后的条目任期号相同，那么日志比索引大的日志新。</p><blockquote><p><code>拒绝</code>日志比自己旧节点投票是基于这样一种思考，要当选领导者，就必须获得大多数节点的选票，意味着他必须至少比大多数节点的日志新或者一致，这样拒绝比自己旧日志节点的投票请求，就保证了状态比大多数节点落后的节点是不会当选领导者。</p></blockquote><p>&emsp;&emsp;如果一个<code>领导者</code>把日志复制到大多数其他节点，在应用到状态机之前崩溃了，新选出的领导者，是不知道被复制到大多数节点的日志是否应用到了状态机。</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/raft1/1.png?raw=true" width="70%" height="70%"></p><p>&emsp;&emsp;<b>(a)</b> 中，S1 是领导者，部分的复制了索引位置 2 的日志条目；<br>&emsp;&emsp;<b>(b) </b>中，S1 崩溃了，然后 S5 在任期 3 里通过 S3、S4 和自己的选票赢得选举，然后从客户端接收了一条不一样的日志条目放在了索引 2 处；<br>&emsp;&emsp;<b>(c)</b>中，S5 又崩溃了；S1 重新启动，选举成功，开始复制日志。在这时，来自任期 2 的那条日志已经被复制到了集群中的大多数机器上，但是还没有被提交；<br>&emsp;&emsp;<b>(d) </b>中，S1又崩溃了，S5 可以重新被选举成功（通过来自 S2，S3 和 S4 的选票），然后覆盖了他们在索引 2 处的日志。注意：<code>虽然s2复制日志过半，但是S5节点的任期号大，日志新，是可以接收S2选票</code>；反之S1在崩溃前把新接收到的日志复制到大多数机器中，如(e)所示的情况。<br>&emsp;&emsp;<b>(e)</b> 中那样，那么在后面任期里面这些新的日志条目就会被提交（因为S5 就不可能选举成功）。 这样在同一时刻就同时保证了，之前的所有老的日志条目就会被提交。</p><h3 id="候选者和跟随者安全性"><a href="#候选者和跟随者安全性" class="headerlink" title="候选者和跟随者安全性"></a>候选者和跟随者安全性</h3><p>&emsp;&emsp;<code>候选者</code>，<code>跟随者</code>奔溃以后，领导者就是简单的周期性的发送<code>RPC</code>请求，如果重启发生在节点处理完日志复制，响<code>RPC</code>请求之前，收到一样的<code>RPC</code>请求正常返回即可，没有任何问题。如果崩溃时间太长，重启以后落后其他节点日志太多，将会采取<code>快照</code>的方式进行恢复。</p><blockquote><p><code>Raft</code>的<code>RPC</code>请求是幂等的。</p></blockquote><h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><p>&emsp;&emsp;<code>Raft</code>的要求之一就是安全性不能依赖时间：整个系统不能因为某些事件运行的比预期快一点或者慢一点就产生了错误的结果。但是，可用性（系统可以及时的响应客户端）不可避免的要依赖于时间。这个时候就又会有一些限制；</p><ul><li>服务器故障的时间必须比消息交换的时间长，否则每当一个节点要收集到足够多选票的时候就宕机了，新一轮的投票又重复这个过程，导致足够的时间选出领导人。</li><li>广播的世界必须小于选举超时时间一个数量级，这样领导者才能发送稳定的心跳阻止跟随者进入候选人状态。</li><li>当领导者崩溃后，整个系统在大约等于选举超时时间中不可用，所以平均故障间隔时间要大于选举超时时间几个数量级，系统可用性才比较高。<blockquote><p>一般来说，广播时间在10毫秒左右，选举超时时间在300毫秒左右，服务器平均故障时间都大于一个月。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;在&lt;a href=&quot;http://qyuan.top/2019/07/14/raft/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;「分布式一致性协议之Raft（一）」&lt;/a&gt;中，描述了&lt;code&gt;Raft&lt;/code&gt;在正常情况下的算法流程，但当节点崩溃的情况下会有一些异常，影响状态机顺序的执行相同的指令。&lt;/p&gt;
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分布式一致性协议之Raft(一)</title>
    <link href="http://yoursite.com/2019/07/14/raft/"/>
    <id>http://yoursite.com/2019/07/14/raft/</id>
    <published>2019-07-14T12:38:08.000Z</published>
    <updated>2019-07-16T12:34:02.361Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<code>Raft</code>算法解决的核心问题是在分布式环境下如何保持集群状态的一致性，简而言之就是一组服务，给定一组操作，最后得到一致的结果。</p><a id="more"></a><p>&emsp;&emsp;<code>Raft</code>算法通过选举<code>领导人（leader）</code>，由领导人复制<code>日志（log）</code>到<code>跟随者（follower）</code>，跟随者执行日志指令来达到最后集群状态的一致，整个算法也分成了两部分，领导人如何选举和跟随者如何安全的执行日志指令。</p><h3 id="领导人选举"><a href="#领导人选举" class="headerlink" title="领导人选举"></a>领导人选举</h3><p>&emsp;&emsp;<code>Raft</code>算法中一个节点在任意时刻只能处在<code>领导人（leader）</code>，<code>候选人（candidate）</code>，<code>跟随者（follower）</code>，同时强调强领导来简化整个流程，所以他的日志数据流只能从领导人复制到跟随者，跟随者之间也不能传递日志。</p><blockquote><p>通常情况下，系统中只有一个领导人并且其他节点全部都是跟随者，跟随者都是被动的，他们不会发送任何请求，只是简单的响应来自领导者或者候选人的请求</p></blockquote><p>&emsp;&emsp;下面是三个状态的状态转换图；</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/raft/1.png?raw=true" width="70%" height="70%"></p><p>&emsp;&emsp;节点启动的时候，都是跟随者状态，在一段时间没有收到来自领导者的心跳，就从跟随者转变为候选人，发起选举；如果收到含自己的多数选票则转换到领导者；如果发现其他节点比自己更新，则切换到跟随者状态。为了确定其他节点比自己更新，<code>Raft</code>又引入了<code>任期（term）</code>的概念。</p><p>&emsp;&emsp;算法起始，任期是0，当有节点当选<code>领导者</code>时，任期号为<code>1</code>，新领导人选出后，任期在之前的任期号加<code>1</code>。当节点从跟随者转化为候选人的时候，任期号也要增加<code>1</code>。</p><blockquote><p>任期起到逻辑时钟的作用</p></blockquote><h5 id="选举流程"><a href="#选举流程" class="headerlink" title="选举流程"></a>选举流程</h5><p>&emsp;&emsp;当一个跟随者节点长时间没有收到领导者心跳包，猜测领导者节点可能挂了，发起新领导者节点选举。</p><ul><li>增加自己当前的<code>任期</code>，转换状态到<code>候选人</code>；</li><li>投自己一票，并且给其他节点发送请求给自己投票的请求；</li><li>等待其他节点回复，在等待过程中又可能发生下面的情况<ol><li>赢得选举，成为领导者；</li><li>被告知其他节点当选领导者，自己退回跟随者状态；</li><li>超时时间没有收到足够多的选票，则重复整个选举过程；</li></ol></li></ul><p>下面的这个gif就展示了这个过程；</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/raft/2.gif?raw=true" width="70%" height="70%"></p><h3 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h3><p>&emsp;&emsp;当选出了<code>领导人</code>系统就可以对外提供服务，客户端把请求发送给集群，如果是跟随者收到则转发给领导者，由领导者统一处理，领导人会调度这些请求，顺序告知所有跟随者，保证所有节点的状态一致。<br>&emsp;&emsp;<code>Raft</code>是基于复制状态机实现的，其核心思想就是<code>相同的初始状态 + 相同的输入 = 一致的最终状态</code>，领导者将客户端请求打包到一个个<code>log entry</code>，将这些<code>log entries</code>发送到所有跟随者节点，然后大家按相同顺序应用<code>log entry</code>中的命令，则状态肯定是一致的。</p><h5 id="复制流程"><a href="#复制流程" class="headerlink" title="复制流程"></a>复制流程</h5><ul><li>领导者接收请求打包到<code>log entry</code>；</li><li>领导者并行发送<code>log entry</code>到集群所有节点；</li><li>领导者收到大多数跟随者收到<code>log entry</code>的回复；</li><li>领导者应用<code>log entry</code>里面的命令到自己的状态机中，也就是执行命令；</li><li>领导者回复跟随者，并且让他们也执行<code>log entry</code>中命令，达到和自己一致的状态机；</li></ul><p>&emsp;&emsp;每个<code>log entry</code>中，除了需要执行的命令之外还有领导者节点的任期号，用于处理异常情况；同时我们也可以看到，当日志被复制到大多数节点，即可向客户端返回成功的消息，一旦返回了结果，就必须保证系统在任何异常情况都不会发送回滚。<br>&emsp;&emsp;<code>Raft</code>通过第一个阶段的<code>commited</code>和第二个阶段的<code>apply</code>，保证了状态机的一致性。</p><p>&emsp;&emsp;当然还有各种异常情况，我们下篇再讲，讨论细节(<em>╹▽╹</em>)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;&lt;code&gt;Raft&lt;/code&gt;算法解决的核心问题是在分布式环境下如何保持集群状态的一致性，简而言之就是一组服务，给定一组操作，最后得到一致的结果。&lt;/p&gt;
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出数字证书</title>
    <link href="http://yoursite.com/2019/07/01/ca/"/>
    <id>http://yoursite.com/2019/07/01/ca/</id>
    <published>2019-07-01T11:36:53.000Z</published>
    <updated>2019-07-01T11:50:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在<a href="http://qyuan.top/2019/06/23/tls/" target="_blank" rel="noopener">「详解TLS/SSL运行机制」</a>这篇文章中，在<code>TLS</code>握手的第三步中，用到了数字证书中的公钥，通过这篇文章，我们一起来看一下为什么会出现数字证书，以及它解决了什么问题。</p><a id="more"></a><h3 id="无数字证书场景"><a href="#无数字证书场景" class="headerlink" title="无数字证书场景"></a>无数字证书场景</h3><p>&emsp;&emsp;我们假设这样一种不使用证书进行<code>TLS</code>建立连接的场景；</p><p>&emsp;&emsp; 在<code>TLS/SSL</code>握手的第一步中，客户端（Client）发送明文消息<code>client_hello</code>给服务端（Server）。<br>&emsp;&emsp; 黑客在服务端收到<code>client_hello</code>之前，截获了这个消息，发送给客户端<code>伪造</code>的协商信息（server_hello）。<br>&emsp;&emsp; 客户端收到黑客发来的伪造的协商信息，如果不验证证书，继续进行后续的秘钥协商过程，流程也是可以走完。</p><p>&emsp;&emsp;后续的通信依然使用客户端和服务端协商的秘钥加密通信，但是问题显而易见，我们并没有和最初预想的服务端建立连接，而是和黑客的服务器建立连接。</p><blockquote><p>黑客可以冒充客户端再和真正的服务端建立连接，黑客作为中间人，监听转发通信。</p></blockquote><p>&emsp;&emsp;产生这个问题的根源在于，大家都可以生成公私钥对，而我们无法确认这对公私钥到底是属于谁，这个时候就需要一种方法可以证明一对公私钥的所有者是谁。</p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>&emsp;&emsp;数字证书是一个经<code>数字证书认证机构CA</code>（Certificate Authority）认证签名的文件，包含拥有者的公钥以及相关的身份信息。<br>&emsp;&emsp;用户想要获得证书，应该先向<code>CA</code>提出申请，<code>CA</code>验证申请者的身份后，为其分配一个公钥与其身份信息绑定，为该信息信息进行签名，作为证书的一部分，然后把整个证书发送给申请者。<br>&emsp;&emsp;当需要鉴别证书真伪时，只需要用<code>CA</code>的公钥对证书上的签名进行验证，验证通过则证书有效。</p><h3 id="证书结构"><a href="#证书结构" class="headerlink" title="证书结构"></a>证书结构</h3><p>&emsp;&emsp;证书的结构一般遵循<code>X.509</code>规范。<br><img src="https://raw.githubusercontent.com/Ice-Storm/ice-storm.github.io/master/images/ca/1.png" alt="Alt text"></p><p>字段含义</p><ul><li>版本： 使用<code>X.509</code>的版本，目前普遍使用<code>v3</code>版本；</li><li>序列号：<code>CA</code>分配给证书的一个整数，作为证书的唯一标识；</li><li>签名算法：<code>CA</code>颁发证书使用的签名算法；</li><li>有效期：包含证书的起止日期；</li><li>主体名：该证书拥有者的名称，如果与颁发者相同则说明证书是一个自签名证书；</li><li>公钥信息： 对外公开的公钥以及公钥算法；</li><li>扩展信息：通常包含证书的用法，<code>证书吊销列表（Certificate Revocation List，CRL）</code>的发布地址等可选字段；</li><li>签名：颁发者用私钥对证书信息的签名；</li></ul><p>可以通过查看浏览器查看网站证书来快速理解：<br><img src="https://raw.githubusercontent.com/Ice-Storm/ice-storm.github.io/master/images/ca/2.png" alt="Alt text"></p><h3 id="证书类型"><a href="#证书类型" class="headerlink" title="证书类型"></a>证书类型</h3><ul><li>自签名证书：自签名证书又称根证书，是自己发给自己的证书，证书的颁发者和主体同名；</li><li>本地证书：<code>CA</code>颁发给申请者的证书；</li><li>设备本地：设备根据CA证书给自己颁发的证书，证书中的颁发者名称是CA服务器的名称。</li></ul><h3 id="证书格式"><a href="#证书格式" class="headerlink" title="证书格式"></a>证书格式</h3><ul><li><code>PKCS#12</code>：<code>#12</code>是标准号，常见后缀是<code>.P12</code>，可包含私钥也可不包含私钥；</li><li><code>DER</code>：二进制格式保存证书，不包含私钥，常见后缀<code>.DER</code>;</li><li><code>PEM</code>：以ASCII格式保存的证书，可包含私钥，也可不包含私钥，常见后缀<code>.PEM</code>；</li></ul>]]></content>
    
    <summary type="html">
    
      数字证书
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="密码学" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="密码学" scheme="http://yoursite.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>详解TLS/SSL运行机制</title>
    <link href="http://yoursite.com/2019/06/23/tls/"/>
    <id>http://yoursite.com/2019/06/23/tls/</id>
    <published>2019-06-23T03:44:24.000Z</published>
    <updated>2019-06-23T03:46:50.658Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<code>TLS</code>传输层安全性协议（Transport Layer Security）及其前身<code>SSL</code>安全套接层（Secure Sockets Layer）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障，<code>TLS/SSL</code>协议位于网络OSI七层模型的会话层，用来加密通信。</p><a id="more"></a><h3 id="TLS-SSL握手过程"><a href="#TLS-SSL握手过程" class="headerlink" title="TLS/SSL握手过程"></a><code>TLS/SSL</code>握手过程</h3><p>&emsp;&emsp;第一步，客户端（Client）以明文的形式发起请求信息（client_hello），其中信息包含；</p><ul><li>客户端生成的随机数<code>random_C</code></li><li>支持的最高<code>TLS</code>协议版本</li><li>客户端支持的加密套件<code>cipher suites</code></li><li>支持的压缩算法列表</li><li>扩展字段</li></ul><blockquote><p> 身份加密套件包括： 身份认证算法Au ，采用的密钥交换算法（密钥协商），对称加密算法，信息摘要算法Mac（校验信息的完整性）</p></blockquote><hr><p>&emsp;&emsp;第二步，服务端（Server）收到客户端发来的请求以后，返回协商的信息（server_hello），其中包括</p><ul><li>服务端生成的随机数<code>random_S</code></li><li>使用<code>TLS</code>协议的版本</li><li>使用的压缩算法版本</li><li>选择的加密套件<code>cipher suites</code></li><li>服务端配置的对应的证书链</li></ul><hr><p>&emsp;&emsp;第三步，客户端（Server）收到服务端发来的请求以后，首先会检查服务端证书的合法性，如果合法就会进行如下操作；</p><ul><li>客户端生成第三个随机数字<code>pre-master</code></li><li>计算协商秘钥<code>enc_key=Func(random_C, random_S, pre-master)</code></li><li>计算之前通信的所有参数的hash作为<code>sessionSecret</code></li></ul><p>&emsp;&emsp;将<code>sessionSecret</code>和用证书携带的公钥加密<code>pre-master</code>发送给服务器（Server）</p><hr><p>&emsp;&emsp;第四步，服务端（Server）收到客户端发来的请求后，会进行如下操作</p><ul><li>用私钥解密或者<code>pre-master</code>的值</li><li>基于<code>random_S</code>，<code>random_C</code>和<code>pre-master</code>计算协商秘钥<code>enc_key=Func(random_C, random_S, pre-master)</code></li><li>验证<code>sessionSecret</code></li></ul><p>&emsp;&emsp;服务端进行完上面的操作以后，会用协商秘钥加密<code>sessionSecret</code>作为<code>encrypted_handshake_message</code>消息发送给客户端。</p><hr><p>&emsp;&emsp;第五步，客户端（Client）接收到<code>encrypted_handshake_message</code>消息以后，会用自己计算出的协商秘钥解密<code>encrypted_handshake_message</code>查看里面<code>sessionSecret</code>是否和自己生成的一致，如果一致则用协商出来的秘钥加密后续的通信。</p><h3 id="双向认证"><a href="#双向认证" class="headerlink" title="双向认证"></a>双向认证</h3><p>&emsp;&emsp;上面的整个过程，都是客户端单向认证服务端，也是最为常用的场景。同时，服务端也可以要求验证客户端，比较常见的场景就是大额网银汇款转账会需要在电脑上插入<code>U盾</code>。<br>&emsp;&emsp;<code>U盾</code>中包含银行签发的证书用来验证客户端。<br>&emsp;&emsp;双向认证在单向认证第二步的时候，服务器会要求客户端发送证书，来校验客户端证书有效性。</p>]]></content>
    
    <summary type="html">
    
      TLS/SSL秘钥协商算法
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="密码学" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="密码学" scheme="http://yoursite.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>ECDH秘钥协商算法原理</title>
    <link href="http://yoursite.com/2019/06/13/ecdh/"/>
    <id>http://yoursite.com/2019/06/13/ecdh/</id>
    <published>2019-06-13T10:43:15.000Z</published>
    <updated>2019-06-13T11:02:07.154Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<code>ECDH</code>全称是椭圆曲线迪菲-赫尔曼秘钥交换（Elliptic Curve Diffie–Hellman key Exchange），主要是用来在一个不安全的通道中建立起安全的共有加密资料，一般来说交换的都是<code>私钥</code>，这个密钥一般作为“对称加密”的密钥而被双方在后续数据传输中使用。</p><a id="more"></a><p>&emsp;&emsp;<code>ECDH</code>是建立在这样一个前提之上的，给定椭圆曲线上的一个点P，一个整数k，求Q=KP很容易；但是通过Q，P求解K很难。</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>&emsp;&emsp;我们通过一个经典的场景，Alice和Bob要在一条不安全的线路上交换秘钥，交换的秘钥不能被中间人知晓。<br>&emsp;&emsp;首先，双方约定使用<code>ECDH</code>秘钥交换算法，这个时候双方也知道了<code>ECDH</code>算法里的一个大素数<code>P</code>，这个<code>P</code>可以看做是一个算法中的常量。</p><blockquote><p><code>P</code>的位数决定了攻击者破解的难度</p></blockquote><p>&emsp;&emsp;还有一个整数<code>g</code>用来辅助整个秘钥交换，<code>g</code>不用很大，一般是2或者5，双方知道<code>g</code>和<code>p</code>之后就开始了<code>ECDH</code>交换秘钥的过程了。</p><hr><p>&emsp;&emsp;Alice知道了共用参数<code>p</code>和<code>g</code>，生成私有整数<code>a</code>作为私钥，公钥算法一般是公钥加密，私钥解密，公钥给对方来加密数据，拿到密文后私钥解密查看内容正确性，这个时候Alice直接通过线路告诉Bob自己的私钥<code>a</code>显然既不合理也是一件风险很大的事。</p><p>&emsp;&emsp;这个时候Alice需要利用<code>p</code>，<code>g</code>，<code>a</code>通过公式<code>g^a mod p = A</code>生成A作为公钥传递。</p><hr><p>&emsp;&emsp; Bob通过链路收到Alice发来的<code>p</code>，<code>g</code>，<code>A</code>，知道了Alice的公钥<code>A</code>。这个时候Bob也生成自己的私钥<code>b</code>，然后通过公式<code>g^b mod p = B</code>生成自己公钥<code>B</code>。<br>&emsp;&emsp; 在发送公钥<code>B</code>前，Bob通过<code>A^b mod p = K</code>生成K作为公共秘钥，但是并不发送给Alice，只通过链路发送<code>B</code>。</p><hr><p>&emsp;&emsp; Alice收到Bob发来的公钥<code>B</code>以后，同样通过<code>B^a mod p = K</code>生成公共秘钥K，这样Alice和Bob就通过不传递私钥<code>a</code>和<code>b</code>完成了对公共秘钥K的协商。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>&emsp;&emsp; 我们通过代入具体的数字来重复一下上面的过程。</p><p>&emsp;&emsp;1. Alice和Bob同意使用质数p和整数g：<br>&emsp;&emsp; p = 83, g = 8<br>&emsp;&emsp;<br>&emsp;&emsp; 2. Alice选择秘钥 a = 9, 生成公钥  g^a mod p = A 并发送<br>&emsp;&emsp; (8^9) mod 83 = 5<br>&emsp;&emsp;<br>&emsp;&emsp; 3. Bob选择秘钥 b = 21, 生成公钥 A^b mod p = K 并发送<br>&emsp;&emsp; (8^21) mod 83 = 18<br>&emsp;&emsp;<br>&emsp;&emsp; 4. Alice计算 B^a mod p = K<br>&emsp;&emsp; 18^9 mod 83 = 24<br>&emsp;&emsp;<br>&emsp;&emsp; 5. Bob计算 B^a mod p = K<br>&emsp;&emsp;  5^21 mod 83 = 24<br>&emsp;&emsp;<br>&emsp;&emsp; 至此<code>24</code>就是双方协商出来的秘钥。</p><h3 id="协议所面临的问题"><a href="#协议所面临的问题" class="headerlink" title="协议所面临的问题"></a>协议所面临的问题</h3><p>&emsp;&emsp;由于 ECDH 密钥交换协议不验证公钥发送者的身份，因此无法阻止中间人攻击。如果监听者 Mallory 截获了 Alice 的公钥，就可以替换为他自己的公钥，并将其发送给 Bob。Mallory 还可以截获 Bob 的公钥，替换为他自己的公钥，并将其发送给 Alice。这样，Mallory 就可以轻松地对 Alice 与 Bob 之间发送的任何消息进行解密。他可以更改消息，用他自己的密钥对消息重新加密，然后将消息发送给接收者。<br>&emsp;&emsp;为了解决此问题，Alice 和 Bob 可以在交换公钥之前使用数字签名对公钥进行签名。有两种方法可以实现此目的：</p><ul><li><p>用安全的媒体（例如语音通信或可信载运商）在双方之间传输数字签名密钥。</p></li><li><p>使用公共证书颁发机构 (CA) 向双方提供可信数字签名密钥。</p></li></ul><h3 id="区块链中的应用场景"><a href="#区块链中的应用场景" class="headerlink" title="区块链中的应用场景"></a>区块链中的应用场景</h3><p>&emsp;&emsp;当多个参与方共享同一个链路的时候，联盟链各参与方想要在同一个链路上实现通性的隔离，使用<code>ECDH</code>算法既可以实现TCP链接的复用，避免频繁建立大量链接，又可以保证同一链接间的通信隔离。</p><p>&emsp;&emsp;各参与方的身份在加入网络前已经有MSP（Membership Service Provider）来颁发验证过，这样就可以规避<code>ECDH</code>协议的缺陷。</p>]]></content>
    
    <summary type="html">
    
      ECDH秘钥协商算法
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="密码学" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="密码学" scheme="http://yoursite.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>以太坊TXpool分析</title>
    <link href="http://yoursite.com/2019/06/02/txpool/"/>
    <id>http://yoursite.com/2019/06/02/txpool/</id>
    <published>2019-06-02T09:21:15.000Z</published>
    <updated>2019-06-02T09:37:07.268Z</updated>
    
    <content type="html"><![CDATA[<h3 id="以太坊交易流程"><a href="#以太坊交易流程" class="headerlink" title="以太坊交易流程"></a>以太坊交易流程</h3><p>&emsp;&emsp;用户通过<code>Json RPC</code>向以太坊网络发送的交易请求最后都会被<code>go-ethereum/internal/ethapi/api.go</code>的<code>SendTransaction</code>函数所接收。</p><a id="more"></a><p>&emsp;&emsp;从接收用户传入的参数，到把交易放入交易池等待广播的流程如下图所示：</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/txpool/50786776.png?raw=true" alt="Alt text"></p><p>&emsp;&emsp;整个流程从<code>SendTransaction</code>接收到<code>SendTxArgs</code>开始, <code>SendTxArgs</code>的结构如下；<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SendTxArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">   From     common.Address  <span class="string">`json:"from"`</span></span><br><span class="line">   To       *common.Address <span class="string">`json:"to"`</span></span><br><span class="line">   Gas      *hexutil.Uint64 <span class="string">`json:"gas"`</span></span><br><span class="line">   GasPrice *hexutil.Big    <span class="string">`json:"gasPrice"`</span></span><br><span class="line">   Value    *hexutil.Big    <span class="string">`json:"value"`</span></span><br><span class="line">   Nonce    *hexutil.Uint64 <span class="string">`json:"nonce"`</span></span><br><span class="line">   Data  *hexutil.Bytes     <span class="string">`json:"data"`</span></span><br><span class="line">   Input *hexutil.Bytes     <span class="string">`json:"input"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<code>SendTransaction</code>首先需要根据<code>From</code>字段来找到当前的账户，为签名交易做准备。<br>&emsp;&emsp;接着开始对交易进行预处理，为<code>SendTxArgs</code>的一些空字段设置默认值，比如分配<code>Nonce</code>，根据<code>To</code>字段是否为空，来判断交易是部署合约还是发送交易等。<br>&emsp;&emsp;进行预处理之后，需要对交易进行<code>RLP</code>编码，再根据之前获得的账户私钥进行签名。<br>&emsp;&emsp;最后在把交易提交到<code>TXpool</code>。</p><h3 id="交易序列化"><a href="#交易序列化" class="headerlink" title="交易序列化"></a>交易序列化</h3><p>&emsp;&emsp;交易的序列化是通过<code>toTransaction</code>这个函数来完成的。<br>&emsp;&emsp;序列化的时候根据<code>To</code>字段是否为<code>nil</code>来判断是将交易序列化成交易，还是创建合约。<br> &emsp;&emsp;调用<code>SendTranstion</code>接口的<code>Data</code>和<code>Input</code>字段，最终都会被赋值给<code>Input</code>，再被序列化成<code>Payload</code>放入交易池（TXpool）中，现在保留<code>Data</code>字主要是为了向前兼容，目前推荐用<code>Input</code>字段。</p><blockquote><p>当部署合约的时候<code>Input</code>是合约的代码，当发送交易的时候<code>Input</code>是交易的内容</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(args *SendTxArgs)</span> <span class="title">toTransaction</span><span class="params">()</span> *<span class="title">types</span>.<span class="title">Transaction</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> input []<span class="keyword">byte</span></span><br><span class="line">   <span class="keyword">if</span> args.Data != <span class="literal">nil</span> &#123;</span><br><span class="line">      input = *args.Data</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> args.Input != <span class="literal">nil</span> &#123;</span><br><span class="line">      input = *args.Input</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> args.To == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> types.NewContractCreation(<span class="keyword">uint64</span>(*args.Nonce), (*big.Int)(args.Value), <span class="keyword">uint64</span>(*args.Gas), (*big.Int)(args.GasPrice), input)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> types.NewTransaction(<span class="keyword">uint64</span>(*args.Nonce), *args.To, (*big.Int)(args.Value), <span class="keyword">uint64</span>(*args.Gas), (*big.Int)(args.GasPrice), input)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最终序列化后的交易包含以下字段，需要注意的是不包含<code>From</code>字段，把交易和发送者解耦以后可以支持域名地址，提供了更多的可能性。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> txdata <span class="keyword">struct</span> &#123;</span><br><span class="line">   AccountNonce <span class="keyword">uint64</span>          <span class="string">`json:"nonce"    gencodec:"required"`</span></span><br><span class="line">   Price        *big.Int        <span class="string">`json:"gasPrice" gencodec:"required"`</span></span><br><span class="line">   GasLimit     <span class="keyword">uint64</span>          <span class="string">`json:"gas"      gencodec:"required"`</span></span><br><span class="line">   Recipient    *common.Address <span class="string">`json:"to"       rlp:"nil"`</span> <span class="comment">// nil means contract creation</span></span><br><span class="line">   Amount       *big.Int        <span class="string">`json:"value"    gencodec:"required"`</span></span><br><span class="line">   Payload      []<span class="keyword">byte</span>          <span class="string">`json:"input"    gencodec:"required"`</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Signature values</span></span><br><span class="line">   V *big.Int <span class="string">`json:"v" gencodec:"required"`</span></span><br><span class="line">   R *big.Int <span class="string">`json:"r" gencodec:"required"`</span></span><br><span class="line">   S *big.Int <span class="string">`json:"s" gencodec:"required"`</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// This is only used when marshaling to JSON.</span></span><br><span class="line">   Hash *common.Hash <span class="string">`json:"hash" rlp:"-"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>r,s,v是交易签名后的值，它们可以被用来生成签名者的公钥；R，S是ECDSA椭圆加密算法的输出值，V是用于恢复结果的ID</p></blockquote><p>&emsp;&emsp;用户私钥签名序列化的交易以后就会被放入到交易池中。</p><h3 id="交易池"><a href="#交易池" class="headerlink" title="交易池"></a>交易池</h3><p>&emsp;&emsp;无论是本节点创建的交易(<code>local</code>)还是其他节点广播过来的交易(<code>remote</code>)，都会缓存在<code>TXpool</code>中，当需要生成区块时，就从<code>TXpool</code>中选择合适的交易打包成块，经由共识最终确认。<br>&emsp;&emsp;<code>TXpool</code>的核心功能</p><ul><li>缓存交易</li><li>在打包区块前，对交易进行验证</li><li>过滤无效交易</li><li>惩罚恶意发送大量交易的账户</li></ul><p>&emsp;&emsp;<code>TXpool</code>的核心结构如下图；</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/txpool/71987537.png?raw=true" alt="Alt text"></p><p>&emsp;&emsp;<code>TXpool</code>最为核心的结构是两个Map<code>queued</code>和<code>pending</code>，用来存未验证的交易和验证过的交易。</p><h4 id="添加交易"><a href="#添加交易" class="headerlink" title="添加交易"></a>添加交易</h4><p>&emsp;&emsp;添加交易到<code>TXpool</code>的过程比较简单，总体流程是这样的；</p><ul><li>验证交易的有效性</li><li>判断交易的<code>price</code>是否大于缓存中最小的，如果小于就拒收，如果大于就删除最小的交易，把本次交易插入<code>pending</code></li><li>如果这个<code>nonce</code>已经存在，依然是按照<code>price</code>的大小进行替换</li><li>如果交易有效，不能替换<code>pending</code>里面的任何交易，则添加到<code>queued</code>中</li></ul><h4 id="清理交易池"><a href="#清理交易池" class="headerlink" title="清理交易池"></a>清理交易池</h4><p>&emsp;&emsp;<code>TXpool</code>存在内存中，不可能无限大，等超过一定阈值就需要对交易池里面的交易进行清理。</p><blockquote><p>pending的缓冲区容量默认是 4096，queued的缓冲区容量默认是1024</p></blockquote><p>&emsp;&emsp;清理交易分为清理<code>queued</code>和清理<code>pending</code>，清理顺序<code>queued</code>-&gt;<code>pending</code>-&gt;<code>queued</code></p><hr><p>&emsp;&emsp;当满足以下条件的时候就会清理<code>queued</code></p><ul><li>当<code>nonce</code>小于当前账号发送<code>noce</code>的最小值，也就是说之前的交易已经全部上链</li><li>当前的<code>nonce</code>符合条件可以移动到<code>pending</code>队列中，先从<code>queued</code>清除，然后移动（<code>send</code>）到<code>pending</code>中</li><li>账户余额不足以支持该交易的花费了</li><li>交易数量超过了缓冲区</li></ul><blockquote><p>清理<code>queued</code>会影响<code>pending</code>的大小，所以<code>queued</code>清理优先级高</p></blockquote><hr><p>&emsp;&emsp;清理<code>pending</code>时，首先把超过每个账户可执行交易数量(<code>AccountSlots</code>)的数量，按照从大到小记录下来，接着按照从多到少删除。<br>&emsp;&emsp;举个例子来说明剔除的规则；</p><blockquote><p>假如<code>AccountSlots</code>为4<br>有四个超出的账户，它们的数量分别是10， 9， 7，5<br>第一次剔除 [10]             剔除结束 [10]<br>第二次剔除 [10, 9]         剔除结束 [9，9]<br>第三次剔除 [9, 9, 7]       剔除结束 [7, 7, 7]<br>第四次剔除 [7, 7 , 7 ,5]  剔除结束 [5，5，5，5]<br>这个时候如果还是超出限制，则继续剔除<br>第五次剔除 [5, 5 , 5 ,5]  剔除结束 [4，4，4，4]</p></blockquote><hr><p>&emsp;&emsp;接着清理<code>ququed</code>，规则也很简单，越先进入queued的越后删除，直到清理到满足最大队列长度（<code>GlobalQueue</code>）为止。</p><h3 id="重构交易池-reset"><a href="#重构交易池-reset" class="headerlink" title="重构交易池(reset)"></a>重构交易池(<code>reset</code>)</h3><p>&emsp;&emsp;到这一步还有一个问题没有解决，以太坊是分布式系统，当本地节点已经挑选出最优的交易，准备广播给整个网络，这个时候矿工已经打包了一个区块，本地节点的区块头就是旧的了，本地筛选的交易有可能已经被打包，如果已经被打包生成了新区块，再将这个交易广播已经没有任何的意义，甚至我们费尽心思准备好的<code>pending</code>缓冲区里的交易都是无效的。<br>&emsp;&emsp;为了避免上面的情况发生，我们就需要监听链是否有新区块产生，也就是<code>ChainHeadEvent</code>事件。<br>&emsp;&emsp;当监听到<code>ChainHeadEvent</code>事件时候，我们又该如何调整<code>queued</code>和<code>pending</code>呢？<br>&emsp;&emsp;首先需要将已经分叉的链回退到同一个区块号上(<code>blockNumebr</code>)，有可能是本地节点领先，有可能是网络上其他节点领先，但无论怎样，都回退到同一个区块号。</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/txpool/59517862.png?raw=true" alt="Alt text"></p><p>&emsp;&emsp;本地节点回退时，撤销的交易保存到<code>discarded</code>切片中，网络上其他节点的撤销交易保存在<code>included</code>切片中。<br>&emsp;&emsp;当区块号一致的时候，还需要进一步的比较区块的<code>Hash</code>来进一步确认区块里面的交易是否一致，如果不一致一致回退到区块<code>Hash</code>为止，回退撤销的交易依旧保存在<code>discarded</code>和<code>included</code>切片中。<br>&emsp;&emsp;等完全确认本地和网络的链没有分叉的时候，就需要比较<code>discarded</code>和<code>included</code>里面的交易，因为网络上区块的生成优先级高于本地，所以需要剔除<code>discarded</code>中<code>inclueded</code>的交易，生成<code>reinject</code>切片，剔除完以后还需要对<code>TXpool</code>按照网络新生成区块的信息设置世界状态等信息，设置完以后，重新将<code>reinject</code>加入<code>TXpool</code>，加入以后在进行验证清理等流程。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考:"></a>思考:</h3><ul><li><p>以太坊在实现<code>TXpool</code>的时候为了保证数据的一致性使用大量的锁，性能一般。</p></li><li><p>当区块生成速度比较快的时候需要频繁的<code>reset</code>，导致<code>TXpool</code>需要占用比较多的资源。</p></li><li><p>是否有比较好的方法既可以保证数据的一致性又可以快速找到相同的根区块？</p></li></ul>]]></content>
    
    <summary type="html">
    
      以太坊TXpool源码分析
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="以太坊" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="以太坊" scheme="http://yoursite.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
  <entry>
    <title>以太坊RLP编码</title>
    <link href="http://yoursite.com/2019/05/20/rlp/"/>
    <id>http://yoursite.com/2019/05/20/rlp/</id>
    <published>2019-05-20T07:54:29.000Z</published>
    <updated>2019-08-27T12:23:16.943Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<code>RLP（Recursive Length Prefix）</code>递归长度前缀编码，<code>RLP</code>主要用于以太坊中数据的网络传输和持久化存储。</p><a id="more"></a><h3 id="为什么需要RLP编码"><a href="#为什么需要RLP编码" class="headerlink" title="为什么需要RLP编码"></a>为什么需要<code>RLP</code>编码</h3><p>&emsp;&emsp;比较常见的序列化方法有<code>JSON</code>，<code>ProtoBuf</code>，但是这些序列化方法在以太坊这样的场景下都有一些问题。</p><p>&emsp;&emsp;比如像<code>Json</code>编码，编码后的体积比较大。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Persion <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">uint</span> </span><br><span class="line">&#125;</span><br><span class="line">    p := &amp;Persion&#123;Name: <span class="string">"Tom"</span>, Age: <span class="number">22</span>&#125;</span><br><span class="line">    data, _ := json.Marshal(p)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line"><span class="comment">//  &#123;"Name":"Tom","Age":22&#125;</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;从编码后的结果可以看到，其实我们需要的数据是<code>Name</code>, <code>Tom</code>, <code>Age</code>, <code>22</code>，其余的括号和引号都是描述这种格式的，也就是冗余数据。<br>&emsp;&emsp;当然，会有人说可以用<code>protoBuf</code>这样的二进制格式，但是例如<code>JavaScript</code>这样的弱类型语言，是没有<code>int</code>类型的，所有数字都是用<code>Number</code>类型，底层用浮点数来实现，这样就会导致因为语言的不同编码后的数据有一定差异，最后得到的hash值也不同。<br>&emsp;&emsp;针对这些问题，以太坊设计了<code>RLP</code>编码，同时也大幅简化了编码规则。</p><h3 id="RLP编码定义"><a href="#RLP编码定义" class="headerlink" title="RLP编码定义"></a><code>RLP</code>编码定义</h3><p><code>RLP</code>简化了编码的类型，只定义了两种类型编码：</p><ul><li>byte数组</li><li>byte数组的数组，也就是列表</li></ul><h3 id="RLP编码基于上面两种数据类型提出了5条编码规则"><a href="#RLP编码基于上面两种数据类型提出了5条编码规则" class="headerlink" title="RLP编码基于上面两种数据类型提出了5条编码规则;"></a><code>RLP</code>编码基于上面两种数据类型提出了5条编码规则;</h3><h5 id="规则一"><a href="#规则一" class="headerlink" title="规则一"></a>规则一</h5><p>&emsp;&emsp;对于值在[0, 127]之间的单个字节，其编码是其本身；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a的编码是97</span><br></pre></td></tr></table></figure></p><h5 id="规则二"><a href="#规则二" class="headerlink" title="规则二"></a>规则二</h5><p>&emsp;&emsp;如果byte数组的长度<code>l&lt;=55</code>，编码的结果是数组本身，再加上<code>128+l</code>作为前缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">空字符串的编码是`128`，即 `128=128+0`</span><br><span class="line">`abc`的编码是`131 97 98 99`，其实`131=128+len(&quot;abc&quot;)`, `97 98 99`依次是`a b c`</span><br></pre></td></tr></table></figure></p><h5 id="规则三"><a href="#规则三" class="headerlink" title="规则三"></a>规则三</h5><p>&emsp;&emsp;如果数组长度大于<code>55</code>，编码结果第一个值是<code>183（128+55）</code>加数组长度的编码的长度，然后是数组长度本身的编码，最后是byte数组的编码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编码一个重复1024次&quot;a&quot;的字符串，其结果是`185 4 0 97 97 97 ...`</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;1024按照<code>大端编码</code>是<code>0000 0000 001</code>转换为十进制是<code>0 0 4 0</code>，省略前面的<code>0</code>,长度为2， 因此<code>185 = 183 + 2</code></p><h5 id="规则四"><a href="#规则四" class="headerlink" title="规则四"></a>规则四</h5><p>&emsp;&emsp;如果列表长度小于55，编码结果第一位是192加列表长度的编码的长度，然后依次连接各个子列表的编码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`[&quot;abc&quot;, &quot;def&quot;]`的编码结果是`200 131 97 98 99 131 100 101 102`</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;其中<code>abc</code>的编码是<code>131 97 98 99</code>, <code>131 = 128 + l</code>长度是4，<code>def</code>的编码是<code>131 100 101 102</code>，长度是4，总长度为<code>8</code>，编码结果的第一位<code>200 = 192 + 8</code></p><h5 id="规则五"><a href="#规则五" class="headerlink" title="规则五"></a>规则五</h5><p>&emsp;&emsp;如果列表的长度超过55，编码结果第一位是<code>247(192 + 55)</code>加列表长度的编码长度，然后是列表本身的编码，最后依次连接子列表的编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;The length of this sentence is more than 55 bytes, &quot;, &quot;I know it because I pre-designed it&quot;]</span><br></pre></td></tr></table></figure></p><p>的编码结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">248 88 179 84 104 101 32 108 101 110 103 116 104 32 111 102 32 116 104 105 115 32 115 101 110116 101 110 99 101 32 105 115 32 109 111 114 101 32 116 104 97 110 32 53 53 32 98 121 116 101115 44 32 163 73 32 107 110 111 119 32 105 116 32 98 101 99 97 117 115 101 32 73 32 112 114101 45 100 101 115 105 103 110 101 100 32 105 116</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中前两个字节的计算方式如下：</p><ul><li><p><code>248 = 247 + 1</code></p></li><li><p><code>88 = 86 + 2</code>， 在规则3的示例中，长度为86，而在此例中，由于有两个子字符串，每个子字符串本身的长度的编码各占1字节，因此总共占2字节。</p></li><li><p>第3个字节<code>179</code>依据规则2得出</p></li></ul><p>第55个字节<code>163</code>同样依据规则2得出<code>163=128+35</code></p><blockquote><p>其中<code>规则三</code>，<code>规则四</code>，<code>规则5</code>是递归定义的，就是可以允许嵌套</p></blockquote>]]></content>
    
    <summary type="html">
    
      以太坊RLP编码分析
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="以太坊" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="Etherum" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/Etherum/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="以太坊" scheme="http://yoursite.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
  <entry>
    <title>白话布隆过滤器（Bloom Filter）</title>
    <link href="http://yoursite.com/2019/04/30/BloomFilter/"/>
    <id>http://yoursite.com/2019/04/30/BloomFilter/</id>
    <published>2019-04-30T14:46:08.000Z</published>
    <updated>2019-04-30T14:49:56.001Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;要判断一个元素是不是在一个集合里，比较容易想到的方法是用数组，链表这样的数据结构把元素保存起来，然后依次比较来确定。<br>&emsp;&emsp;但是随着集合的变大，上面的这种方法就面临几个问题，首先比较的速度随着数据量的增加而变慢，其次存储集合的空间也越来越大。<br>&emsp;&emsp;为了解决上面的问题，就引入了<code>布隆过滤器（Bloom Filter）</code></p><a id="more"></a><h3 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h3><p>&emsp;&emsp;布隆过滤器的原理就是当一个元素被加入到集合的时候，用<code>K</code>个<code>Hash</code>函数将元素映射到一个<code>位图</code>中的<code>K</code>个点，并且把这个点的值设置为<code>1</code>，在每次检索的时候我们看一下这个点是不是都是<code>1</code>就知道集合中有没有这个元素了。<br>&emsp;&emsp;这样说可能比较抽象，举个例子：</p><p>&emsp;&emsp;我们假设<code>K</code>是<code>2</code>，有<code>Hash1</code>和<code>Hash2</code>两个哈希函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hash1 = n%3</span><br><span class="line">Hash2 = n%8</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后我们创建一个名叫<code>bitMap</code>长度是<code>20</code>的<code>位图</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitMap=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这个时候，我们要将7，存入到这个集合中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = 7</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;分别用<code>Hash1</code>和<code>Hash2</code>计算<code>n</code>哈希后的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hash1  -&gt;  1</span><br><span class="line">Hash2  -&gt;  7</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我们把<code>bitMap</code>对应的值置为1，从0开始<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitMap=[0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这样下次我们来查找<code>7</code>在不在这个集合的时候就可以用<code>Hash1</code>和<code>Hash2</code>计算完以后在<code>bitMap</code>集合中查找对应位置是否都是<code>1</code>，如果都是<code>1</code>则一定在集合中。</p><p>&emsp;&emsp;如果再在集合中插入13<br>&emsp;&emsp;分别用<code>Hash1</code>和<code>Hash2</code>计算<code>n</code>哈希后的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n = 13</span><br><span class="line">Hash1  -&gt;  1</span><br><span class="line">Hash2  -&gt;  5</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我们把<code>bitMap</code>对应的值置为1，从0开始<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitMap=[0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这个时候我们发现<code>1</code>被映射到了两次，但是并不影响我们在集合<code>[7, 13]</code>中快速找到7或者13。</p><p>&emsp;&emsp;但是当插入的数据量大幅提升的时候，甚至<code>bitMap</code>全部被置为<code>1</code>的时候问题就很严重了，误识率就非常高了，这个也是根据不同场景实现布隆过滤器所要考虑的问题。</p><p>&emsp;&emsp;尽管有这样的问题，但是仍然不能掩盖布隆过滤器的<code>空间利用率</code>和<code>查询时间</code>远超其他算法，插入数据和查询数据的时间复杂度都是<code>O(k)</code></p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>&emsp;&emsp;比较典型的应用场景就是检查垃圾邮箱的地址，比如我建立了一个垃圾邮件的布隆过滤器，当新邮件到来的时候我要快速的判断这封邮件是不是垃圾邮件。<br>&emsp;&emsp;还可以用来判断一个URL是不是恶意链接等等。<br>&emsp;&emsp;以太坊大量的用到了布隆过滤器，用来定位查找日志等。</p>]]></content>
    
    <summary type="html">
    
      深入理解布隆过滤器
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>深入理解`BucketTree`</title>
    <link href="http://yoursite.com/2019/04/18/BucketTree/"/>
    <id>http://yoursite.com/2019/04/18/BucketTree/</id>
    <published>2019-04-18T12:16:32.000Z</published>
    <updated>2019-04-18T12:42:46.707Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Bucket Tree结合了默克尔树和哈希表的特点，如果想要深入了解Bucket Tree就必须掌握默克尔树和哈希表。</p><p>&emsp;&emsp;Merkle Tree大多用来进行对比验证处理，特别是在分布式环境下进行比对或验证的时候可以大大减少数据传输量和计算的复杂度。</p><a id="more"></a><h3 id="默克尔树结构解析"><a href="#默克尔树结构解析" class="headerlink" title="默克尔树结构解析"></a><code>默克尔树结构解析</code></h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>默克尔树是一种树，一般是二叉树，也可以是多叉树；</li><li>默克尔树的叶子节点可以是数据项，也可以是数据项的哈希值；</li><li>非叶子节点的数据项是由其叶子节点Hash计算得到的；</li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>&emsp;&emsp;默克尔树是自底向上构建的，下面就是一颗典型的默克尔树。</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/bucketTree/1.jpg?raw=true" alt="Alt text"></p><p>&emsp;&emsp;首先计算ENTRY1-ENTRY4单元的数据哈希，然后分别存入到对应的叶子节点，这些叶子节点分别是HASH0-0,HASH0-1,HASH1-0,HASH1-1。<br>接着将相邻节点的哈希值合并成一个字符串，然后计算这个字符串的哈希值，得到的就是这两个节点父节点的哈希值。</p><p>&emsp;&emsp;如果用公式表示的话就是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HASH 0 = Hash（HASH 0-0 + HASH 0-1）、</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;如果树节点的个数是单数，就对它直接进行哈希运算，或者复制一次这个节点的哈希值，凑齐偶数个节点。</p><p>&emsp;&emsp;重复上述过程，自底向上就可以构建整个默克尔树了。</p><h5 id="Tips"><a href="#Tips" class="headerlink" title="Tips:"></a>Tips:</h5><ul><li>若两颗树的根哈希一直，则这两棵树的结构，节点内容必然相同。</li></ul><h4 id="默克尔树的优势"><a href="#默克尔树的优势" class="headerlink" title="默克尔树的优势"></a>默克尔树的优势</h4><p>&emsp;&emsp;当一个节点内容发生变化的时候，仅需要计算从该节点到根路径上所有节点节点的哈希，减少计算量，同时也方便快速定位数据发生变化的位置。</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a><code>哈希表</code></h3><p>&emsp;&emsp;哈希表也称散列表，根据键（key）快速定位值（value）的存储位置的数据结构。</p><h3 id="Bucket-Tree"><a href="#Bucket-Tree" class="headerlink" title="Bucket Tree"></a><code>Bucket Tree</code></h3><p>&emsp;&emsp;Bucket Tree拓展了哈希表的概念，引入了一个桶（bucket），也就是哈希桶。<br>&emsp;&emsp;其结构如下图所示:</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/bucketTree/2.jpg?raw=true" alt="Alt text"></p><p>&emsp;&emsp;KEY2和KEY3映射到相同的152号桶里。￼</p><p>&emsp;&emsp;Bucket tree在扩展哈希表的同时，又在哈希表上建立了默克尔树。</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/bucketTree/3.jpg?raw=true" alt="Alt text"></p><p>&emsp;&emsp;哈希表由一系列的哈希桶（bucket）组成，每个桶中存储着若干被散列到该桶中的数据项（entry）所以数据项按序排列，每一个哈希桶有一个哈希值来标识整个桶，该哈希值是桶内所有数据通过哈希计算所得。</p><p>&emsp;&emsp;除了底层的哈希表外，上层是一系列的默克尔树节点，一个默克尔树节点对应着下层的N个哈希桶或者默克尔树节点，这个N也称作默克尔树的聚合度。</p><h4 id="如此设计的目的："><a href="#如此设计的目的：" class="headerlink" title="如此设计的目的："></a>如此设计的目的：</h4><ul><li>​利用默克尔树的特点，使每次树状态改变，重新计算哈希的代价最小；</li><li>利用哈希表进行底层数据的维护，使得数据项均匀分布；</li></ul><p>&emsp;&emsp;例如上图中，一条新的数据项entry5插入，该数据项被散列到POS为1的桶中。该桶，即从该桶至根节点上所有的节点被标为粉红色，即为脏节点。仅对这些脏节点进行哈希重计算，便可得到一个新的哈希值用来代表新的树状态。</p><p>&emsp;&emsp;由于bucket tree是一棵固定大小的树（即底层的哈希表容量在树初始化之后，就无法更改了），随着数据量的增大，采用散列函数将所有的数据项进行均匀散列可以避免数据聚集的情况发生。</p><h4 id="Bucket-tree有两个重要的可调参数："><a href="#Bucket-tree有两个重要的可调参数：" class="headerlink" title="Bucket tree有两个重要的可调参数："></a>Bucket tree有两个重要的可调参数：</h4><ul><li>​capacity：表示哈希表的容量，该值越大，整课树所能容纳的数据项个数就越多，在聚合程度不变的前提下，树越高，从叶子节点到根节点的路径越长，哈希计算次数也越多。</li><li>aggreation：表示一个父节点对应的孩子节点的个数，该值越大，表示树的收敛速度越快，在哈希表容量不变的前提下，树更低，从叶子节点到根节点路径越短，哈希计算次数也越少。但是每个默克尔树节点的size就越大，增加磁盘IO开销。</li></ul><h5 id="Tips-1"><a href="#Tips-1" class="headerlink" title="Tips:"></a>Tips:</h5><ul><li>​当有比较多数据变更的时候，非常容易散列到不同bucket，这个时候可以并行计算新bucket的哈希值，加速构建默克尔树。</li><li>如果Bucket tree树比较大，并且用数据库来存储的话，加上读cache可以显著的提升性能。</li></ul>]]></content>
    
    <summary type="html">
    
      Hyperledger Fabric区块链的世界状态组织形式
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="账本" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E8%B4%A6%E6%9C%AC/"/>
    
      <category term="世界状态" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E8%B4%A6%E6%9C%AC/%E4%B8%96%E7%95%8C%E7%8A%B6%E6%80%81/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Kademlia算法原理详解</title>
    <link href="http://yoursite.com/2018/08/28/kad/"/>
    <id>http://yoursite.com/2018/08/28/kad/</id>
    <published>2018-08-28T14:22:44.000Z</published>
    <updated>2019-07-14T12:40:25.615Z</updated>
    
    <content type="html"><![CDATA[<p>P2P网络有四个发展阶段：<code>集中式网络</code>，<code>纯分布式网络</code>，<code>混合式网络</code>，<code>结构化网络</code>。</p><a id="more"></a><h3 id="集中式网络"><a href="#集中式网络" class="headerlink" title="集中式网络"></a><code>集中式网络</code></h3><p><code>集中式</code>的P2P网络最简单，即一个节点保存了其他所有节点的索引信息，而索引信息又包括了节点IP，端口，节点资源等。节点之间互连的路由查询由中心节点完成，一旦和对等节点建立连接则与中心节点没有什么联系。集中式的P2P网络结构简单，实现容易，但是由于所有路由信息在中心节点存储，当节点数量变多扩展的时候容易出现性能瓶颈，也容易出现单点故障。</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/kad/1.jpg?raw=true" width="70%" height="70%"></p><h3 id="纯分布式网络"><a href="#纯分布式网络" class="headerlink" title="纯分布式网络"></a><code>纯分布式网络</code></h3><p><code>纯分布式</code>的P2P网络移除了中心节点，在P2P网络之间建立了随机网络，一个新加入的节点和P2P网络中的某个随机节点建立连接，从而形成一个随机的拓扑结构。新节点和邻居节点建立连接以后还需要全网广播，让整个网络知道自己的存在。</p><p>全网广播的方式是，该节点向自己的邻居节点广播，邻居节点收到消息以后在向自己的邻居节点广播，以此类推，从而广播到整个网络。这种广播也称为泛洪机制。</p><p>纯分布式的P2P网络不存在集中式网络的单点故障和中心性能瓶颈的问题，具有较好的扩展性，但是泛洪机制又引入了新的问题，一是容易形成泛洪循环，A节点发出的消息经过节点B到节点C，节点C在<br>广播到节点A，形成了一个消息循环；另一个是响应消息风暴的问题，如果节点A想请求的资源被很多节点所拥有，那么在短时间内就会出现大量的节点向A节点发送响应消息，可能会让节点A崩溃。</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/kad/2.jpg?raw=true" width="70%" height="70%"></p><h3 id="混合式网络"><a href="#混合式网络" class="headerlink" title="混合式网络"></a><code>混合式网络</code></h3><p><code>混合式</code>的P2P网络就是混合了<code>集中式</code>和<code>纯分布式</code>的结构，网络中存在多个超级节点组成分布式网络，而每个超级节点则与多个普通节点组成局部的集中式网络。一个新的普通节点加入网络需要先选择一个超级节点通信，该超级节点在推送其他超级节点列表给新加入的节点，加入节点在根据超级节点列表中的状态选择加入哪个超级节点作为父节点。这种结构限制了泛洪广播的范围，避免了大规模的泛洪问题。<br>在实际应用中，<code>混合式</code>结构是相对灵活且比较有效的网络架构，实现也相对容易。</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/kad/3.jpg?raw=true" width="70%" height="70%"></p><h3 id="结构化网络"><a href="#结构化网络" class="headerlink" title="结构化网络"></a><code>结构化网络</code></h3><p><code>结构化P2P网络</code>也是一种分布式网络结构，但又与<code>纯分布式</code>有所区别。<code>纯分布式</code>网络就是一个随机网络，而结构化网络则将所有节点按照某种结构有序的组织起来，比如形成一个环状网络或者树状的网络。<br>结构化网络的具体实现上普遍都是基于DHT(Distributed Hash Table，分布式哈希表) 算法。具体的实现方案有 Chord、Pastry、CAN、Kademlia 等算法，其中 Kademlia 也是以太坊网络的实现算法，后面中重点讲解它的实现原理。</p><h2 id="Kad算法原理"><a href="#Kad算法原理" class="headerlink" title="Kad算法原理"></a><code>Kad</code>算法原理</h2><p><code>Kad</code>算法用来在分布式环境中准确的路由，定位数据。</p><p>在Kad网络中每个节点都有一个随机产生的160bit的标识符作为节点ID，Kad算法通过计算节点ID间的距离来快速路由和定位资源。</p><p>Kad算法通过异或节点ID来计算节点之间的距离，这个距离是逻辑上的距离并不是节点间物理上的距离。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">节点A的ID（010）</span><br><span class="line">节点B的ID（110）</span><br><span class="line">A ⊕ B = 100（二进制） = 4（十进制）</span><br></pre></td></tr></table></figure><p>在上面异或度量节点距离的基础之上，Kad算法还可以将整个网络划分成一个二叉前缀树，每个节点映射到二叉树上的某个叶子。</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/kad/kbucket.png?raw=true" width="80%" height="80%"></p><p>映射规则：</p><ul><li>将节点ID（160bit）从高到低依次分层，第N位就对应了第N层</li><li>如果是0进入左子树，如果是1则进入右子树</li><li>每个节点就对应树中的一个叶子</li></ul><p>在这种二叉树结构下，对于每个节点来说离他它越近的值节点的异或距离也越近，每一个节点都可以从自己的视角来对二叉树进行拆分，拆分规则是从根节点开始，把不包含自己的子树拆分出来，然后在剩下的子树再拆分不包含自己的下一层子树，以此类推，直到最后只剩下自己。上图的例子就是以节点ID为110的视角多二叉树进行了拆分。</p><p>因为Kad算法默认的节点ID是160bit，所有拆分以后最多可以有160课子树，而对于每个子树，如果我们分别知道里面的一个节点，就可以利用这个节点递归路由到子树的任意一个节点。</p><p>但是在实际应用中，由于节点是动态增加减少的，如果知道的节点恰好宕机或者下线了就会出现问题，为了保证系统的鲁棒性Kad算法又引入了K桶（K-bucket）的机制。</p><h3 id="K桶（k-bucket）"><a href="#K桶（k-bucket）" class="headerlink" title="K桶（k-bucket）"></a>K桶（<code>k-bucket</code>）</h3><p>节点在完成拆分子树以后需要记录每个子树里面K个节点，K可以由用户自己定义，在BT下载使用的Kad算法中K是8。</p><p><code>K-bucket</code>实际上就是路由表，每个节点按照自己的视角拆分完子树以后可以得到N个子树，那就需要维护N个路由表，对应N个K-bucket.</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/kad/k_bucket.png?raw=true" width="80%" height="80%"></p><p>每个节点维护N个K-bucket以后还会出现一个问题，K-bucket中的节点也会动态的增减，那又如何K-bucket的稳定呢？</p><h3 id="K桶的更新机制"><a href="#K桶的更新机制" class="headerlink" title="K桶的更新机制"></a>K桶的更新机制</h3><p><code>K-bucket</code>主要有三种方式来更新路由表。</p><ul><li>主动收集节点，主动发起FIND_NODE查询节点的请求，从而更新K桶的节点信息。</li><li>被动收集节点，当收到其他节点发送过来的请求（如：FIND_NODE、FIND_VALUE），会把对方的节点ID加入到某个K桶中。</li><li>检测失效节点，周期性的发起PING请求，判断K桶中某个节点是否在线，然后清理K桶中哪些下线的节点。</li></ul><p>当一个节点ID被用来更新K桶的时候进行如下步骤：</p><ul><li>计算自己和目标节点ID的距离d</li><li>通过距离d找到对应的K桶，如果ID已经在K桶中了则把对应项移到K桶的末尾</li><li><p>如果不在K桶中则有两种情况</p><p>  1.如果该K桶存储的节点小于K个，则直接把目标节点插入到K-桶尾部；<br>  2.如果该K桶存储节点大于等于K个，则选择K-桶中的头部节点进行PING操作，检测节点是否存活。如果头部节点没有响应，则移除该头部节点，并将目标节点插入到队列尾部；如果头部节点有响应，则把头部节点移到队列尾部，同时忽略目标节点。</p></li></ul><p>通过这种更新策略可以保证在线时间长的节点有较大的可能继续保存在K桶中，提高了稳定网络构建路由表的成本。</p><h3 id="加入Kad网络"><a href="#加入Kad网络" class="headerlink" title="加入Kad网络"></a>加入<code>Kad</code>网络</h3><p>一个新节点需要加入Kad网络有如下的步骤</p><ul><li>新节点A需要一个种子节点B作为引导，并把该种子节点加入到K桶中。</li><li>生成一个随机的节点ID，直到离开网络一直使用。</li><li>向节点B发送FIND_NODE请求。</li><li>节点B在收到节点A的FIND_NODE请求后，会根据FIND_NODE请求的约定，找到K个距离A最近的节点，并返回给A节点</li><li>A收到这些节点以后，就把它们加入到自己的K桶中</li><li>然后节点A会继续向这些刚拿到节点发起FIND_NODE请求，如此往复，直到A建立了足够详细的路由表。</li></ul><h3 id="定位节点"><a href="#定位节点" class="headerlink" title="定位节点"></a>定位节点</h3><p>节点查询可以同步进行也可以异步进行，同时查询并发一般为3。</p><ul><li>确定目标ID对应路由表中的K桶位置，然后从自己的K-桶中筛选出K个距离目标ID最近的节点，并同时向这些节点发起FIND_NODE的查询请求。</li><li>被查询节点收到FIND_NODE请求后，从对应的K桶中找出自己所知道的最近的K个节点，并返回给发起者。</li><li>发起者在收到这些节点后，更新自己的结果列表，并再次从其中K个距离目标节点ID最近的节点，挑选未发送请求的节点重复第一步</li><li>不断重复上面的步骤直到找到目标节点为止</li></ul>]]></content>
    
    <summary type="html">
    
      P2P网络的演化，Kademlia算法的原理
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="P2P网络" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/P2P%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="P2P网络" scheme="http://yoursite.com/tags/P2P%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Fabric共识模块源码分析</title>
    <link href="http://yoursite.com/2018/04/10/pbft/"/>
    <id>http://yoursite.com/2018/04/10/pbft/</id>
    <published>2018-04-10T12:15:41.000Z</published>
    <updated>2019-07-14T12:40:31.156Z</updated>
    
    <content type="html"><![CDATA[<p>正好这些天要有一个需求要帮客户魔改Fabric-v0.6，把一些hyperchain的高级特性移植过去，借此机会把之前看过的源码在梳理一下。<br>下面就是对Fabric共识模块的源码分析和梳理，代码都是以Fabric-v0.6-preview为例，在1.0及后续版本中都移除了PBFT部分，用了更好的SBFT，目前这一部分还在开发中。</p><a id="more"></a><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>可以看到共识模块目录如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">consensus</span><br><span class="line">├── controller</span><br><span class="line">├── executor</span><br><span class="line">├── helper</span><br><span class="line">│   └── persist</span><br><span class="line">├── noops</span><br><span class="line">├── pbft</span><br><span class="line">└── util</span><br><span class="line">    └── events</span><br></pre></td></tr></table></figure><p>目录含义如下</p><ul><li><code>controller</code> 用来控制Fabric选择什么样的共识算法，默认是<code>noops</code>。</li><li><code>executor</code> 封装了消息队列中对交易的处理。</li><li><code>helper</code> 对外提供接口调用和数据持久化接口。</li><li><code>noops</code> 提供了如何编写Fabric共识算法的Demo。</li><li><code>pbft</code> PBFT算法的具体实现。</li><li><code>util</code> 实现了一个peer节点到共识算法的一个消息通道，和一个消息队列。</li></ul><h3 id="流程概览"><a href="#流程概览" class="headerlink" title="流程概览"></a>流程概览</h3><p>Fabric网络通过一个<code>EventLoop</code>和共识算法进行交互，所有的操作都通过对事件循环中的事件监听进行推进。</p><p>整体流程如下图所示。<br><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/2017review/PBFT.jpeg?raw=true" alt="Alt text"></p><h3 id="Consensus模块接口"><a href="#Consensus模块接口" class="headerlink" title="Consensus模块接口"></a>Consensus模块接口</h3><p><code>fabric/consensus/consensus.go</code>对外提供共识模块的方法调用。</p><p>其中最核心也是每个算法必须实现的接口是<code>Consenter</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ExecutionConsumer <span class="keyword">interface</span> &#123;</span><br><span class="line">Executed(tag <span class="keyword">interface</span>&#123;&#125;)                                </span><br><span class="line">Committed(tag <span class="keyword">interface</span>&#123;&#125;, target *pb.BlockchainInfo)    </span><br><span class="line">RolledBack(tag <span class="keyword">interface</span>&#123;&#125;)                              </span><br><span class="line">StateUpdated(tag <span class="keyword">interface</span>&#123;&#125;, target *pb.BlockchainInfo)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Consenter <span class="keyword">interface</span> &#123;</span><br><span class="line">RecvMsg(msg *pb.Message, senderHandle *pb.PeerID) error</span><br><span class="line">ExecutionConsumer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接口的具体实现在<code>fabric/consensus/pbft/external.go</code>。</p><p>因为对交易的操作都是异步的，所以必须手动实现<code>Executed</code>，<code>Committed</code>，<code>RolledBack</code>，<code>StateUpdated</code>方法来监听对应动作的完成。</p><p><code>RecvMsg</code>方法用来从不用的<code>peer</code>节点接收消息。</p><h3 id="初始化共识模块"><a href="#初始化共识模块" class="headerlink" title="初始化共识模块"></a>初始化共识模块</h3><p>共识算法引擎在<code>peer</code>启动的时候初始化，初始化的具体函数如下所示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// consensus/helper/engine.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetEngine</span><span class="params">(coord peer.MessageHandlerCoordinator)</span> <span class="params">(peer.Engine, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">engineOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">engine = <span class="built_in">new</span>(EngineImpl)</span><br><span class="line">engine.helper = NewHelper(coord)</span><br><span class="line">engine.consenter = controller.NewConsenter(engine.helper)</span><br><span class="line">engine.helper.setConsenter(engine.consenter)</span><br><span class="line">engine.peerEndpoint, err = coord.GetPeerEndpoint()</span><br><span class="line">engine.consensusFan = util.NewMessageFan()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">logger.Debug(<span class="string">"Starting up message thread for consenter"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> msg := <span class="keyword">range</span> engine.consensusFan.GetOutChannel() &#123;</span><br><span class="line">engine.consenter.RecvMsg(msg.Msg, msg.Sender)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> engine, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GetEngine</code>的作用是进行共识模块的初始化，同时启动一个<code>goroutine</code>等待消息进入共识。</p><p>具体的<code>engine.consenter</code>是在<code>consensus/controller/controller.go</code>里进行选择。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// consensus/controller/controller.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConsenter</span><span class="params">(stack consensus.Stack)</span> <span class="title">consensus</span>.<span class="title">Consenter</span></span> &#123;</span><br><span class="line"></span><br><span class="line">plugin := strings.ToLower(viper.GetString(<span class="string">"peer.validator.consensus.plugin"</span>))</span><br><span class="line"><span class="keyword">if</span> plugin == <span class="string">"pbft"</span> &#123;</span><br><span class="line">logger.Infof(<span class="string">"Creating consensus plugin %s"</span>, plugin)</span><br><span class="line"><span class="keyword">return</span> pbft.GetPlugin(stack)</span><br><span class="line">&#125;</span><br><span class="line">logger.Info(<span class="string">"Creating default consensus plugin (noops)"</span>)</span><br><span class="line"><span class="keyword">return</span> noops.GetNoops(stack)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认选择的是<code>noops</code>，如果需要添加自己编写的共识模块需要在这里自行添加判断。</p><blockquote><p><code>noops</code> 只是演示如何编写Fabric共识模块，不要用在生产环境。</p></blockquote><p>如果选择了<code>PBFT</code>则会调用<code>consensus/pbft/pbft.go</code>进行初始化。</p><p>使用<code>PBFT</code>的<code>batch</code>模式启动时会调用<code>newObcBatch</code>进行<code>PBFT</code>算法初始化。</p><blockquote><p>PBFT只有<code>batch</code>一种模式。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// consensus/pbft/batch.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newObcBatch</span><span class="params">(id <span class="keyword">uint64</span>, config *viper.Viper, stack consensus.Stack)</span> *<span class="title">obcBatch</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    op.manager = events.NewManagerImpl()</span><br><span class="line">op.manager.SetReceiver(op)</span><br><span class="line">etf := events.NewTimerFactoryImpl(op.manager)</span><br><span class="line">op.pbft = newPbftCore(id, config, op, etf)</span><br><span class="line">op.manager.Start()</span><br><span class="line">blockchainInfoBlob := stack.GetBlockchainInfoBlob()</span><br><span class="line">op.externalEventReceiver.manager = op.manager</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> op</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>newObcBatch</code>主要做了这几项工作</p><ul><li>初始化了<code>eventLoop</code>的消息队列。</li><li>设置了消息的接收者，用来处理对应的消息。</li><li>创建监听消息超时的定时器。</li><li>初始化<code>pbft</code>算法。</li><li>启动消息队列，不断监听事件的到来并且分发给接收者处理。</li></ul><h3 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h3><p>Fabric的共识消息是通过<code>eventLoop</code>注射给对应处理函数的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// consensus/util/events/events.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendEvent</span><span class="params">(receiver Receiver, event Event)</span></span> &#123;</span><br><span class="line">next := event</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">next = receiver.ProcessEvent(next)</span><br><span class="line"><span class="keyword">if</span> next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(em *managerImpl)</span> <span class="title">Inject</span><span class="params">(event Event)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> em.receiver != <span class="literal">nil</span> &#123;</span><br><span class="line">SendEvent(em.receiver, event)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(em *managerImpl)</span> <span class="title">eventLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> next := &lt;-em.events:</span><br><span class="line">em.Inject(next)</span><br><span class="line"><span class="keyword">case</span> &lt;-em.exit:</span><br><span class="line">logger.Debug(<span class="string">"eventLoop told to exit"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>eventLoop</code>函数不断的从<code>em.events</code>里取出事件，通过<code>Inject</code>注射给对应的接收者，注意，通过<code>SendEvent</code>注射给接收者的<code>ProcessEvent</code>方法。</p><p><code>SendEvent</code>函数实现非常有意思，如果<code>receiver.ProcessEvent</code>的返回不为<code>nil</code>则不断的调用<code>receiver.ProcessEvent</code>直到找到对应的消息处理函数，在<code>ProcessEvent</code>函数中，其余<code>case</code>均为事件处理函数，唯独<code>pbftMessage</code>依赖<code>SendEvent</code>发送消息给其余函数处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// consensus/pbft/pbft-core.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(instance *pbftCore)</span> <span class="title">ProcessEvent</span><span class="params">(e events.Event)</span> <span class="title">events</span>.<span class="title">Event</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> *pbftMessage:</span><br><span class="line"><span class="keyword">return</span> pbftMessageEvent(*et)</span><br><span class="line"><span class="keyword">case</span> pbftMessageEvent:</span><br><span class="line">msg := et</span><br><span class="line">logger.Debugf(<span class="string">"Replica %d received incoming message from %v"</span>, instance.id, msg.sender)</span><br><span class="line">next, err := instance.recvMsg(msg.msg, msg.sender)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> next</span><br><span class="line"><span class="keyword">case</span> *RequestBatch:</span><br><span class="line">err = instance.recvRequestBatch(et)</span><br><span class="line"><span class="keyword">case</span> *PrePrepare:</span><br><span class="line">err = instance.recvPrePrepare(et)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>*pbftMessage</code>和<code>pbftMessageEvent</code>这两个<code>case</code>通过<code>recvMsg</code>的返回值又把消息分发给其余<code>case</code>，非常巧妙。</p><p><code>PBFT</code>算法的不同阶段都会按着上面的流程映射到不同的处理函数往前推进，本质上是一个状态机。</p><p>至此Fabric的<code>Consensus</code>模块主要流程已经梳理清楚，熟悉了这个流程以后再结合<code>PBFT</code>算法的过程就可以很容易在此基础上添加新的功能了。</p>]]></content>
    
    <summary type="html">
    
      联盟链Hyperledger fabric共识模块源码分析
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Fabric" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Fabric/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Fabric" scheme="http://yoursite.com/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>区块链技术的应用场景</title>
    <link href="http://yoursite.com/2018/01/31/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://yoursite.com/2018/01/31/区块链技术的应用场景/</id>
    <published>2018-01-31T15:54:56.000Z</published>
    <updated>2018-04-10T12:50:46.537Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;区块链的一个重要应用场景就是解决不同金融机构交易结算的成本，举个例子~在日常生活中使用微信提现会有24小时到账时间的限制，超过微信免费提现额度还会有一定的手续费，当然这都是建立在微信的支付系统和银行的交易系统正常运行的前提下。</p><a id="more"></a><p>&emsp;&emsp;通过这个例子我们发现了两个问题，提现需要24小时到账，交易过程产生了手续费。</p><p>&emsp;&emsp;将这个例子延伸到跨国，不同组织，对交易实时性要求高的场景下，上面的问题就会更为突出，例如将微信里提现到支付宝，因为微信和支付宝的支付网络不通，必须经过银行等第三方网络(微信和支付宝都信任的支付网络)的流转支持，也就是先由微信转账到银行在转到支付宝。</p><h3 id="交易过程"><a href="#交易过程" class="headerlink" title="交易过程"></a>交易过程</h3><p>&emsp;&emsp;先假定有一枚数字货币，货币的拥有者将货币加上自己的签名与时间戳，向全网广播交易给另一个地址，给向全世界都宣布了这个交易过程，等区块确认交易就成功了 :-D</p><p>&emsp;&emsp;这个交易过程是建立在使用同一个网络的前提下的，如果不同网络那就如同鸡同鸭讲，你的广播对方无法理解所以宣布的交易没有任何意义，如果要转换成对方所能理解的信息自然又得费一番功夫。</p><p>&emsp;&emsp;通过上面的交易过程可以发现因为使用了同一个网络从而避免了交易在不同网络之间交易的成本，避免了不同网络之间因为结算速度，结算方式带来的时间成本。</p><h3 id="信任问题"><a href="#信任问题" class="headerlink" title="信任问题"></a>信任问题</h3><p>&emsp;&emsp;在网购中，买方和卖方表现在不同的平台上可能是一个淘宝账号，可能是一个微信或者是其他的媒介，双方都没有任何的信任基础，你不会先把钱给对方，对方也不可能先给货物，这个时候你们可以找一个双方都信任的平台作为担保，比如淘宝，或者可以查看对方的交易记录，身份凭证来增加你的信任来进行直接交易，但是会有欺诈的风险，因为身份信息可能是伪造的。</p><p>&emsp;&emsp;可以看到第一种方式是中心化的，找到了双方都认可的作为担保。第二种方式则是去中心化的，但是有很高的欺诈风险，显然第一种方式是一种更好的选择。</p><p>&emsp;&emsp;这也就很好的解释了为什么支付宝的支付网络不和微信的支付网络直连，而是要通过第三方的银行来实现结算，银行是以国家信用作为背书的，是双方都可以信赖的。只是列举出支付宝和微信举例，整个网络中的大大小小的网络数不胜数，如果是第二种方式进行交易，整个信任问题简直爆炸。</p><h3 id="区块链原理"><a href="#区块链原理" class="headerlink" title="区块链原理"></a>区块链原理</h3><p>&emsp;&emsp;微信和支付宝的支付网络账本都是私有的，不可能给对方查看，如果微信转账给支付宝而支付宝抵赖说没有收到钱，这个时候微信掏出自己的账本说我确实转了钱，显然单方面的账本没有任何说服力，归根到底还是信任问题。</p><p>&emsp;&emsp;区块链采用分布式账本来解决这个问题，所有的人都在同一个账本记账，所有的交易记录都是可以追溯的，所有的账目都是透明的，每个人都可以保存一个账本的副本，如果出现了上面抵赖的问题大家都知道了这个转账存在过，即使微信抵赖但是绝大部分人都不承认，微信抵赖就是无效的。同时也解决了单一节点失效导致交易不可用的情况，例如微信的账本突然丢失但是其他节点存在非常多个副本，只需要同步一下账本就又可以恢复账户信息了。</p><p>&emsp;&emsp;这个时候就又会产生一个问题，大家的账本都共用一个，我有多少钱我和谁交易大家都知道了，这不是很尴尬，存个私房钱老婆都知道了还存个***啊 :-D</p><p>&emsp;&emsp;到目前为止，我们的区块链网络已经解决了信任问题（依靠大部分人的共识），现在需要解决的问题是如何保证隐私~</p><p>&emsp;&emsp;在区块链网络中的交易主体，如微信，支付宝这些名字带来的信用背书已经没有任何意义，在缺乏信任的环境中我不可能转账给一只猫，一只狗，因为我不知道我转账过去是否能获得我想要的东西，但是在区块链中所有主体的信用背书都是一样的，所以可以将主体抽象成任何东西，在区块链中是一串数字和字符的序列，并且这些东西和主体不是一一对应的，甚至可以一笔交易生成一个匿名序列，这样你知道发生了什么交易，交易是否可行（余额是否够）但是并不知道是交易属于谁。</p><p>&emsp;&emsp;最后我们回顾开始的问题，转账速度和手续费似乎并没有解决~只是把问题都转移到了区块链技术本身，以比特币为代表的第一代区块链为人所诟病的交易确认慢，高昂的手续费仍然存在，但是随着区块链技术的进步比如瑞波网络，Hyperledger（超级账本）等技术的发展已经很大程度上解决了以上问题，在Hyperledger v0.61中已经可以每秒处理1000多笔交易，随着技术的发展区块链交易处理速度还将大幅提高，制约区块链使用的难题逐渐解决以后区块链技术必将再次迎来一波发展。</p>]]></content>
    
    <summary type="html">
    
      区块链应用场景讨论
    
    </summary>
    
      <category term="Blockchain" scheme="http://yoursite.com/categories/Blockchain/"/>
    
      <category term="区块链" scheme="http://yoursite.com/categories/Blockchain/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Blockchain" scheme="http://yoursite.com/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>2017小结</title>
    <link href="http://yoursite.com/2017/12/30/2017%E5%B9%B4%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2017/12/30/2017年小结/</id>
    <published>2017-12-30T12:39:02.000Z</published>
    <updated>2017-12-31T14:14:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;之前没有如此强烈的想写年终的总结的冲动，但是今年经历了太多的事情，不如就此回顾一下2017在展望一下2018吧。</p><a id="more"></a><h2 id="毕业"><a href="#毕业" class="headerlink" title="毕业"></a>毕业</h2><p>&emsp;&emsp;今年六月终于从广东某不知名的一所学校毕业了，说终于倒不是因为不喜欢读书，大学四年的时间真是我这么多年来度过的最开心快乐充实的时光，现在看到朋友圈的师弟师妹发在学校的生活还不经回想起当年的时光，泡在实验室或者是图书馆搞自己喜欢的东西，顺带着晚上跑个外环，简直开心的不行。</p><p>&emsp;&emsp;至于学校的那些课程么~自然是划划水了，其实现在工作以后觉得还是有几门课需要认真学的，毕竟以后用的着而且还蛮有意思的，只不过当时觉得一帮念PPT的教不出个所以然来。</p><p>&emsp;&emsp;毕业也还顺利，拿到手一看读了四年是一个管理学学位，不过也蛮有意思的，高中文科生，大学管理学学士，毕业去搞计算机啦，按我老爸的话说就是能折腾，年轻。从读书到实习都能折腾，实习的折腾后面在说吧，先聊毕业的事。</p><p>&emsp;&emsp;拍毕业照的时候也没什么值得留恋的东西，就和班里人集体例行公事的拍了一下，中间的时间都拉着佳婷拍了，和佳婷坐湖边好好聊了一会，也错过了几次集体的合照，本来也无所谓，我这人在班上也没有什么存在感，照片里少了也没几个人会注意到的，和佳婷聊聊人生谈谈理想，虽然追了挺久也没追到但是这事就翻篇了，大学也就这么糊弄过去了。</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>&emsp;&emsp;先说实习吧，实习这事跨度太大，16年到17年，大三的时候去阿里音乐见识了见识外面的世界，学到了点人生经验，当然也得写写代码换点钱花花，学到了不少开阔了眼界，知道了外面的公司前端是怎么开发的流程是什么样的，当然也暴露了测试的时候没见过那么多的不同牌子的手机，自然测试完我都是要借来摸一遍的。</p><p>&emsp;&emsp;大四的时候闲来无事就又跑去UC实习了，第一次感受到了被切图支配的恐惧（笑:-D) ~  RED部门里设计为主，前端的主要工作就把设计用CSS高度还原以后分装成模块在给另一个前端组实习交互逻辑，当然说的专业点就是前端重构工程师了，大厂流程很规范加班也不少，只是觉得有点枯燥大多都是流程化的操作，一两遍还行你要说天天搞这个我也是不开心，踏实做也能做出点东西，可是还是不太喜欢就跑路喽。</p><p>&emsp;&emsp;后来就这么奇奇怪怪的在年初的时候来了北京，当时是投的Node.Js来的SenseTime，结果来了以后转型后端工程师写起了ruby，等适应以后觉得ruby还是蛮有意思，给社区翻译了一些文档，还试着把Libuv移植到Ruby写一个web服务器结合了一些Puma的代码，自娱自乐倒也很是开心。</p><p><img src="https://raw.githubusercontent.com/Ice-Storm/ice-storm.github.io/master/images/2017review/WechatIMG43.jpeg" alt=""></p><p>&emsp;&emsp;转正以后就慢慢参与公有云管理后台的开发，同事离职以后就全部负责起了这个项目，第一次维护开发一个逻辑很复杂的项目自然是非常开心，学到了不少东西也让我见识真正上线服务很多客户的云是怎么回事，整个管理后台不算前端大概两三万行rails的代码逻辑非常的复杂，集成了各种子系统真是Debug到飞起，现在玩的比较溜以后又可以研究研究其他好玩的东西啦。</p><p>&emsp;&emsp;其他的就是看看ML啊，学习学习计算机组成，折腾一下Golang，玩玩docker，rancher什么的乐在其中。</p><h3 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h3><p>&emsp;&emsp;说旅行有点牵强，但又实实在在的去了很多的地方，湛江，广州，酒泉，北京，天津，苏州，杭州还有一些记不得地方了，去这些地方多多少少都带着点目的，不是单单纯纯的去玩，除去回酒泉也就是家的那次吧。<br>&emsp;&emsp;飘的地方多了反而想安稳一点了，在苏州的女票又总是抱怨我居无定所，算不上流浪法师但至少是够得上流浪码农了，<code>如果有大佬看到这公司在江浙一带又恰好缺一个写代码的，或者需要一个只存在在线上的码农不妨联系我</code>。</p><p><img src="https://raw.githubusercontent.com/Ice-Storm/ice-storm.github.io/master/images/2017review/WechatIMG46.jpeg" alt=""><br><img src="https://raw.githubusercontent.com/Ice-Storm/ice-storm.github.io/master/images/2017review/WechatIMG44.jpeg" alt=""><br><img src="https://raw.githubusercontent.com/Ice-Storm/ice-storm.github.io/master/images/2017review/WechatIMG45.jpeg" alt=""></p><p><img src="https://raw.githubusercontent.com/Ice-Storm/ice-storm.github.io/master/images/2017review/WechatIMG47.jpeg" alt=""><br><img src="https://raw.githubusercontent.com/Ice-Storm/ice-storm.github.io/master/images/2017review/WechatIMG48.jpeg" alt=""></p><h3 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h3><p>砥砺前行~</p><ul><li>深入学习一下Go语言，并且在项目里实践</li><li>Docker，Rancher深入学习</li><li>把Github的坑填完</li><li>初探ML，毕竟公司有大神指导 :-D</li><li>明确一下以后发展的方向，技术和生活两方面</li><li>把叶叶拐回家让父母认识认识这个小呆子</li><li>尤克里里在溜一点，生活气在多一点，就这样吧~</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;之前没有如此强烈的想写年终的总结的冲动，但是今年经历了太多的事情，不如就此回顾一下2017在展望一下2018吧。&lt;/p&gt;
    
    </summary>
    
      <category term="review2017" scheme="http://yoursite.com/categories/review2017/"/>
    
    
      <category term="review2017" scheme="http://yoursite.com/tags/review2017/"/>
    
  </entry>
  
  <entry>
    <title>浅析Node的nextTick</title>
    <link href="http://yoursite.com/2017/07/22/%E6%B5%85%E6%9E%90Node%E7%9A%84nextTick/"/>
    <id>http://yoursite.com/2017/07/22/浅析Node的nextTick/</id>
    <published>2017-07-22T06:48:29.000Z</published>
    <updated>2017-07-22T12:52:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>看thinkjs源码的时候发现下面这段代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cluster.on(<span class="string">'exit'</span>, worker =&gt; &#123;</span><br><span class="line">  think.log(<span class="keyword">new</span> <span class="built_in">Error</span>(think.locale(<span class="string">'WORKER_DIED'</span>, worker.process.pid)), <span class="string">'THINK'</span>);</span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> cluster.fork());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>  这段代码的意思很简单，就是cluster挂了以后重新fork一个。<br>  但是注意到其中的<code>process.nextTick(() =&gt; cluster.fork());</code>这行，刚开始想了一下没有理解为什么不直接<code>fork</code>，后面仔细想了一下，发现如果直接<code>fork</code>，在<code>fork</code>的过程中又出现错误导致进程退出，而<code>cluster</code>又监听到<code>exit</code>的事件，就会不断的重复这个过程，阻塞Node进程。<br>  如果使用<code>process.nextTick(() =&gt; cluster.fork());</code>则不会阻塞Node的事件循环，只会在<code>Event Loop</code>的<code>close callbacks</code>阶段执行<code>fork</code>，即使程序一直<code>fork</code>失败也不会导致程序假死。(如果有疑问可以阅读文章末的扩展阅读)。<br>  下面的Demo说明了为什么使用了<code>nextTick</code>不会导致程序假死。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter; </span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">event.on(<span class="string">'some_event'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  count++;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'some_event 事件触发'</span> + count);</span><br><span class="line">  <span class="keyword">if</span> (count &lt; num) &#123;</span><br><span class="line">    event.emit(<span class="string">'some_event'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">event.emit(<span class="string">'some_event'</span>); </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'what ?'</span>)</span><br></pre></td></tr></table></figure></p><p>运行这段代码就会输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">some_event 事件触发1</span><br><span class="line">some_event 事件触发2</span><br><span class="line">some_event 事件触发3</span><br><span class="line">some_event 事件触发4</span><br><span class="line">some_event 事件触发5</span><br><span class="line">some_event 事件触发6</span><br><span class="line">some_event 事件触发7</span><br><span class="line">some_event 事件触发8</span><br><span class="line">some_event 事件触发9</span><br><span class="line">some_event 事件触发10</span><br><span class="line">what ?</span><br></pre></td></tr></table></figure></p><p>  可以发现 <code>what ?</code> 在最后才输出。如果把num设置的非常大就会报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">internal/process/next_tick.js:148</span><br><span class="line">    nextTickQueue.push(&#123;</span><br><span class="line">                 ^</span><br><span class="line">RangeError: Maximum call stack size exceeded</span><br></pre></td></tr></table></figure></p><p>  V8不断的向事件队列里添加任务，最终导致出现溢出，把<code>event.emit(&#39;some_event&#39;)</code>改写成<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  event.emit(<span class="string">'some_event'</span>) </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>  就会发现输出成了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ome_event 事件触发1</span><br><span class="line">what ?</span><br><span class="line">some_event 事件触发2</span><br><span class="line">some_event 事件触发3</span><br><span class="line">some_event 事件触发4</span><br><span class="line">some_event 事件触发5</span><br><span class="line">some_event 事件触发6</span><br><span class="line">some_event 事件触发7</span><br><span class="line">some_event 事件触发8</span><br><span class="line">some_event 事件触发9</span><br><span class="line">some_event 事件触发10</span><br></pre></td></tr></table></figure></p><p>  <code>what ?</code>并不会被阻塞，而且无论<code>num</code>改成多少，都不会出现栈溢出的错误。<br>  Node的<code>Event loop</code>执行流程如图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">|      nextTick（队列执行）</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">|       nextTick（队列执行）</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      </span><br><span class="line">|      nextTick（队列执行）         ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;─────┤  connections, │</span><br><span class="line">│  └──────────┬────────────┘      |               |</span><br><span class="line">|      nextTick（队列执行）         │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">|       nextTick（队列执行）</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure></p><p>  直接<code>event.emit(&#39;some_event&#39;)</code>的时候，Node不断的把收集到的事件塞到<code>I/O callbacks</code>这个队列，如果有大量的事件塞入就会最终导致溢出，就是上面的<code>Maximum call stack size exceeded</code>错误。<br>  如果加了<code>process.nextTick</code>则会不断的把<code>emit</code>的事件回调加到<code>nextTickQueue</code>队列，在各个主队列切换的时候执行，见上图的 <code>nextTick（队列执行）</code>。上面的那段Demo把<code>event.emit(&#39;some_event&#39;)</code>修改后的执行顺序就是<br>  1、发送事件<br>  2、把事件回调函数添加到<code>nextTickQueue</code>(注意，这个时候<code>nextTickQueue</code>队列里只有一个事件回调函数，如果当前队列尚未执行完毕并且没有发生切换，则<code>nextTickQueue</code>队列里的事件永远不会执行)<br>  3、执行<code>nextTickQueue</code>里的第一个事件回调(当前队列执行完毕或者执行到一定数量发生切换时，事件回调又会重新创建一个新的<code>nextTickQueue</code>队列并添加一个事件回调)<br>  4、然后同上<br>  这样就没有阻塞Node的事件循环，无论num多大都不会撑爆<code>I/O callbacks</code>队列。其实最核心的思想就是将任务拆解到若干次事件循环中，逐步执行。</p><p>扩展阅读<br>  <a href="https://github.com/creeperyang/blog/issues/26" target="_blank" rel="noopener">Node.js的event loop及timer/setImmediate/nextTick</a><br>  <a href="http://www.cnblogs.com/bingooo/p/6720540.html" target="_blank" rel="noopener">Node.js 原理简介</a><br>  <a href="https://yjhjstz.gitbooks.io/deep-into-node/content/" target="_blank" rel="noopener">深入理解Node.js：核心思想与源码分析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看thinkjs源码的时候发现下面这段代码。&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cluster.on(&lt;span class=&quot;string&quot;&gt;&#39;exit&#39;&lt;/span&gt;, worker =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  think.log(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Error&lt;/span&gt;(think.locale(&lt;span class=&quot;string&quot;&gt;&#39;WORKER_DIED&#39;&lt;/span&gt;, worker.process.pid)), &lt;span class=&quot;string&quot;&gt;&#39;THINK&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  process.nextTick(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; cluster.fork());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Node" scheme="http://yoursite.com/categories/Node/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/Node/JavaScript/"/>
    
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
