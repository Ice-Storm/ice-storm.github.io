<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Qin Yuan&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-28T09:30:21.088Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Qin Yuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kademlia算法原理详解</title>
    <link href="http://yoursite.com/2018/08/28/kad/"/>
    <id>http://yoursite.com/2018/08/28/kad/</id>
    <published>2018-08-28T14:22:44.000Z</published>
    <updated>2018-08-28T09:30:21.088Z</updated>
    
    <content type="html"><![CDATA[<p>P2P网络有四个发展阶段：<code>集中式网络</code>，<code>纯分布式网络</code>，<code>混合式网络</code>，<code>结构化网络</code>。</p><a id="more"></a><h3 id="集中式网络"><a href="#集中式网络" class="headerlink" title="集中式网络"></a><code>集中式网络</code></h3><p><code>集中式</code>的P2P网络最简单，即一个节点保存了其他所有节点的索引信息，而索引信息又包括了节点IP，端口，节点资源等。节点之间互连的路由查询由中心节点完成，一旦和对等节点建立连接则与中心节点没有什么联系。集中式的P2P网络结构简单，实现容易，但是由于所有路由信息在中心节点存储，当节点数量变多扩展的时候容易出现性能瓶颈，也容易出现单点故障。</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/kad/1.jpg?raw=true" width="70%" height="70%"></p><h3 id="纯分布式网络"><a href="#纯分布式网络" class="headerlink" title="纯分布式网络"></a><code>纯分布式网络</code></h3><p><code>纯分布式</code>的P2P网络移除了中心节点，在P2P网络之间建立了随机网络，一个新加入的节点和P2P网络中的某个随机节点建立连接，从而形成一个随机的拓扑结构。新节点和邻居节点建立连接以后还需要全网广播，让整个网络知道自己的存在。</p><p>全网广播的方式是，该节点向自己的邻居节点广播，邻居节点收到消息以后在向自己的邻居节点广播，以此类推，从而广播到整个网络。这种广播也称为泛洪机制。</p><p>纯分布式的P2P网络不存在集中式网络的单点故障和中心性能瓶颈的问题，具有较好的扩展性，但是泛洪机制又引入了新的问题，一是容易形成泛洪循环，A节点发出的消息经过节点B到节点C，节点C在<br>广播到节点A，形成了一个消息循环；另一个是响应消息风暴的问题，如果节点A想请求的资源被很多节点所拥有，那么在短时间内就会出现大量的节点向A节点发送响应消息，可能会让节点A崩溃。</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/kad/2.jpg?raw=true" width="70%" height="70%"></p><h3 id="混合式网络"><a href="#混合式网络" class="headerlink" title="混合式网络"></a><code>混合式网络</code></h3><p><code>混合式</code>的P2P网络就是混合了<code>集中式</code>和<code>纯分布式</code>的结构，网络中存在多个超级节点组成分布式网络，而每个超级节点则与多个普通节点组成局部的集中式网络。一个新的普通节点加入网络需要先选择一个超级节点通信，该超级节点在推送其他超级节点列表给新加入的节点，加入节点在根据超级节点列表中的状态选择加入哪个超级节点作为父节点。这种结构限制了泛洪广播的范围，避免了大规模的泛洪问题。<br>在实际应用中，<code>混合式</code>结构是相对灵活且比较有效的网络架构，实现也相对容易。</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/kad/3.jpg?raw=true" width="70%" height="70%"></p><h3 id="结构化网络"><a href="#结构化网络" class="headerlink" title="结构化网络"></a><code>结构化网络</code></h3><p><code>结构化P2P网络</code>也是一种分布式网络结构，但又与<code>纯分布式</code>有所区别。<code>纯分布式</code>网络就是一个随机网络，而结构化网络则将所有节点按照某种结构有序的组织起来，比如形成一个环状网络或者树状的网络。<br>结构化网络的具体实现上普遍都是基于DHT(Distributed Hash Table，分布式哈希表) 算法。具体的实现方案有 Chord、Pastry、CAN、Kademlia 等算法，其中 Kademlia 也是以太坊网络的实现算法，后面中重点讲解它的实现原理。</p><h2 id="Kad算法原理"><a href="#Kad算法原理" class="headerlink" title="Kad算法原理"></a><code>Kad</code>算法原理</h2><p><code>Kad</code>算法用来在分布式环境中准确的路由，定位数据。</p><p>在Kad网络中每个节点都有一个随机产生的160bit的标识符作为节点ID，Kad算法通过计算节点ID间的距离来快速路由和定位资源。</p><p>Kad算法通过异或节点ID来计算节点之间的距离，这个距离是逻辑上的距离并不是节点间物理上的距离。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">节点A的ID（010）</span><br><span class="line">节点B的ID（110）</span><br><span class="line">A ⊕ B = 100（二进制） = 4（十进制）</span><br></pre></td></tr></table></figure><p>在上面异或度量节点距离的基础之上，Kad算法还可以将整个网络划分成一个二叉前缀树，每个节点映射到二叉树上的某个叶子。</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/kad/kbucket.png?raw=true" width="80%" height="80%"></p><p>映射规则：</p><ul><li>将节点ID（160bit）从高到低依次分层，第N位就对应了第N层</li><li>如果是0进入左子树，如果是1则进入右子树</li><li>每个节点就对应树中的一个叶子</li></ul><p>在这种二叉树结构下，对于每个节点来说离他它越近的值节点的异或距离也越近，每一个节点都可以从自己的视角来对二叉树进行拆分，拆分规则是从根节点开始，把不包含自己的子树拆分出来，然后在剩下的子树再拆分不包含自己的下一层子树，以此类推，直到最后只剩下自己。上图的例子就是以节点ID为110的视角多二叉树进行了拆分。</p><p>因为Kad算法默认的节点ID是160bit，所有拆分以后最多可以有160课子树，而对于每个子树，如果我们分别知道里面的一个节点，就可以利用这个节点递归路由到子树的任意一个节点。</p><p>但是在实际应用中，由于节点是动态增加减少的，如果知道的节点恰好宕机或者下线了就会出现问题，为了保证系统的鲁棒性Kad算法又引入了K桶（K-bucket）的机制。</p><h3 id="K桶（k-bucket）"><a href="#K桶（k-bucket）" class="headerlink" title="K桶（k-bucket）"></a>K桶（<code>k-bucket</code>）</h3><p>节点在完成拆分子树以后需要记录每个子树里面K个节点，K可以由用户自己定义，在BT下载使用的Kad算法中K是8。</p><p><code>K-bucket</code>实际上就是路由表，每个节点按照自己的视角拆分完子树以后可以得到N个子树，那就需要维护N个路由表，对应N个K-bucket.</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/kad/k_bucket.png?raw=true" width="80%" height="80%"></p><p>每个节点维护N个K-bucket以后还会出现一个问题，K-bucket中的节点也会动态的增减，那又如何K-bucket的稳定呢？</p><h3 id="K桶的更新机制"><a href="#K桶的更新机制" class="headerlink" title="K桶的更新机制"></a>K桶的更新机制</h3><p><code>K-bucket</code>主要有三种方式来更新路由表。</p><ul><li>主动收集节点，主动发起FIND_NODE查询节点的请求，从而更新K桶的节点信息。</li><li>被动收集节点，当收到其他节点发送过来的请求（如：FIND_NODE、FIND_VALUE），会把对方的节点ID加入到某个K桶中。</li><li>检测失效节点，周期性的发起PING请求，判断K桶中某个节点是否在线，然后清理K桶中哪些下线的节点。</li></ul><p>当一个节点ID被用来更新K桶的时候进行如下步骤：</p><ul><li>计算自己和目标节点ID的距离d</li><li>通过距离d找到对应的K桶，如果ID已经在K桶中了则把对应项移到K桶的末尾</li><li><p>如果不在K桶中则有两种情况</p><p>  1.如果该K桶存储的节点小于K个，则直接把目标节点插入到K-桶尾部；<br>  2.如果该K桶存储节点大于等于K个，则选择K-桶中的头部节点进行PING操作，检测节点是否存活。如果头部节点没有响应，则移除该头部节点，并将目标节点插入到队列尾部；如果头部节点有响应，则把头部节点移到队列尾部，同时忽略目标节点。</p></li></ul><p>通过这种更新策略可以保证在线时间长的节点有较大的可能继续保存在K桶中，提高了稳定网络构建路由表的成本。</p><h3 id="加入Kad网络"><a href="#加入Kad网络" class="headerlink" title="加入Kad网络"></a>加入<code>Kad</code>网络</h3><p>一个新节点需要加入Kad网络有如下的步骤</p><ul><li>新节点A需要一个种子节点B作为引导，并把该种子节点加入到K桶中。</li><li>生成一个随机的节点ID，直到离开网络一直使用。</li><li>向节点B发送FIND_NODE请求。</li><li>节点B在收到节点A的FIND_NODE请求后，会根据FIND_NODE请求的约定，找到K个距离A最近的节点，并返回给A节点</li><li>A收到这些节点以后，就把它们加入到自己的K桶中</li><li>然后节点A会继续向这些刚拿到节点发起FIND_NODE请求，如此往复，直到A建立了足够详细的路由表。</li></ul><h3 id="定位节点"><a href="#定位节点" class="headerlink" title="定位节点"></a>定位节点</h3><p>节点查询可以同步进行也可以异步进行，同时查询并发一般为3。</p><ul><li>确定目标ID对应路由表中的K桶位置，然后从自己的K-桶中筛选出K个距离目标ID最近的节点，并同时向这些节点发起FIND_NODE的查询请求。</li><li>被查询节点收到FIND_NODE请求后，从对应的K桶中找出自己所知道的最近的K个节点，并返回给发起者。</li><li>发起者在收到这些节点后，更新自己的结果列表，并再次从其中K个距离目标节点ID最近的节点，挑选未发送请求的节点重复第一步</li><li>不断重复上面的步骤直到找到目标节点为止</li></ul>]]></content>
    
    <summary type="html">
    
      P2P网络的演化，Kademlia算法的原理
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="P2P网络" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/P2P%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="P2P网络" scheme="http://yoursite.com/tags/P2P%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Fabric共识模块源码分析</title>
    <link href="http://yoursite.com/2018/04/10/pbft/"/>
    <id>http://yoursite.com/2018/04/10/pbft/</id>
    <published>2018-04-10T12:15:41.000Z</published>
    <updated>2018-04-10T12:50:12.473Z</updated>
    
    <content type="html"><![CDATA[<p>正好这些天要有一个需求要帮客户魔改Fabric-v0.6，把一些hyperchain的高级特性移植过去，借此机会把之前看过的源码在梳理一下。<br>下面就是对Fabric共识模块的源码分析和梳理，代码都是以Fabric-v0.6-preview为例，在1.0及后续版本中都移除了PBFT部分，用了更好的SBFT，目前这一部分还在开发中。</p><a id="more"></a><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>可以看到共识模块目录如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">consensus</span><br><span class="line">├── controller</span><br><span class="line">├── executor</span><br><span class="line">├── helper</span><br><span class="line">│   └── persist</span><br><span class="line">├── noops</span><br><span class="line">├── pbft</span><br><span class="line">└── util</span><br><span class="line">    └── events</span><br></pre></td></tr></table></figure><p>目录含义如下</p><ul><li><code>controller</code> 用来控制Fabric选择什么样的共识算法，默认是<code>noops</code>。</li><li><code>executor</code> 封装了消息队列中对交易的处理。</li><li><code>helper</code> 对外提供接口调用和数据持久化接口。</li><li><code>noops</code> 提供了如何编写Fabric共识算法的Demo。</li><li><code>pbft</code> PBFT算法的具体实现。</li><li><code>util</code> 实现了一个peer节点到共识算法的一个消息通道，和一个消息队列。</li></ul><h3 id="流程概览"><a href="#流程概览" class="headerlink" title="流程概览"></a>流程概览</h3><p>Fabric网络通过一个<code>EventLoop</code>和共识算法进行交互，所有的操作都通过对事件循环中的事件监听进行推进。</p><p>整体流程如下图所示。<br><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/2017review/PBFT.jpeg?raw=true" alt="Alt text"></p><h3 id="Consensus模块接口"><a href="#Consensus模块接口" class="headerlink" title="Consensus模块接口"></a>Consensus模块接口</h3><p><code>fabric/consensus/consensus.go</code>对外提供共识模块的方法调用。</p><p>其中最核心也是每个算法必须实现的接口是<code>Consenter</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ExecutionConsumer <span class="keyword">interface</span> &#123;</span><br><span class="line">Executed(tag <span class="keyword">interface</span>&#123;&#125;)                                </span><br><span class="line">Committed(tag <span class="keyword">interface</span>&#123;&#125;, target *pb.BlockchainInfo)    </span><br><span class="line">RolledBack(tag <span class="keyword">interface</span>&#123;&#125;)                              </span><br><span class="line">StateUpdated(tag <span class="keyword">interface</span>&#123;&#125;, target *pb.BlockchainInfo)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Consenter <span class="keyword">interface</span> &#123;</span><br><span class="line">RecvMsg(msg *pb.Message, senderHandle *pb.PeerID) error</span><br><span class="line">ExecutionConsumer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接口的具体实现在<code>fabric/consensus/pbft/external.go</code>。</p><p>因为对交易的操作都是异步的，所以必须手动实现<code>Executed</code>，<code>Committed</code>，<code>RolledBack</code>，<code>StateUpdated</code>方法来监听对应动作的完成。</p><p><code>RecvMsg</code>方法用来从不用的<code>peer</code>节点接收消息。</p><h3 id="初始化共识模块"><a href="#初始化共识模块" class="headerlink" title="初始化共识模块"></a>初始化共识模块</h3><p>共识算法引擎在<code>peer</code>启动的时候初始化，初始化的具体函数如下所示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// consensus/helper/engine.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetEngine</span><span class="params">(coord peer.MessageHandlerCoordinator)</span> <span class="params">(peer.Engine, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">engineOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">engine = <span class="built_in">new</span>(EngineImpl)</span><br><span class="line">engine.helper = NewHelper(coord)</span><br><span class="line">engine.consenter = controller.NewConsenter(engine.helper)</span><br><span class="line">engine.helper.setConsenter(engine.consenter)</span><br><span class="line">engine.peerEndpoint, err = coord.GetPeerEndpoint()</span><br><span class="line">engine.consensusFan = util.NewMessageFan()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">logger.Debug(<span class="string">"Starting up message thread for consenter"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> msg := <span class="keyword">range</span> engine.consensusFan.GetOutChannel() &#123;</span><br><span class="line">engine.consenter.RecvMsg(msg.Msg, msg.Sender)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> engine, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GetEngine</code>的作用是进行共识模块的初始化，同时启动一个<code>goroutine</code>等待消息进入共识。</p><p>具体的<code>engine.consenter</code>是在<code>consensus/controller/controller.go</code>里进行选择。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// consensus/controller/controller.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConsenter</span><span class="params">(stack consensus.Stack)</span> <span class="title">consensus</span>.<span class="title">Consenter</span></span> &#123;</span><br><span class="line"></span><br><span class="line">plugin := strings.ToLower(viper.GetString(<span class="string">"peer.validator.consensus.plugin"</span>))</span><br><span class="line"><span class="keyword">if</span> plugin == <span class="string">"pbft"</span> &#123;</span><br><span class="line">logger.Infof(<span class="string">"Creating consensus plugin %s"</span>, plugin)</span><br><span class="line"><span class="keyword">return</span> pbft.GetPlugin(stack)</span><br><span class="line">&#125;</span><br><span class="line">logger.Info(<span class="string">"Creating default consensus plugin (noops)"</span>)</span><br><span class="line"><span class="keyword">return</span> noops.GetNoops(stack)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认选择的是<code>noops</code>，如果需要添加自己编写的共识模块需要在这里自行添加判断。</p><blockquote><p><code>noops</code> 只是演示如何编写Fabric共识模块，不要用在生产环境。</p></blockquote><p>如果选择了<code>PBFT</code>则会调用<code>consensus/pbft/pbft.go</code>进行初始化。</p><p>使用<code>PBFT</code>的<code>batch</code>模式启动时会调用<code>newObcBatch</code>进行<code>PBFT</code>算法初始化。</p><blockquote><p>PBFT只有<code>batch</code>一种模式。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// consensus/pbft/batch.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newObcBatch</span><span class="params">(id <span class="keyword">uint64</span>, config *viper.Viper, stack consensus.Stack)</span> *<span class="title">obcBatch</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    op.manager = events.NewManagerImpl()</span><br><span class="line">op.manager.SetReceiver(op)</span><br><span class="line">etf := events.NewTimerFactoryImpl(op.manager)</span><br><span class="line">op.pbft = newPbftCore(id, config, op, etf)</span><br><span class="line">op.manager.Start()</span><br><span class="line">blockchainInfoBlob := stack.GetBlockchainInfoBlob()</span><br><span class="line">op.externalEventReceiver.manager = op.manager</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> op</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>newObcBatch</code>主要做了这几项工作</p><ul><li>初始化了<code>eventLoop</code>的消息队列。</li><li>设置了消息的接收者，用来处理对应的消息。</li><li>创建监听消息超时的定时器。</li><li>初始化<code>pbft</code>算法。</li><li>启动消息队列，不断监听事件的到来并且分发给接收者处理。</li></ul><h3 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h3><p>Fabric的共识消息是通过<code>eventLoop</code>注射给对应处理函数的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// consensus/util/events/events.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendEvent</span><span class="params">(receiver Receiver, event Event)</span></span> &#123;</span><br><span class="line">next := event</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">next = receiver.ProcessEvent(next)</span><br><span class="line"><span class="keyword">if</span> next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(em *managerImpl)</span> <span class="title">Inject</span><span class="params">(event Event)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> em.receiver != <span class="literal">nil</span> &#123;</span><br><span class="line">SendEvent(em.receiver, event)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(em *managerImpl)</span> <span class="title">eventLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> next := &lt;-em.events:</span><br><span class="line">em.Inject(next)</span><br><span class="line"><span class="keyword">case</span> &lt;-em.exit:</span><br><span class="line">logger.Debug(<span class="string">"eventLoop told to exit"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>eventLoop</code>函数不断的从<code>em.events</code>里取出事件，通过<code>Inject</code>注射给对应的接收者，注意，通过<code>SendEvent</code>注射给接收者的<code>ProcessEvent</code>方法。</p><p><code>SendEvent</code>函数实现非常有意思，如果<code>receiver.ProcessEvent</code>的返回不为<code>nil</code>则不断的调用<code>receiver.ProcessEvent</code>直到找到对应的消息处理函数，在<code>ProcessEvent</code>函数中，其余<code>case</code>均为事件处理函数，唯独<code>pbftMessage</code>依赖<code>SendEvent</code>发送消息给其余函数处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// consensus/pbft/pbft-core.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(instance *pbftCore)</span> <span class="title">ProcessEvent</span><span class="params">(e events.Event)</span> <span class="title">events</span>.<span class="title">Event</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> *pbftMessage:</span><br><span class="line"><span class="keyword">return</span> pbftMessageEvent(*et)</span><br><span class="line"><span class="keyword">case</span> pbftMessageEvent:</span><br><span class="line">msg := et</span><br><span class="line">logger.Debugf(<span class="string">"Replica %d received incoming message from %v"</span>, instance.id, msg.sender)</span><br><span class="line">next, err := instance.recvMsg(msg.msg, msg.sender)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> next</span><br><span class="line"><span class="keyword">case</span> *RequestBatch:</span><br><span class="line">err = instance.recvRequestBatch(et)</span><br><span class="line"><span class="keyword">case</span> *PrePrepare:</span><br><span class="line">err = instance.recvPrePrepare(et)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>*pbftMessage</code>和<code>pbftMessageEvent</code>这两个<code>case</code>通过<code>recvMsg</code>的返回值又把消息分发给其余<code>case</code>，非常巧妙。</p><p><code>PBFT</code>算法的不同阶段都会按着上面的流程映射到不同的处理函数往前推进，本质上是一个状态机。</p><p>至此Fabric的<code>Consensus</code>模块主要流程已经梳理清楚，熟悉了这个流程以后再结合<code>PBFT</code>算法的过程就可以很容易在此基础上添加新的功能了。</p>]]></content>
    
    <summary type="html">
    
      联盟链Hyperledger fabric共识模块源码分析
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Fabric" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Fabric/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Fabric" scheme="http://yoursite.com/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>区块链技术的应用场景</title>
    <link href="http://yoursite.com/2018/01/31/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://yoursite.com/2018/01/31/区块链技术的应用场景/</id>
    <published>2018-01-31T15:54:56.000Z</published>
    <updated>2018-04-10T12:50:46.537Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;区块链的一个重要应用场景就是解决不同金融机构交易结算的成本，举个例子~在日常生活中使用微信提现会有24小时到账时间的限制，超过微信免费提现额度还会有一定的手续费，当然这都是建立在微信的支付系统和银行的交易系统正常运行的前提下。</p><a id="more"></a><p>&emsp;&emsp;通过这个例子我们发现了两个问题，提现需要24小时到账，交易过程产生了手续费。</p><p>&emsp;&emsp;将这个例子延伸到跨国，不同组织，对交易实时性要求高的场景下，上面的问题就会更为突出，例如将微信里提现到支付宝，因为微信和支付宝的支付网络不通，必须经过银行等第三方网络(微信和支付宝都信任的支付网络)的流转支持，也就是先由微信转账到银行在转到支付宝。</p><h3 id="交易过程"><a href="#交易过程" class="headerlink" title="交易过程"></a>交易过程</h3><p>&emsp;&emsp;先假定有一枚数字货币，货币的拥有者将货币加上自己的签名与时间戳，向全网广播交易给另一个地址，给向全世界都宣布了这个交易过程，等区块确认交易就成功了 :-D</p><p>&emsp;&emsp;这个交易过程是建立在使用同一个网络的前提下的，如果不同网络那就如同鸡同鸭讲，你的广播对方无法理解所以宣布的交易没有任何意义，如果要转换成对方所能理解的信息自然又得费一番功夫。</p><p>&emsp;&emsp;通过上面的交易过程可以发现因为使用了同一个网络从而避免了交易在不同网络之间交易的成本，避免了不同网络之间因为结算速度，结算方式带来的时间成本。</p><h3 id="信任问题"><a href="#信任问题" class="headerlink" title="信任问题"></a>信任问题</h3><p>&emsp;&emsp;在网购中，买方和卖方表现在不同的平台上可能是一个淘宝账号，可能是一个微信或者是其他的媒介，双方都没有任何的信任基础，你不会先把钱给对方，对方也不可能先给货物，这个时候你们可以找一个双方都信任的平台作为担保，比如淘宝，或者可以查看对方的交易记录，身份凭证来增加你的信任来进行直接交易，但是会有欺诈的风险，因为身份信息可能是伪造的。</p><p>&emsp;&emsp;可以看到第一种方式是中心化的，找到了双方都认可的作为担保。第二种方式则是去中心化的，但是有很高的欺诈风险，显然第一种方式是一种更好的选择。</p><p>&emsp;&emsp;这也就很好的解释了为什么支付宝的支付网络不和微信的支付网络直连，而是要通过第三方的银行来实现结算，银行是以国家信用作为背书的，是双方都可以信赖的。只是列举出支付宝和微信举例，整个网络中的大大小小的网络数不胜数，如果是第二种方式进行交易，整个信任问题简直爆炸。</p><h3 id="区块链原理"><a href="#区块链原理" class="headerlink" title="区块链原理"></a>区块链原理</h3><p>&emsp;&emsp;微信和支付宝的支付网络账本都是私有的，不可能给对方查看，如果微信转账给支付宝而支付宝抵赖说没有收到钱，这个时候微信掏出自己的账本说我确实转了钱，显然单方面的账本没有任何说服力，归根到底还是信任问题。</p><p>&emsp;&emsp;区块链采用分布式账本来解决这个问题，所有的人都在同一个账本记账，所有的交易记录都是可以追溯的，所有的账目都是透明的，每个人都可以保存一个账本的副本，如果出现了上面抵赖的问题大家都知道了这个转账存在过，即使微信抵赖但是绝大部分人都不承认，微信抵赖就是无效的。同时也解决了单一节点失效导致交易不可用的情况，例如微信的账本突然丢失但是其他节点存在非常多个副本，只需要同步一下账本就又可以恢复账户信息了。</p><p>&emsp;&emsp;这个时候就又会产生一个问题，大家的账本都共用一个，我有多少钱我和谁交易大家都知道了，这不是很尴尬，存个私房钱老婆都知道了还存个***啊 :-D</p><p>&emsp;&emsp;到目前为止，我们的区块链网络已经解决了信任问题（依靠大部分人的共识），现在需要解决的问题是如何保证隐私~</p><p>&emsp;&emsp;在区块链网络中的交易主体，如微信，支付宝这些名字带来的信用背书已经没有任何意义，在缺乏信任的环境中我不可能转账给一只猫，一只狗，因为我不知道我转账过去是否能获得我想要的东西，但是在区块链中所有主体的信用背书都是一样的，所以可以将主体抽象成任何东西，在区块链中是一串数字和字符的序列，并且这些东西和主体不是一一对应的，甚至可以一笔交易生成一个匿名序列，这样你知道发生了什么交易，交易是否可行（余额是否够）但是并不知道是交易属于谁。</p><p>&emsp;&emsp;最后我们回顾开始的问题，转账速度和手续费似乎并没有解决~只是把问题都转移到了区块链技术本身，以比特币为代表的第一代区块链为人所诟病的交易确认慢，高昂的手续费仍然存在，但是随着区块链技术的进步比如瑞波网络，Hyperledger（超级账本）等技术的发展已经很大程度上解决了以上问题，在Hyperledger v0.61中已经可以每秒处理1000多笔交易，随着技术的发展区块链交易处理速度还将大幅提高，制约区块链使用的难题逐渐解决以后区块链技术必将再次迎来一波发展。</p>]]></content>
    
    <summary type="html">
    
      区块链应用场景讨论
    
    </summary>
    
      <category term="Blockchain" scheme="http://yoursite.com/categories/Blockchain/"/>
    
      <category term="区块链" scheme="http://yoursite.com/categories/Blockchain/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Blockchain" scheme="http://yoursite.com/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>2017小结</title>
    <link href="http://yoursite.com/2017/12/30/2017%E5%B9%B4%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2017/12/30/2017年小结/</id>
    <published>2017-12-30T12:39:02.000Z</published>
    <updated>2017-12-31T14:14:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;之前没有如此强烈的想写年终的总结的冲动，但是今年经历了太多的事情，不如就此回顾一下2017在展望一下2018吧。</p><a id="more"></a><h2 id="毕业"><a href="#毕业" class="headerlink" title="毕业"></a>毕业</h2><p>&emsp;&emsp;今年六月终于从广东某不知名的一所学校毕业了，说终于倒不是因为不喜欢读书，大学四年的时间真是我这么多年来度过的最开心快乐充实的时光，现在看到朋友圈的师弟师妹发在学校的生活还不经回想起当年的时光，泡在实验室或者是图书馆搞自己喜欢的东西，顺带着晚上跑个外环，简直开心的不行。</p><p>&emsp;&emsp;至于学校的那些课程么~自然是划划水了，其实现在工作以后觉得还是有几门课需要认真学的，毕竟以后用的着而且还蛮有意思的，只不过当时觉得一帮念PPT的教不出个所以然来。</p><p>&emsp;&emsp;毕业也还顺利，拿到手一看读了四年是一个管理学学位，不过也蛮有意思的，高中文科生，大学管理学学士，毕业去搞计算机啦，按我老爸的话说就是能折腾，年轻。从读书到实习都能折腾，实习的折腾后面在说吧，先聊毕业的事。</p><p>&emsp;&emsp;拍毕业照的时候也没什么值得留恋的东西，就和班里人集体例行公事的拍了一下，中间的时间都拉着佳婷拍了，和佳婷坐湖边好好聊了一会，也错过了几次集体的合照，本来也无所谓，我这人在班上也没有什么存在感，照片里少了也没几个人会注意到的，和佳婷聊聊人生谈谈理想，虽然追了挺久也没追到但是这事就翻篇了，大学也就这么糊弄过去了。</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>&emsp;&emsp;先说实习吧，实习这事跨度太大，16年到17年，大三的时候去阿里音乐见识了见识外面的世界，学到了点人生经验，当然也得写写代码换点钱花花，学到了不少开阔了眼界，知道了外面的公司前端是怎么开发的流程是什么样的，当然也暴露了测试的时候没见过那么多的不同牌子的手机，自然测试完我都是要借来摸一遍的。</p><p>&emsp;&emsp;大四的时候闲来无事就又跑去UC实习了，第一次感受到了被切图支配的恐惧（笑:-D) ~  RED部门里设计为主，前端的主要工作就把设计用CSS高度还原以后分装成模块在给另一个前端组实习交互逻辑，当然说的专业点就是前端重构工程师了，大厂流程很规范加班也不少，只是觉得有点枯燥大多都是流程化的操作，一两遍还行你要说天天搞这个我也是不开心，踏实做也能做出点东西，可是还是不太喜欢就跑路喽。</p><p>&emsp;&emsp;后来就这么奇奇怪怪的在年初的时候来了北京，当时是投的Node.Js来的SenseTime，结果来了以后转型后端工程师写起了ruby，等适应以后觉得ruby还是蛮有意思，给社区翻译了一些文档，还试着把Libuv移植到Ruby写一个web服务器结合了一些Puma的代码，自娱自乐倒也很是开心。</p><p><img src="https://raw.githubusercontent.com/Ice-Storm/ice-storm.github.io/master/images/2017review/WechatIMG43.jpeg" alt=""></p><p>&emsp;&emsp;转正以后就慢慢参与公有云管理后台的开发，同事离职以后就全部负责起了这个项目，第一次维护开发一个逻辑很复杂的项目自然是非常开心，学到了不少东西也让我见识真正上线服务很多客户的云是怎么回事，整个管理后台不算前端大概两三万行rails的代码逻辑非常的复杂，集成了各种子系统真是Debug到飞起，现在玩的比较溜以后又可以研究研究其他好玩的东西啦。</p><p>&emsp;&emsp;其他的就是看看ML啊，学习学习计算机组成，折腾一下Golang，玩玩docker，rancher什么的乐在其中。</p><h3 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h3><p>&emsp;&emsp;说旅行有点牵强，但又实实在在的去了很多的地方，湛江，广州，酒泉，北京，天津，苏州，杭州还有一些记不得地方了，去这些地方多多少少都带着点目的，不是单单纯纯的去玩，除去回酒泉也就是家的那次吧。<br>&emsp;&emsp;飘的地方多了反而想安稳一点了，在苏州的女票又总是抱怨我居无定所，算不上流浪法师但至少是够得上流浪码农了，<code>如果有大佬看到这公司在江浙一带又恰好缺一个写代码的，或者需要一个只存在在线上的码农不妨联系我</code>。</p><p><img src="https://raw.githubusercontent.com/Ice-Storm/ice-storm.github.io/master/images/2017review/WechatIMG46.jpeg" alt=""><br><img src="https://raw.githubusercontent.com/Ice-Storm/ice-storm.github.io/master/images/2017review/WechatIMG44.jpeg" alt=""><br><img src="https://raw.githubusercontent.com/Ice-Storm/ice-storm.github.io/master/images/2017review/WechatIMG45.jpeg" alt=""></p><p><img src="https://raw.githubusercontent.com/Ice-Storm/ice-storm.github.io/master/images/2017review/WechatIMG47.jpeg" alt=""><br><img src="https://raw.githubusercontent.com/Ice-Storm/ice-storm.github.io/master/images/2017review/WechatIMG48.jpeg" alt=""></p><h3 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h3><p>砥砺前行~</p><ul><li>深入学习一下Go语言，并且在项目里实践</li><li>Docker，Rancher深入学习</li><li>把Github的坑填完</li><li>初探ML，毕竟公司有大神指导 :-D</li><li>明确一下以后发展的方向，技术和生活两方面</li><li>把叶叶拐回家让父母认识认识这个小呆子</li><li>尤克里里在溜一点，生活气在多一点，就这样吧~</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;之前没有如此强烈的想写年终的总结的冲动，但是今年经历了太多的事情，不如就此回顾一下2017在展望一下2018吧。&lt;/p&gt;
    
    </summary>
    
      <category term="review2017" scheme="http://yoursite.com/categories/review2017/"/>
    
    
      <category term="review2017" scheme="http://yoursite.com/tags/review2017/"/>
    
  </entry>
  
  <entry>
    <title>浅析Node的nextTick</title>
    <link href="http://yoursite.com/2017/07/22/%E6%B5%85%E6%9E%90Node%E7%9A%84nextTick/"/>
    <id>http://yoursite.com/2017/07/22/浅析Node的nextTick/</id>
    <published>2017-07-22T06:48:29.000Z</published>
    <updated>2017-07-22T12:52:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>看thinkjs源码的时候发现下面这段代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cluster.on(<span class="string">'exit'</span>, worker =&gt; &#123;</span><br><span class="line">  think.log(<span class="keyword">new</span> <span class="built_in">Error</span>(think.locale(<span class="string">'WORKER_DIED'</span>, worker.process.pid)), <span class="string">'THINK'</span>);</span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> cluster.fork());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>  这段代码的意思很简单，就是cluster挂了以后重新fork一个。<br>  但是注意到其中的<code>process.nextTick(() =&gt; cluster.fork());</code>这行，刚开始想了一下没有理解为什么不直接<code>fork</code>，后面仔细想了一下，发现如果直接<code>fork</code>，在<code>fork</code>的过程中又出现错误导致进程退出，而<code>cluster</code>又监听到<code>exit</code>的事件，就会不断的重复这个过程，阻塞Node进程。<br>  如果使用<code>process.nextTick(() =&gt; cluster.fork());</code>则不会阻塞Node的事件循环，只会在<code>Event Loop</code>的<code>close callbacks</code>阶段执行<code>fork</code>，即使程序一直<code>fork</code>失败也不会导致程序假死。(如果有疑问可以阅读文章末的扩展阅读)。<br>  下面的Demo说明了为什么使用了<code>nextTick</code>不会导致程序假死。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter; </span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">event.on(<span class="string">'some_event'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  count++;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'some_event 事件触发'</span> + count);</span><br><span class="line">  <span class="keyword">if</span> (count &lt; num) &#123;</span><br><span class="line">    event.emit(<span class="string">'some_event'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">event.emit(<span class="string">'some_event'</span>); </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'what ?'</span>)</span><br></pre></td></tr></table></figure></p><p>运行这段代码就会输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">some_event 事件触发1</span><br><span class="line">some_event 事件触发2</span><br><span class="line">some_event 事件触发3</span><br><span class="line">some_event 事件触发4</span><br><span class="line">some_event 事件触发5</span><br><span class="line">some_event 事件触发6</span><br><span class="line">some_event 事件触发7</span><br><span class="line">some_event 事件触发8</span><br><span class="line">some_event 事件触发9</span><br><span class="line">some_event 事件触发10</span><br><span class="line">what ?</span><br></pre></td></tr></table></figure></p><p>  可以发现 <code>what ?</code> 在最后才输出。如果把num设置的非常大就会报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">internal/process/next_tick.js:148</span><br><span class="line">    nextTickQueue.push(&#123;</span><br><span class="line">                 ^</span><br><span class="line">RangeError: Maximum call stack size exceeded</span><br></pre></td></tr></table></figure></p><p>  V8不断的向事件队列里添加任务，最终导致出现溢出，把<code>event.emit(&#39;some_event&#39;)</code>改写成<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  event.emit(<span class="string">'some_event'</span>) </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>  就会发现输出成了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ome_event 事件触发1</span><br><span class="line">what ?</span><br><span class="line">some_event 事件触发2</span><br><span class="line">some_event 事件触发3</span><br><span class="line">some_event 事件触发4</span><br><span class="line">some_event 事件触发5</span><br><span class="line">some_event 事件触发6</span><br><span class="line">some_event 事件触发7</span><br><span class="line">some_event 事件触发8</span><br><span class="line">some_event 事件触发9</span><br><span class="line">some_event 事件触发10</span><br></pre></td></tr></table></figure></p><p>  <code>what ?</code>并不会被阻塞，而且无论<code>num</code>改成多少，都不会出现栈溢出的错误。<br>  Node的<code>Event loop</code>执行流程如图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">|      nextTick（队列执行）</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">|       nextTick（队列执行）</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      </span><br><span class="line">|      nextTick（队列执行）         ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;─────┤  connections, │</span><br><span class="line">│  └──────────┬────────────┘      |               |</span><br><span class="line">|      nextTick（队列执行）         │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">|       nextTick（队列执行）</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure></p><p>  直接<code>event.emit(&#39;some_event&#39;)</code>的时候，Node不断的把收集到的事件塞到<code>I/O callbacks</code>这个队列，如果有大量的事件塞入就会最终导致溢出，就是上面的<code>Maximum call stack size exceeded</code>错误。<br>  如果加了<code>process.nextTick</code>则会不断的把<code>emit</code>的事件回调加到<code>nextTickQueue</code>队列，在各个主队列切换的时候执行，见上图的 <code>nextTick（队列执行）</code>。上面的那段Demo把<code>event.emit(&#39;some_event&#39;)</code>修改后的执行顺序就是<br>  1、发送事件<br>  2、把事件回调函数添加到<code>nextTickQueue</code>(注意，这个时候<code>nextTickQueue</code>队列里只有一个事件回调函数，如果当前队列尚未执行完毕并且没有发生切换，则<code>nextTickQueue</code>队列里的事件永远不会执行)<br>  3、执行<code>nextTickQueue</code>里的第一个事件回调(当前队列执行完毕或者执行到一定数量发生切换时，事件回调又会重新创建一个新的<code>nextTickQueue</code>队列并添加一个事件回调)<br>  4、然后同上<br>  这样就没有阻塞Node的事件循环，无论num多大都不会撑爆<code>I/O callbacks</code>队列。其实最核心的思想就是将任务拆解到若干次事件循环中，逐步执行。</p><p>扩展阅读<br>  <a href="https://github.com/creeperyang/blog/issues/26" target="_blank" rel="noopener">Node.js的event loop及timer/setImmediate/nextTick</a><br>  <a href="http://www.cnblogs.com/bingooo/p/6720540.html" target="_blank" rel="noopener">Node.js 原理简介</a><br>  <a href="https://yjhjstz.gitbooks.io/deep-into-node/content/" target="_blank" rel="noopener">深入理解Node.js：核心思想与源码分析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看thinkjs源码的时候发现下面这段代码。&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cluster.on(&lt;span class=&quot;string&quot;&gt;&#39;exit&#39;&lt;/span&gt;, worker =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  think.log(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Error&lt;/span&gt;(think.locale(&lt;span class=&quot;string&quot;&gt;&#39;WORKER_DIED&#39;&lt;/span&gt;, worker.process.pid)), &lt;span class=&quot;string&quot;&gt;&#39;THINK&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  process.nextTick(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; cluster.fork());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Node" scheme="http://yoursite.com/categories/Node/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/Node/JavaScript/"/>
    
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Sinatra扩展机制</title>
    <link href="http://yoursite.com/2017/07/22/Sinatra%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2017/07/22/Sinatra扩展机制/</id>
    <published>2017-07-21T16:43:19.000Z</published>
    <updated>2017-07-22T12:38:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Sinatra通过<code>helpers</code>和<code>register</code>函数进行扩展<br>首先看一下<code>helpers</code>函数，用来是来扩展Base类的实例方法。</p><a id="more"></a><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helpers</span><span class="params">(*extensions, &amp;block)</span></span></span><br><span class="line">  class_eval(&amp;block)   <span class="keyword">if</span> block_given?</span><br><span class="line">  <span class="keyword">include</span>(*extensions) <span class="keyword">if</span> extensions.any?</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在看一下<code>register</code>函数,用来扩展Base类的类方法<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(*extensions, &amp;block)</span></span></span><br><span class="line">  extensions &lt;&lt; Module.new(&amp;block) <span class="keyword">if</span> block_given?</span><br><span class="line">  @extensions += extensions</span><br><span class="line">  extensions.each <span class="keyword">do</span> <span class="params">|extension|</span></span><br><span class="line">    extend extension</span><br><span class="line">    extension.registered(<span class="keyword">self</span>) <span class="keyword">if</span> extension.respond_to?(<span class="symbol">:registered</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>两个方法都支持通过代码块扩展，也支持通过Module来扩展。</p><p>两种扩展方法对应Sinatra的两种编程风格。</p><p>Sinatra编程的两种风格:</p><p>经典风格:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span><span class="string">'sinatra'</span></span><br><span class="line"></span><br><span class="line">get <span class="string">'/'</span> <span class="keyword">do</span></span><br><span class="line">  <span class="string">"hello world"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>模块化风格:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span><span class="string">'sinatra/base'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> &lt; Sinatra::Base</span></span><br><span class="line"></span><br><span class="line">  get <span class="string">"/"</span> <span class="keyword">do</span></span><br><span class="line">    <span class="string">"hello world"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  run!</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>为两种风格编写扩展:</p><p>Sinatra扩展也分为两种:</p><p>helper 型<br>dsl 型</p><p>helper型:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'sinatra/base'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Sinatra</span></span></span><br><span class="line">  <span class="class"><span class="keyword">module</span> <span class="title">FormatHelper</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">escape_html</span><span class="params">(text)</span></span></span><br><span class="line">      Rack::Utils.escape_html(text)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  helpers FormatHelper </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>classic style 使用extension</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'sinatra'</span></span><br><span class="line"></span><br><span class="line">get <span class="string">'/'</span> <span class="keyword">do</span></span><br><span class="line">  escape_html(<span class="string">"x &gt; y"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>modular style 使用extension</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'sinatra/base'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> &lt; Sinatra::Base</span></span><br><span class="line"></span><br><span class="line">  helpers Sinatra::FormatHelper</span><br><span class="line"></span><br><span class="line">  get <span class="string">'/'</span> <span class="keyword">do</span></span><br><span class="line">    escape_html(<span class="string">"x &gt; y"</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  run!</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里的<code>helpers</code>其实相当于<code>include</code></p><p>dsl型:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'sinatra/base'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Sinatra</span></span></span><br><span class="line">  <span class="class"><span class="keyword">module</span> <span class="title">Devise</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">authenticate!</span></span></span><br><span class="line">      before &#123;</span><br><span class="line">        halt <span class="number">403</span>, <span class="string">"You Bastards!"</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  register Devise</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>classic style 使用 dsl extension</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'sinatra'</span></span><br><span class="line"></span><br><span class="line">authenticate!</span><br><span class="line"></span><br><span class="line">get <span class="string">'/'</span> <span class="keyword">do</span></span><br><span class="line">  escape_html(<span class="string">"x &gt; y"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>modular style 使用 dsl extension</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'sinatra/base'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> &lt; Sinatra::Base</span></span><br><span class="line">  register Sinatra::Devise</span><br><span class="line"></span><br><span class="line">  authenticate!</span><br><span class="line"></span><br><span class="line">  get <span class="string">'/'</span> <span class="keyword">do</span></span><br><span class="line">    <span class="string">"hello world"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  run!</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上面就是两种扩展的用法，我们在深入一点</p><p>在<code>Sinatra/main</code>的最后几行可以看到<code>extend Sinatra::Delegator</code>，其实当 <code>require &#39;sinatra&#39;</code>的时候就是执行的上面那行代码，作为整个Sinatra的入口。</p><p>看一下<code>Delegator</code>模块,默认的target是<code>Application</code>,也就是<code>helpers</code>和<code>register</code>等Sinatra的一干关键字<code>get post ...</code>等都是通过动态派发给<code>Application</code>类执行的。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Delegator</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">delegate</span><span class="params">(*methods)</span></span></span><br><span class="line">    methods.each <span class="keyword">do</span> <span class="params">|method_name|</span></span><br><span class="line">      define_method(method_name) <span class="keyword">do</span> <span class="params">|*args, &amp;block|</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>(*args, &amp;block) <span class="keyword">if</span> respond_to? method_name</span><br><span class="line">        Delegator.target.send(method_name, *args, &amp;block)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      private method_name</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  delegate <span class="symbol">:get</span>, <span class="symbol">:patch</span>, <span class="symbol">:put</span>, <span class="symbol">:post</span>, <span class="symbol">:delete</span>, <span class="symbol">:head</span>, <span class="symbol">:options</span>, <span class="symbol">:link</span>, <span class="symbol">:unlink</span>,</span><br><span class="line">           <span class="symbol">:template</span>, <span class="symbol">:layout</span>, <span class="symbol">:before</span>, <span class="symbol">:after</span>, <span class="symbol">:error</span>, <span class="symbol">:not_found</span>, <span class="symbol">:configure</span>,</span><br><span class="line">           <span class="symbol">:set</span>, <span class="symbol">:mime_type</span>, <span class="symbol">:enable</span>, <span class="symbol">:disable</span>, <span class="symbol">:use</span>, <span class="symbol">:development?</span>, <span class="symbol">:test?</span>,</span><br><span class="line">           <span class="symbol">:production?</span>, <span class="symbol">:helpers</span>, <span class="symbol">:settings</span>, <span class="symbol">:register</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> &lt;&lt; self</span></span><br><span class="line">    <span class="keyword">attr_accessor</span> <span class="symbol">:target</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">self</span>.target = Application</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><code>Delegator</code>模块功能就是定义派发给<code>Application</code>的函数（不管实现，只是转发）</p><p>整个通过<code>Delegator.delegate</code>注册的方法的实现都在<code>Helper</code>这个模块里，在<code>Base</code>类里<code>include</code>各种方法的实现，然后<code>Application</code>在继承<code>Base</code>,有点绕~。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line">  <span class="keyword">include</span> Rack::Utils</span><br><span class="line">  <span class="keyword">include</span> Helpers</span><br><span class="line">  <span class="keyword">include</span> Templates</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>通过一张图理清楚他们的关系</p><p><img src="https://l.ruby-china.org/photo/2017/767a092d-c6a4-43df-aee0-c20109525e34.jpeg!large" alt=""></p><p>定义自己的关键字，像<code>get post</code>这样。</p><p>扩展方法首先在<code>Delegator</code>模块调用<code>delegate</code>方法的时候添加你扩展的关键字名称，类似<code>delegate :get, :patch, ... , :my_fun</code>, 然后在<code>Helper</code>模块里定义<code>my_fun</code>的实现<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Helpers</span></span></span><br><span class="line">  my_fun</span><br><span class="line">    p <span class="string">"my_fun"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>这样就可以像关键字一样使用my_fun了，当然也可以通过上面介绍的两个方法进行扩展。</p><p>参考  <a href="http://saito.im/note/Sinatra-Extensions/" target="_blank" rel="noopener">http://saito.im/note/Sinatra-Extensions/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Sinatra通过&lt;code&gt;helpers&lt;/code&gt;和&lt;code&gt;register&lt;/code&gt;函数进行扩展&lt;br&gt;首先看一下&lt;code&gt;helpers&lt;/code&gt;函数，用来是来扩展Base类的实例方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Ruby" scheme="http://yoursite.com/categories/Ruby/"/>
    
      <category term="Sinatra" scheme="http://yoursite.com/categories/Ruby/Sinatra/"/>
    
    
      <category term="Ruby" scheme="http://yoursite.com/tags/Ruby/"/>
    
      <category term="Sinatra" scheme="http://yoursite.com/tags/Sinatra/"/>
    
  </entry>
  
</feed>
