<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Qin Yuan&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-13T10:46:07.952Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Qin Yuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ECDH秘钥协商算法原及在区块链中的应用场景</title>
    <link href="http://yoursite.com/2019/06/13/ecdh/"/>
    <id>http://yoursite.com/2019/06/13/ecdh/</id>
    <published>2019-06-13T10:43:15.000Z</published>
    <updated>2019-06-13T10:46:07.952Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<code>ECDH</code>全称是椭圆曲线迪菲-赫尔曼秘钥交换（Elliptic Curve Diffie–Hellman key Exchange），主要是用来在一个不安全的通道中建立起安全的共有加密资料，一般来说交换的都是<code>私钥</code>，这个密钥一般作为“对称加密”的密钥而被双方在后续数据传输中使用。</p><a id="more"></a><p>&emsp;&emsp;<code>ECDH</code>是建立在这样一个前提之上的，给定椭圆曲线上的一个点P，一个整数k，求Q=KP很容易；但是通过Q，P求解K很难。</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>&emsp;&emsp;我们通过一个经典的场景，Alice和Bob要在一条不安全的线路上交换秘钥，交换的秘钥不能被中间人知晓。<br>&emsp;&emsp;首先，双方约定使用<code>ECDH</code>秘钥交换算法，这个时候双方也知道了<code>ECDH</code>算法里的一个大素数<code>P</code>，这个<code>P</code>可以看做是一个算法中的常量。</p><blockquote><p><code>P</code>的位数决定了攻击者破解的难度</p></blockquote><p>&emsp;&emsp;还有一个整数<code>g</code>用来辅助整个秘钥交换，<code>g</code>不用很大，一般是2或者5，双方知道<code>g</code>和<code>p</code>之后就开始了<code>ECDH</code>交换秘钥的过程了。</p><hr><p>&emsp;&emsp;Alice知道了共用参数<code>p</code>和<code>g</code>，生成私有整数<code>a</code>作为私钥，公钥算法一般是公钥加密，私钥解密，公钥给对方来加密数据，拿到密文后私钥解密查看内容正确性，这个时候Alice直接通过线路告诉Bob自己的私钥<code>a</code>显然既不合理也是一件风险很大的事。<br>&emsp;&emsp;这个时候Alice需要利用<code>p</code>，<code>g</code>，<code>a</code>通过公式<code>g^a mod p = A</code>生成A作为公钥传递。</p><hr><p>&emsp;&emsp; Bob通过链路收到Alice发来的<code>p</code>，<code>g</code>，<code>A</code>，知道了Alice的公钥<code>A</code>。这个时候Bob也生成自己的私钥<code>b</code>，然后通过公式<code>g^b mod p = B</code>生成自己公钥<code>B</code>。<br>&emsp;&emsp; 在发送公钥<code>B</code>前，Bob通过<code>A^b mod p = K</code>生成K作为公共秘钥，但是并不发送给Alice，只通过链路发送<code>B</code>。</p><hr><p>&emsp;&emsp; Alice收到Bob发来的公钥<code>B</code>以后，同样通过<code>B^a mod p = K</code>生成公共秘钥K，这样Alice和Bob就通过不传递私钥<code>a</code>和<code>b</code>完成了对公共秘钥K的协商。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>&emsp;&emsp; 我们通过代入具体的数字来重复一下上面的过程。</p><p>&emsp;&emsp;1. Alice和Bob同意使用质数p和整数g：<br>&emsp;&emsp; p = 83, g = 8<br>&emsp;&emsp;<br>&emsp;&emsp; 2. Alice选择秘钥 a = 9, 生成公钥  g^a mod p = A 并发送<br>&emsp;&emsp; (8^9) mod 83 = 5<br>&emsp;&emsp;<br>&emsp;&emsp; 3. Bob选择秘钥 b = 21, 生成公钥 A^b mod p = K 并发送<br>&emsp;&emsp; (8^21) mod 83 = 18<br>&emsp;&emsp;<br>&emsp;&emsp; 4. Alice计算 B^a mod p = K<br>&emsp;&emsp; 18^9 mod 83 = 24<br>&emsp;&emsp;<br>&emsp;&emsp; 5. Bob计算 B^a mod p = K<br>&emsp;&emsp;  5^21 mod 83 = 24<br>&emsp;&emsp;<br>&emsp;&emsp; 至此<code>24</code>就是双方协商出来的秘钥。</p><h3 id="协议所面临的问题"><a href="#协议所面临的问题" class="headerlink" title="协议所面临的问题"></a>协议所面临的问题</h3><p>&emsp;&emsp;由于 ECDH 密钥交换协议不验证公钥发送者的身份，因此无法阻止中间人攻击。如果监听者 Mallory 截获了 Alice 的公钥，就可以替换为他自己的公钥，并将其发送给 Bob。Mallory 还可以截获 Bob 的公钥，替换为他自己的公钥，并将其发送给 Alice。这样，Mallory 就可以轻松地对 Alice 与 Bob 之间发送的任何消息进行解密。他可以更改消息，用他自己的密钥对消息重新加密，然后将消息发送给接收者。<br>&emsp;&emsp;为了解决此问题，Alice 和 Bob 可以在交换公钥之前使用数字签名对公钥进行签名。有两种方法可以实现此目的：</p><ul><li><p>用安全的媒体（例如语音通信或可信载运商）在双方之间传输数字签名密钥。</p></li><li><p>使用公共证书颁发机构 (CA) 向双方提供可信数字签名密钥。</p></li></ul><h3 id="区块链中的应用场景"><a href="#区块链中的应用场景" class="headerlink" title="区块链中的应用场景"></a>区块链中的应用场景</h3><p>&emsp;&emsp;当多个参与方共享同一个链路的时候，联盟链各参与方想要在同一个链路上实现通性的隔离，使用<code>ECDH</code>算法既可以实现TCP链接的复用，避免频繁建立大量链接，又可以保证同一链接间的通信隔离。</p><p>&emsp;&emsp;各参与方的身份在加入网络前已经有MSP（Membership Service Provider）来颁发验证过，这样就可以规避<code>ECDH</code>协议的缺陷。</p>]]></content>
    
    <summary type="html">
    
      ECDH秘钥协商算法
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="密码学" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>以太坊TXpool分析</title>
    <link href="http://yoursite.com/2019/06/02/txpool/"/>
    <id>http://yoursite.com/2019/06/02/txpool/</id>
    <published>2019-06-02T09:21:15.000Z</published>
    <updated>2019-06-02T09:37:07.268Z</updated>
    
    <content type="html"><![CDATA[<h3 id="以太坊交易流程"><a href="#以太坊交易流程" class="headerlink" title="以太坊交易流程"></a>以太坊交易流程</h3><p>&emsp;&emsp;用户通过<code>Json RPC</code>向以太坊网络发送的交易请求最后都会被<code>go-ethereum/internal/ethapi/api.go</code>的<code>SendTransaction</code>函数所接收。</p><a id="more"></a><p>&emsp;&emsp;从接收用户传入的参数，到把交易放入交易池等待广播的流程如下图所示：</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/txpool/50786776.png?raw=true" alt="Alt text"></p><p>&emsp;&emsp;整个流程从<code>SendTransaction</code>接收到<code>SendTxArgs</code>开始, <code>SendTxArgs</code>的结构如下；<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SendTxArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">   From     common.Address  <span class="string">`json:"from"`</span></span><br><span class="line">   To       *common.Address <span class="string">`json:"to"`</span></span><br><span class="line">   Gas      *hexutil.Uint64 <span class="string">`json:"gas"`</span></span><br><span class="line">   GasPrice *hexutil.Big    <span class="string">`json:"gasPrice"`</span></span><br><span class="line">   Value    *hexutil.Big    <span class="string">`json:"value"`</span></span><br><span class="line">   Nonce    *hexutil.Uint64 <span class="string">`json:"nonce"`</span></span><br><span class="line">   Data  *hexutil.Bytes     <span class="string">`json:"data"`</span></span><br><span class="line">   Input *hexutil.Bytes     <span class="string">`json:"input"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<code>SendTransaction</code>首先需要根据<code>From</code>字段来找到当前的账户，为签名交易做准备。<br>&emsp;&emsp;接着开始对交易进行预处理，为<code>SendTxArgs</code>的一些空字段设置默认值，比如分配<code>Nonce</code>，根据<code>To</code>字段是否为空，来判断交易是部署合约还是发送交易等。<br>&emsp;&emsp;进行预处理之后，需要对交易进行<code>RLP</code>编码，再根据之前获得的账户私钥进行签名。<br>&emsp;&emsp;最后在把交易提交到<code>TXpool</code>。</p><h3 id="交易序列化"><a href="#交易序列化" class="headerlink" title="交易序列化"></a>交易序列化</h3><p>&emsp;&emsp;交易的序列化是通过<code>toTransaction</code>这个函数来完成的。<br>&emsp;&emsp;序列化的时候根据<code>To</code>字段是否为<code>nil</code>来判断是将交易序列化成交易，还是创建合约。<br> &emsp;&emsp;调用<code>SendTranstion</code>接口的<code>Data</code>和<code>Input</code>字段，最终都会被赋值给<code>Input</code>，再被序列化成<code>Payload</code>放入交易池（TXpool）中，现在保留<code>Data</code>字主要是为了向前兼容，目前推荐用<code>Input</code>字段。</p><blockquote><p>当部署合约的时候<code>Input</code>是合约的代码，当发送交易的时候<code>Input</code>是交易的内容</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(args *SendTxArgs)</span> <span class="title">toTransaction</span><span class="params">()</span> *<span class="title">types</span>.<span class="title">Transaction</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> input []<span class="keyword">byte</span></span><br><span class="line">   <span class="keyword">if</span> args.Data != <span class="literal">nil</span> &#123;</span><br><span class="line">      input = *args.Data</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> args.Input != <span class="literal">nil</span> &#123;</span><br><span class="line">      input = *args.Input</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> args.To == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> types.NewContractCreation(<span class="keyword">uint64</span>(*args.Nonce), (*big.Int)(args.Value), <span class="keyword">uint64</span>(*args.Gas), (*big.Int)(args.GasPrice), input)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> types.NewTransaction(<span class="keyword">uint64</span>(*args.Nonce), *args.To, (*big.Int)(args.Value), <span class="keyword">uint64</span>(*args.Gas), (*big.Int)(args.GasPrice), input)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最终序列化后的交易包含以下字段，需要注意的是不包含<code>From</code>字段，把交易和发送者解耦以后可以支持域名地址，提供了更多的可能性。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> txdata <span class="keyword">struct</span> &#123;</span><br><span class="line">   AccountNonce <span class="keyword">uint64</span>          <span class="string">`json:"nonce"    gencodec:"required"`</span></span><br><span class="line">   Price        *big.Int        <span class="string">`json:"gasPrice" gencodec:"required"`</span></span><br><span class="line">   GasLimit     <span class="keyword">uint64</span>          <span class="string">`json:"gas"      gencodec:"required"`</span></span><br><span class="line">   Recipient    *common.Address <span class="string">`json:"to"       rlp:"nil"`</span> <span class="comment">// nil means contract creation</span></span><br><span class="line">   Amount       *big.Int        <span class="string">`json:"value"    gencodec:"required"`</span></span><br><span class="line">   Payload      []<span class="keyword">byte</span>          <span class="string">`json:"input"    gencodec:"required"`</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Signature values</span></span><br><span class="line">   V *big.Int <span class="string">`json:"v" gencodec:"required"`</span></span><br><span class="line">   R *big.Int <span class="string">`json:"r" gencodec:"required"`</span></span><br><span class="line">   S *big.Int <span class="string">`json:"s" gencodec:"required"`</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// This is only used when marshaling to JSON.</span></span><br><span class="line">   Hash *common.Hash <span class="string">`json:"hash" rlp:"-"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>r,s,v是交易签名后的值，它们可以被用来生成签名者的公钥；R，S是ECDSA椭圆加密算法的输出值，V是用于恢复结果的ID</p></blockquote><p>&emsp;&emsp;用户私钥签名序列化的交易以后就会被放入到交易池中。</p><h3 id="交易池"><a href="#交易池" class="headerlink" title="交易池"></a>交易池</h3><p>&emsp;&emsp;无论是本节点创建的交易(<code>local</code>)还是其他节点广播过来的交易(<code>remote</code>)，都会缓存在<code>TXpool</code>中，当需要生成区块时，就从<code>TXpool</code>中选择合适的交易打包成块，经由共识最终确认。<br>&emsp;&emsp;<code>TXpool</code>的核心功能</p><ul><li>缓存交易</li><li>在打包区块前，对交易进行验证</li><li>过滤无效交易</li><li>惩罚恶意发送大量交易的账户</li></ul><p>&emsp;&emsp;<code>TXpool</code>的核心结构如下图；</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/txpool/71987537.png?raw=true" alt="Alt text"></p><p>&emsp;&emsp;<code>TXpool</code>最为核心的结构是两个Map<code>queued</code>和<code>pending</code>，用来存未验证的交易和验证过的交易。</p><h4 id="添加交易"><a href="#添加交易" class="headerlink" title="添加交易"></a>添加交易</h4><p>&emsp;&emsp;添加交易到<code>TXpool</code>的过程比较简单，总体流程是这样的；</p><ul><li>验证交易的有效性</li><li>判断交易的<code>price</code>是否大于缓存中最小的，如果小于就拒收，如果大于就删除最小的交易，把本次交易插入<code>pending</code></li><li>如果这个<code>nonce</code>已经存在，依然是按照<code>price</code>的大小进行替换</li><li>如果交易有效，不能替换<code>pending</code>里面的任何交易，则添加到<code>queued</code>中</li></ul><h4 id="清理交易池"><a href="#清理交易池" class="headerlink" title="清理交易池"></a>清理交易池</h4><p>&emsp;&emsp;<code>TXpool</code>存在内存中，不可能无限大，等超过一定阈值就需要对交易池里面的交易进行清理。</p><blockquote><p>pending的缓冲区容量默认是 4096，queued的缓冲区容量默认是1024</p></blockquote><p>&emsp;&emsp;清理交易分为清理<code>queued</code>和清理<code>pending</code>，清理顺序<code>queued</code>-&gt;<code>pending</code>-&gt;<code>queued</code></p><hr><p>&emsp;&emsp;当满足以下条件的时候就会清理<code>queued</code></p><ul><li>当<code>nonce</code>小于当前账号发送<code>noce</code>的最小值，也就是说之前的交易已经全部上链</li><li>当前的<code>nonce</code>符合条件可以移动到<code>pending</code>队列中，先从<code>queued</code>清除，然后移动（<code>send</code>）到<code>pending</code>中</li><li>账户余额不足以支持该交易的花费了</li><li>交易数量超过了缓冲区</li></ul><blockquote><p>清理<code>queued</code>会影响<code>pending</code>的大小，所以<code>queued</code>清理优先级高</p></blockquote><hr><p>&emsp;&emsp;清理<code>pending</code>时，首先把超过每个账户可执行交易数量(<code>AccountSlots</code>)的数量，按照从大到小记录下来，接着按照从多到少删除。<br>&emsp;&emsp;举个例子来说明剔除的规则；</p><blockquote><p>假如<code>AccountSlots</code>为4<br>有四个超出的账户，它们的数量分别是10， 9， 7，5<br>第一次剔除 [10]             剔除结束 [10]<br>第二次剔除 [10, 9]         剔除结束 [9，9]<br>第三次剔除 [9, 9, 7]       剔除结束 [7, 7, 7]<br>第四次剔除 [7, 7 , 7 ,5]  剔除结束 [5，5，5，5]<br>这个时候如果还是超出限制，则继续剔除<br>第五次剔除 [5, 5 , 5 ,5]  剔除结束 [4，4，4，4]</p></blockquote><hr><p>&emsp;&emsp;接着清理<code>ququed</code>，规则也很简单，越先进入queued的越后删除，直到清理到满足最大队列长度（<code>GlobalQueue</code>）为止。</p><h3 id="重构交易池-reset"><a href="#重构交易池-reset" class="headerlink" title="重构交易池(reset)"></a>重构交易池(<code>reset</code>)</h3><p>&emsp;&emsp;到这一步还有一个问题没有解决，以太坊是分布式系统，当本地节点已经挑选出最优的交易，准备广播给整个网络，这个时候矿工已经打包了一个区块，本地节点的区块头就是旧的了，本地筛选的交易有可能已经被打包，如果已经被打包生成了新区块，再将这个交易广播已经没有任何的意义，甚至我们费尽心思准备好的<code>pending</code>缓冲区里的交易都是无效的。<br>&emsp;&emsp;为了避免上面的情况发生，我们就需要监听链是否有新区块产生，也就是<code>ChainHeadEvent</code>事件。<br>&emsp;&emsp;当监听到<code>ChainHeadEvent</code>事件时候，我们又该如何调整<code>queued</code>和<code>pending</code>呢？<br>&emsp;&emsp;首先需要将已经分叉的链回退到同一个区块号上(<code>blockNumebr</code>)，有可能是本地节点领先，有可能是网络上其他节点领先，但无论怎样，都回退到同一个区块号。</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/txpool/59517862.png?raw=true" alt="Alt text"></p><p>&emsp;&emsp;本地节点回退时，撤销的交易保存到<code>discarded</code>切片中，网络上其他节点的撤销交易保存在<code>included</code>切片中。<br>&emsp;&emsp;当区块号一致的时候，还需要进一步的比较区块的<code>Hash</code>来进一步确认区块里面的交易是否一致，如果不一致一致回退到区块<code>Hash</code>为止，回退撤销的交易依旧保存在<code>discarded</code>和<code>included</code>切片中。<br>&emsp;&emsp;等完全确认本地和网络的链没有分叉的时候，就需要比较<code>discarded</code>和<code>included</code>里面的交易，因为网络上区块的生成优先级高于本地，所以需要剔除<code>discarded</code>中<code>inclueded</code>的交易，生成<code>reinject</code>切片，剔除完以后还需要对<code>TXpool</code>按照网络新生成区块的信息设置世界状态等信息，设置完以后，重新将<code>reinject</code>加入<code>TXpool</code>，加入以后在进行验证清理等流程。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考:"></a>思考:</h3><ul><li><p>以太坊在实现<code>TXpool</code>的时候为了保证数据的一致性使用大量的锁，性能一般。</p></li><li><p>当区块生成速度比较快的时候需要频繁的<code>reset</code>，导致<code>TXpool</code>需要占用比较多的资源。</p></li><li><p>是否有比较好的方法既可以保证数据的一致性又可以快速找到相同的根区块？</p></li></ul>]]></content>
    
    <summary type="html">
    
      以太坊TXpool源码分析
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="以太坊" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="以太坊" scheme="http://yoursite.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
  <entry>
    <title>以太坊RLP编码</title>
    <link href="http://yoursite.com/2019/05/20/rlp/"/>
    <id>http://yoursite.com/2019/05/20/rlp/</id>
    <published>2019-05-20T07:54:29.000Z</published>
    <updated>2019-05-20T08:01:37.602Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<code>RLP（Recursive Length Prefix）</code>递归长度前缀编码，<code>RLP</code>主要用于以太坊中数据的网络传输和持久化存储。</p><a id="more"></a><h3 id="为什么需要RLP编码"><a href="#为什么需要RLP编码" class="headerlink" title="为什么需要RLP编码"></a>为什么需要<code>RLP</code>编码</h3><p>&emsp;&emsp;比较常见的序列化方法有<code>JSON</code>，<code>ProtoBuf</code>，但是这些序列化方法在以太坊这样的场景下都有一些问题。</p><p>&emsp;&emsp;比如像<code>Json</code>编码，编码后的体积比较大。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Persion <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">uint</span> </span><br><span class="line">&#125;</span><br><span class="line">    p := &amp;Persion&#123;Name: <span class="string">"Tom"</span>, Age: <span class="number">22</span>&#125;</span><br><span class="line">    data, _ := json.Marshal(p)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line"><span class="comment">//  &#123;"Name":"Tom","Age":22&#125;</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;从编码后的结果可以看到，其实我们需要的数据是<code>Name</code>, <code>Tom</code>, <code>Age</code>, <code>22</code>，其余的括号和引号都是描述这种格式的，也就是冗余数据。<br>&emsp;&emsp;当然，会有人说可以用<code>protoBuf</code>这样的二进制格式，但是例如<code>JavaScript</code>这样的弱类型语言，是没有<code>int</code>类型的，所有数字都是用<code>Number</code>类型，底层用浮点数来实现，这样就会导致因为语言的不同编码后的数据有一定差异，最后得到的hash值也不同。<br>&emsp;&emsp;针对这些问题，以太坊设计了<code>RLP</code>编码，同时也大幅简化了编码规则。</p><h3 id="RLP编码定义"><a href="#RLP编码定义" class="headerlink" title="RLP编码定义"></a><code>RLP</code>编码定义</h3><p><code>RLP</code>简化了编码的类型，只定义了两种类型编码：</p><ul><li>byte数组</li><li>byte数组的数组，也就是列表</li></ul><h3 id="RLP编码基于上面两种数据类型提出了5条编码规则"><a href="#RLP编码基于上面两种数据类型提出了5条编码规则" class="headerlink" title="RLP编码基于上面两种数据类型提出了5条编码规则;"></a><code>RLP</code>编码基于上面两种数据类型提出了5条编码规则;</h3><h5 id="规则一"><a href="#规则一" class="headerlink" title="规则一"></a>规则一</h5><p>&emsp;&emsp;对于值在[0, 127]之间的单个字节，其编码是其本身；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a的编码是97</span><br></pre></td></tr></table></figure></p><h5 id="规则二"><a href="#规则二" class="headerlink" title="规则二"></a>规则二</h5><p>&emsp;&emsp;如果byte数组的长度<code>l&lt;=55</code>，编码的结果是数组本身，再加上<code>128+l</code>作为前缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">空字符串的编码是`128`，即 `128=128+0`</span><br><span class="line">`abc`的编码是`131 97 98 99`，其实`131=128+len(&quot;abc&quot;)`, `97 98 99`依次是`a b c`</span><br></pre></td></tr></table></figure></p><h5 id="规则三"><a href="#规则三" class="headerlink" title="规则三"></a>规则三</h5><p>&emsp;&emsp;如果数组长度大于<code>55</code>，编码结果第一个值是<code>183（128+55）</code>加数组长度的编码的长度，然后是数组长度本身的编码，最后是byte数组的编码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编码一个重复1024次&quot;a&quot;的字符串，其结果是`185 4 0 97 97 97 ...`</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;1024按照<code>大端编码</code>是<code>0000 0000 001</code>转换为十进制是<code>0 0 4 0</code>，省略前面的<code>0</code>,长度为2， 因此<code>185 = 183 + 2</code></p><h5 id="规则四"><a href="#规则四" class="headerlink" title="规则四"></a>规则四</h5><p>&emsp;&emsp;如果列表长度小于55，编码结果第一位是192加列表长度的编码的长度，然后依次连接各个子列表的编码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`[&quot;abc&quot;, &quot;def&quot;]`的编码结果是`200 131 97 98 99 131 100 101 102`</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;其中<code>abc</code>的编码是<code>131 97 98 99</code>, <code>131 = 128 + l</code>长度是4，<code>def</code>的编码是<code>131 100 101 102</code>，长度是4，总长度为<code>8</code>，编码结果的第一位<code>200 = 192 + 8</code></p><h5 id="规则五"><a href="#规则五" class="headerlink" title="规则五"></a>规则五</h5><p>&emsp;&emsp;如果列表的长度超过55，编码结果第一位是<code>247(192 + 55)</code>加列表长度的编码长度，然后是列表本身的编码，最后依次连接子列表的编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;The length of this sentence is more than 55 bytes, &quot;, &quot;I know it because I pre-designed it&quot;]</span><br></pre></td></tr></table></figure></p><p>的编码结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">248 88 179 84 104 101 32 108 101 110 103 116 104 32 111 102 32 116 104 105 115 32 115 101 110116 101 110 99 101 32 105 115 32 109 111 114 101 32 116 104 97 110 32 53 53 32 98 121 116 101115 44 32 163 73 32 107 110 111 119 32 105 116 32 98 101 99 97 117 115 101 32 73 32 112 114101 45 100 101 115 105 103 110 101 100 32 105 116</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中前两个字节的计算方式如下：</p><ul><li><p><code>248 = 247 + 1</code></p></li><li><p><code>88 = 86 + 2</code>， 在规则3的示例中，长度为86，而在此例中，由于有两个子字符串，每个子字符串本身的长度的编码各占1字节，因此总共占2字节。</p></li><li><p>第3个字节<code>179</code>依据规则2得出</p></li></ul><p>第55个字节<code>163</code>同样依据规则2得出<code>163=128+35</code></p><blockquote><p>其中<code>规则三</code>，<code>规则四</code>，<code>规则5</code>是递归定义的，就是可以允许嵌套</p></blockquote>]]></content>
    
    <summary type="html">
    
      以太坊RLP编码分析
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="以太坊， Etherum" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%EF%BC%8C-Etherum/"/>
    
    
      <category term="区块链， 以太坊" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%EF%BC%8C-%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
  <entry>
    <title>白话布隆过滤器（Bloom Filter）</title>
    <link href="http://yoursite.com/2019/04/30/BloomFilter/"/>
    <id>http://yoursite.com/2019/04/30/BloomFilter/</id>
    <published>2019-04-30T14:46:08.000Z</published>
    <updated>2019-04-30T14:49:56.001Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;要判断一个元素是不是在一个集合里，比较容易想到的方法是用数组，链表这样的数据结构把元素保存起来，然后依次比较来确定。<br>&emsp;&emsp;但是随着集合的变大，上面的这种方法就面临几个问题，首先比较的速度随着数据量的增加而变慢，其次存储集合的空间也越来越大。<br>&emsp;&emsp;为了解决上面的问题，就引入了<code>布隆过滤器（Bloom Filter）</code></p><a id="more"></a><h3 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h3><p>&emsp;&emsp;布隆过滤器的原理就是当一个元素被加入到集合的时候，用<code>K</code>个<code>Hash</code>函数将元素映射到一个<code>位图</code>中的<code>K</code>个点，并且把这个点的值设置为<code>1</code>，在每次检索的时候我们看一下这个点是不是都是<code>1</code>就知道集合中有没有这个元素了。<br>&emsp;&emsp;这样说可能比较抽象，举个例子：</p><p>&emsp;&emsp;我们假设<code>K</code>是<code>2</code>，有<code>Hash1</code>和<code>Hash2</code>两个哈希函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hash1 = n%3</span><br><span class="line">Hash2 = n%8</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后我们创建一个名叫<code>bitMap</code>长度是<code>20</code>的<code>位图</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitMap=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这个时候，我们要将7，存入到这个集合中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = 7</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;分别用<code>Hash1</code>和<code>Hash2</code>计算<code>n</code>哈希后的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hash1  -&gt;  1</span><br><span class="line">Hash2  -&gt;  7</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我们把<code>bitMap</code>对应的值置为1，从0开始<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitMap=[0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这样下次我们来查找<code>7</code>在不在这个集合的时候就可以用<code>Hash1</code>和<code>Hash2</code>计算完以后在<code>bitMap</code>集合中查找对应位置是否都是<code>1</code>，如果都是<code>1</code>则一定在集合中。</p><p>&emsp;&emsp;如果再在集合中插入13<br>&emsp;&emsp;分别用<code>Hash1</code>和<code>Hash2</code>计算<code>n</code>哈希后的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n = 13</span><br><span class="line">Hash1  -&gt;  1</span><br><span class="line">Hash2  -&gt;  5</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我们把<code>bitMap</code>对应的值置为1，从0开始<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitMap=[0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这个时候我们发现<code>1</code>被映射到了两次，但是并不影响我们在集合<code>[7, 13]</code>中快速找到7或者13。</p><p>&emsp;&emsp;但是当插入的数据量大幅提升的时候，甚至<code>bitMap</code>全部被置为<code>1</code>的时候问题就很严重了，误识率就非常高了，这个也是根据不同场景实现布隆过滤器所要考虑的问题。</p><p>&emsp;&emsp;尽管有这样的问题，但是仍然不能掩盖布隆过滤器的<code>空间利用率</code>和<code>查询时间</code>远超其他算法，插入数据和查询数据的时间复杂度都是<code>O(k)</code></p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>&emsp;&emsp;比较典型的应用场景就是检查垃圾邮箱的地址，比如我建立了一个垃圾邮件的布隆过滤器，当新邮件到来的时候我要快速的判断这封邮件是不是垃圾邮件。<br>&emsp;&emsp;还可以用来判断一个URL是不是恶意链接等等。<br>&emsp;&emsp;以太坊大量的用到了布隆过滤器，用来定位查找日志等。</p>]]></content>
    
    <summary type="html">
    
      深入理解布隆过滤器
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>深入理解`BucketTree`</title>
    <link href="http://yoursite.com/2019/04/18/BucketTree/"/>
    <id>http://yoursite.com/2019/04/18/BucketTree/</id>
    <published>2019-04-18T12:16:32.000Z</published>
    <updated>2019-04-18T12:42:46.707Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Bucket Tree结合了默克尔树和哈希表的特点，如果想要深入了解Bucket Tree就必须掌握默克尔树和哈希表。</p><p>&emsp;&emsp;Merkle Tree大多用来进行对比验证处理，特别是在分布式环境下进行比对或验证的时候可以大大减少数据传输量和计算的复杂度。</p><a id="more"></a><h3 id="默克尔树结构解析"><a href="#默克尔树结构解析" class="headerlink" title="默克尔树结构解析"></a><code>默克尔树结构解析</code></h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>默克尔树是一种树，一般是二叉树，也可以是多叉树；</li><li>默克尔树的叶子节点可以是数据项，也可以是数据项的哈希值；</li><li>非叶子节点的数据项是由其叶子节点Hash计算得到的；</li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>&emsp;&emsp;默克尔树是自底向上构建的，下面就是一颗典型的默克尔树。</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/bucketTree/1.jpg?raw=true" alt="Alt text"></p><p>&emsp;&emsp;首先计算ENTRY1-ENTRY4单元的数据哈希，然后分别存入到对应的叶子节点，这些叶子节点分别是HASH0-0,HASH0-1,HASH1-0,HASH1-1。<br>接着将相邻节点的哈希值合并成一个字符串，然后计算这个字符串的哈希值，得到的就是这两个节点父节点的哈希值。</p><p>&emsp;&emsp;如果用公式表示的话就是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HASH 0 = Hash（HASH 0-0 + HASH 0-1）、</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;如果树节点的个数是单数，就对它直接进行哈希运算，或者复制一次这个节点的哈希值，凑齐偶数个节点。</p><p>&emsp;&emsp;重复上述过程，自底向上就可以构建整个默克尔树了。</p><h5 id="Tips"><a href="#Tips" class="headerlink" title="Tips:"></a>Tips:</h5><ul><li>若两颗树的根哈希一直，则这两棵树的结构，节点内容必然相同。</li></ul><h4 id="默克尔树的优势"><a href="#默克尔树的优势" class="headerlink" title="默克尔树的优势"></a>默克尔树的优势</h4><p>&emsp;&emsp;当一个节点内容发生变化的时候，仅需要计算从该节点到根路径上所有节点节点的哈希，减少计算量，同时也方便快速定位数据发生变化的位置。</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a><code>哈希表</code></h3><p>&emsp;&emsp;哈希表也称散列表，根据键（key）快速定位值（value）的存储位置的数据结构。</p><h3 id="Bucket-Tree"><a href="#Bucket-Tree" class="headerlink" title="Bucket Tree"></a><code>Bucket Tree</code></h3><p>&emsp;&emsp;Bucket Tree拓展了哈希表的概念，引入了一个桶（bucket），也就是哈希桶。<br>&emsp;&emsp;其结构如下图所示:</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/bucketTree/2.jpg?raw=true" alt="Alt text"></p><p>&emsp;&emsp;KEY2和KEY3映射到相同的152号桶里。￼</p><p>&emsp;&emsp;Bucket tree在扩展哈希表的同时，又在哈希表上建立了默克尔树。</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/bucketTree/3.jpg?raw=true" alt="Alt text"></p><p>&emsp;&emsp;哈希表由一系列的哈希桶（bucket）组成，每个桶中存储着若干被散列到该桶中的数据项（entry）所以数据项按序排列，每一个哈希桶有一个哈希值来标识整个桶，该哈希值是桶内所有数据通过哈希计算所得。</p><p>&emsp;&emsp;除了底层的哈希表外，上层是一系列的默克尔树节点，一个默克尔树节点对应着下层的N个哈希桶或者默克尔树节点，这个N也称作默克尔树的聚合度。</p><h4 id="如此设计的目的："><a href="#如此设计的目的：" class="headerlink" title="如此设计的目的："></a>如此设计的目的：</h4><ul><li>​利用默克尔树的特点，使每次树状态改变，重新计算哈希的代价最小；</li><li>利用哈希表进行底层数据的维护，使得数据项均匀分布；</li></ul><p>&emsp;&emsp;例如上图中，一条新的数据项entry5插入，该数据项被散列到POS为1的桶中。该桶，即从该桶至根节点上所有的节点被标为粉红色，即为脏节点。仅对这些脏节点进行哈希重计算，便可得到一个新的哈希值用来代表新的树状态。</p><p>&emsp;&emsp;由于bucket tree是一棵固定大小的树（即底层的哈希表容量在树初始化之后，就无法更改了），随着数据量的增大，采用散列函数将所有的数据项进行均匀散列可以避免数据聚集的情况发生。</p><h4 id="Bucket-tree有两个重要的可调参数："><a href="#Bucket-tree有两个重要的可调参数：" class="headerlink" title="Bucket tree有两个重要的可调参数："></a>Bucket tree有两个重要的可调参数：</h4><ul><li>​capacity：表示哈希表的容量，该值越大，整课树所能容纳的数据项个数就越多，在聚合程度不变的前提下，树越高，从叶子节点到根节点的路径越长，哈希计算次数也越多。</li><li>aggreation：表示一个父节点对应的孩子节点的个数，该值越大，表示树的收敛速度越快，在哈希表容量不变的前提下，树更低，从叶子节点到根节点路径越短，哈希计算次数也越少。但是每个默克尔树节点的size就越大，增加磁盘IO开销。</li></ul><h5 id="Tips-1"><a href="#Tips-1" class="headerlink" title="Tips:"></a>Tips:</h5><ul><li>​当有比较多数据变更的时候，非常容易散列到不同bucket，这个时候可以并行计算新bucket的哈希值，加速构建默克尔树。</li><li>如果Bucket tree树比较大，并且用数据库来存储的话，加上读cache可以显著的提升性能。</li></ul>]]></content>
    
    <summary type="html">
    
      Hyperledger Fabric区块链的世界状态组织形式
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="账本" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E8%B4%A6%E6%9C%AC/"/>
    
      <category term="世界状态" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E8%B4%A6%E6%9C%AC/%E4%B8%96%E7%95%8C%E7%8A%B6%E6%80%81/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Kademlia算法原理详解</title>
    <link href="http://yoursite.com/2018/08/28/kad/"/>
    <id>http://yoursite.com/2018/08/28/kad/</id>
    <published>2018-08-28T14:22:44.000Z</published>
    <updated>2018-08-28T09:31:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>P2P网络有四个发展阶段：<code>集中式网络</code>，<code>纯分布式网络</code>，<code>混合式网络</code>，<code>结构化网络</code>。</p><a id="more"></a><h3 id="集中式网络"><a href="#集中式网络" class="headerlink" title="集中式网络"></a><code>集中式网络</code></h3><p><code>集中式</code>的P2P网络最简单，即一个节点保存了其他所有节点的索引信息，而索引信息又包括了节点IP，端口，节点资源等。节点之间互连的路由查询由中心节点完成，一旦和对等节点建立连接则与中心节点没有什么联系。集中式的P2P网络结构简单，实现容易，但是由于所有路由信息在中心节点存储，当节点数量变多扩展的时候容易出现性能瓶颈，也容易出现单点故障。</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/kad/1.jpg?raw=true" width="70%" height="70%"></p><h3 id="纯分布式网络"><a href="#纯分布式网络" class="headerlink" title="纯分布式网络"></a><code>纯分布式网络</code></h3><p><code>纯分布式</code>的P2P网络移除了中心节点，在P2P网络之间建立了随机网络，一个新加入的节点和P2P网络中的某个随机节点建立连接，从而形成一个随机的拓扑结构。新节点和邻居节点建立连接以后还需要全网广播，让整个网络知道自己的存在。</p><p>全网广播的方式是，该节点向自己的邻居节点广播，邻居节点收到消息以后在向自己的邻居节点广播，以此类推，从而广播到整个网络。这种广播也称为泛洪机制。</p><p>纯分布式的P2P网络不存在集中式网络的单点故障和中心性能瓶颈的问题，具有较好的扩展性，但是泛洪机制又引入了新的问题，一是容易形成泛洪循环，A节点发出的消息经过节点B到节点C，节点C在<br>广播到节点A，形成了一个消息循环；另一个是响应消息风暴的问题，如果节点A想请求的资源被很多节点所拥有，那么在短时间内就会出现大量的节点向A节点发送响应消息，可能会让节点A崩溃。</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/kad/2.jpg?raw=true" width="70%" height="70%"></p><h3 id="混合式网络"><a href="#混合式网络" class="headerlink" title="混合式网络"></a><code>混合式网络</code></h3><p><code>混合式</code>的P2P网络就是混合了<code>集中式</code>和<code>纯分布式</code>的结构，网络中存在多个超级节点组成分布式网络，而每个超级节点则与多个普通节点组成局部的集中式网络。一个新的普通节点加入网络需要先选择一个超级节点通信，该超级节点在推送其他超级节点列表给新加入的节点，加入节点在根据超级节点列表中的状态选择加入哪个超级节点作为父节点。这种结构限制了泛洪广播的范围，避免了大规模的泛洪问题。<br>在实际应用中，<code>混合式</code>结构是相对灵活且比较有效的网络架构，实现也相对容易。</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/kad/3.jpg?raw=true" width="70%" height="70%"></p><h3 id="结构化网络"><a href="#结构化网络" class="headerlink" title="结构化网络"></a><code>结构化网络</code></h3><p><code>结构化P2P网络</code>也是一种分布式网络结构，但又与<code>纯分布式</code>有所区别。<code>纯分布式</code>网络就是一个随机网络，而结构化网络则将所有节点按照某种结构有序的组织起来，比如形成一个环状网络或者树状的网络。<br>结构化网络的具体实现上普遍都是基于DHT(Distributed Hash Table，分布式哈希表) 算法。具体的实现方案有 Chord、Pastry、CAN、Kademlia 等算法，其中 Kademlia 也是以太坊网络的实现算法，后面中重点讲解它的实现原理。</p><h2 id="Kad算法原理"><a href="#Kad算法原理" class="headerlink" title="Kad算法原理"></a><code>Kad</code>算法原理</h2><p><code>Kad</code>算法用来在分布式环境中准确的路由，定位数据。</p><p>在Kad网络中每个节点都有一个随机产生的160bit的标识符作为节点ID，Kad算法通过计算节点ID间的距离来快速路由和定位资源。</p><p>Kad算法通过异或节点ID来计算节点之间的距离，这个距离是逻辑上的距离并不是节点间物理上的距离。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">节点A的ID（010）</span><br><span class="line">节点B的ID（110）</span><br><span class="line">A ⊕ B = 100（二进制） = 4（十进制）</span><br></pre></td></tr></table></figure><p>在上面异或度量节点距离的基础之上，Kad算法还可以将整个网络划分成一个二叉前缀树，每个节点映射到二叉树上的某个叶子。</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/kad/kbucket.png?raw=true" width="80%" height="80%"></p><p>映射规则：</p><ul><li>将节点ID（160bit）从高到低依次分层，第N位就对应了第N层</li><li>如果是0进入左子树，如果是1则进入右子树</li><li>每个节点就对应树中的一个叶子</li></ul><p>在这种二叉树结构下，对于每个节点来说离他它越近的值节点的异或距离也越近，每一个节点都可以从自己的视角来对二叉树进行拆分，拆分规则是从根节点开始，把不包含自己的子树拆分出来，然后在剩下的子树再拆分不包含自己的下一层子树，以此类推，直到最后只剩下自己。上图的例子就是以节点ID为110的视角多二叉树进行了拆分。</p><p>因为Kad算法默认的节点ID是160bit，所有拆分以后最多可以有160课子树，而对于每个子树，如果我们分别知道里面的一个节点，就可以利用这个节点递归路由到子树的任意一个节点。</p><p>但是在实际应用中，由于节点是动态增加减少的，如果知道的节点恰好宕机或者下线了就会出现问题，为了保证系统的鲁棒性Kad算法又引入了K桶（K-bucket）的机制。</p><h3 id="K桶（k-bucket）"><a href="#K桶（k-bucket）" class="headerlink" title="K桶（k-bucket）"></a>K桶（<code>k-bucket</code>）</h3><p>节点在完成拆分子树以后需要记录每个子树里面K个节点，K可以由用户自己定义，在BT下载使用的Kad算法中K是8。</p><p><code>K-bucket</code>实际上就是路由表，每个节点按照自己的视角拆分完子树以后可以得到N个子树，那就需要维护N个路由表，对应N个K-bucket.</p><p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/kad/k_bucket.png?raw=true" width="80%" height="80%"></p><p>每个节点维护N个K-bucket以后还会出现一个问题，K-bucket中的节点也会动态的增减，那又如何K-bucket的稳定呢？</p><h3 id="K桶的更新机制"><a href="#K桶的更新机制" class="headerlink" title="K桶的更新机制"></a>K桶的更新机制</h3><p><code>K-bucket</code>主要有三种方式来更新路由表。</p><ul><li>主动收集节点，主动发起FIND_NODE查询节点的请求，从而更新K桶的节点信息。</li><li>被动收集节点，当收到其他节点发送过来的请求（如：FIND_NODE、FIND_VALUE），会把对方的节点ID加入到某个K桶中。</li><li>检测失效节点，周期性的发起PING请求，判断K桶中某个节点是否在线，然后清理K桶中哪些下线的节点。</li></ul><p>当一个节点ID被用来更新K桶的时候进行如下步骤：</p><ul><li>计算自己和目标节点ID的距离d</li><li>通过距离d找到对应的K桶，如果ID已经在K桶中了则把对应项移到K桶的末尾</li><li><p>如果不在K桶中则有两种情况</p><p>  1.如果该K桶存储的节点小于K个，则直接把目标节点插入到K-桶尾部；<br>  2.如果该K桶存储节点大于等于K个，则选择K-桶中的头部节点进行PING操作，检测节点是否存活。如果头部节点没有响应，则移除该头部节点，并将目标节点插入到队列尾部；如果头部节点有响应，则把头部节点移到队列尾部，同时忽略目标节点。</p></li></ul><p>通过这种更新策略可以保证在线时间长的节点有较大的可能继续保存在K桶中，提高了稳定网络构建路由表的成本。</p><h3 id="加入Kad网络"><a href="#加入Kad网络" class="headerlink" title="加入Kad网络"></a>加入<code>Kad</code>网络</h3><p>一个新节点需要加入Kad网络有如下的步骤</p><ul><li>新节点A需要一个种子节点B作为引导，并把该种子节点加入到K桶中。</li><li>生成一个随机的节点ID，直到离开网络一直使用。</li><li>向节点B发送FIND_NODE请求。</li><li>节点B在收到节点A的FIND_NODE请求后，会根据FIND_NODE请求的约定，找到K个距离A最近的节点，并返回给A节点</li><li>A收到这些节点以后，就把它们加入到自己的K桶中</li><li>然后节点A会继续向这些刚拿到节点发起FIND_NODE请求，如此往复，直到A建立了足够详细的路由表。</li></ul><h3 id="定位节点"><a href="#定位节点" class="headerlink" title="定位节点"></a>定位节点</h3><p>节点查询可以同步进行也可以异步进行，同时查询并发一般为3。</p><ul><li>确定目标ID对应路由表中的K桶位置，然后从自己的K-桶中筛选出K个距离目标ID最近的节点，并同时向这些节点发起FIND_NODE的查询请求。</li><li>被查询节点收到FIND_NODE请求后，从对应的K桶中找出自己所知道的最近的K个节点，并返回给发起者。</li><li>发起者在收到这些节点后，更新自己的结果列表，并再次从其中K个距离目标节点ID最近的节点，挑选未发送请求的节点重复第一步</li><li>不断重复上面的步骤直到找到目标节点为止</li></ul>]]></content>
    
    <summary type="html">
    
      P2P网络的演化，Kademlia算法的原理
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="P2P网络" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/P2P%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="P2P网络" scheme="http://yoursite.com/tags/P2P%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Fabric共识模块源码分析</title>
    <link href="http://yoursite.com/2018/04/10/pbft/"/>
    <id>http://yoursite.com/2018/04/10/pbft/</id>
    <published>2018-04-10T12:15:41.000Z</published>
    <updated>2018-04-10T12:50:12.473Z</updated>
    
    <content type="html"><![CDATA[<p>正好这些天要有一个需求要帮客户魔改Fabric-v0.6，把一些hyperchain的高级特性移植过去，借此机会把之前看过的源码在梳理一下。<br>下面就是对Fabric共识模块的源码分析和梳理，代码都是以Fabric-v0.6-preview为例，在1.0及后续版本中都移除了PBFT部分，用了更好的SBFT，目前这一部分还在开发中。</p><a id="more"></a><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>可以看到共识模块目录如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">consensus</span><br><span class="line">├── controller</span><br><span class="line">├── executor</span><br><span class="line">├── helper</span><br><span class="line">│   └── persist</span><br><span class="line">├── noops</span><br><span class="line">├── pbft</span><br><span class="line">└── util</span><br><span class="line">    └── events</span><br></pre></td></tr></table></figure><p>目录含义如下</p><ul><li><code>controller</code> 用来控制Fabric选择什么样的共识算法，默认是<code>noops</code>。</li><li><code>executor</code> 封装了消息队列中对交易的处理。</li><li><code>helper</code> 对外提供接口调用和数据持久化接口。</li><li><code>noops</code> 提供了如何编写Fabric共识算法的Demo。</li><li><code>pbft</code> PBFT算法的具体实现。</li><li><code>util</code> 实现了一个peer节点到共识算法的一个消息通道，和一个消息队列。</li></ul><h3 id="流程概览"><a href="#流程概览" class="headerlink" title="流程概览"></a>流程概览</h3><p>Fabric网络通过一个<code>EventLoop</code>和共识算法进行交互，所有的操作都通过对事件循环中的事件监听进行推进。</p><p>整体流程如下图所示。<br><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/2017review/PBFT.jpeg?raw=true" alt="Alt text"></p><h3 id="Consensus模块接口"><a href="#Consensus模块接口" class="headerlink" title="Consensus模块接口"></a>Consensus模块接口</h3><p><code>fabric/consensus/consensus.go</code>对外提供共识模块的方法调用。</p><p>其中最核心也是每个算法必须实现的接口是<code>Consenter</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ExecutionConsumer <span class="keyword">interface</span> &#123;</span><br><span class="line">Executed(tag <span class="keyword">interface</span>&#123;&#125;)                                </span><br><span class="line">Committed(tag <span class="keyword">interface</span>&#123;&#125;, target *pb.BlockchainInfo)    </span><br><span class="line">RolledBack(tag <span class="keyword">interface</span>&#123;&#125;)                              </span><br><span class="line">StateUpdated(tag <span class="keyword">interface</span>&#123;&#125;, target *pb.BlockchainInfo)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Consenter <span class="keyword">interface</span> &#123;</span><br><span class="line">RecvMsg(msg *pb.Message, senderHandle *pb.PeerID) error</span><br><span class="line">ExecutionConsumer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接口的具体实现在<code>fabric/consensus/pbft/external.go</code>。</p><p>因为对交易的操作都是异步的，所以必须手动实现<code>Executed</code>，<code>Committed</code>，<code>RolledBack</code>，<code>StateUpdated</code>方法来监听对应动作的完成。</p><p><code>RecvMsg</code>方法用来从不用的<code>peer</code>节点接收消息。</p><h3 id="初始化共识模块"><a href="#初始化共识模块" class="headerlink" title="初始化共识模块"></a>初始化共识模块</h3><p>共识算法引擎在<code>peer</code>启动的时候初始化，初始化的具体函数如下所示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// consensus/helper/engine.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetEngine</span><span class="params">(coord peer.MessageHandlerCoordinator)</span> <span class="params">(peer.Engine, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">engineOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">engine = <span class="built_in">new</span>(EngineImpl)</span><br><span class="line">engine.helper = NewHelper(coord)</span><br><span class="line">engine.consenter = controller.NewConsenter(engine.helper)</span><br><span class="line">engine.helper.setConsenter(engine.consenter)</span><br><span class="line">engine.peerEndpoint, err = coord.GetPeerEndpoint()</span><br><span class="line">engine.consensusFan = util.NewMessageFan()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">logger.Debug(<span class="string">"Starting up message thread for consenter"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> msg := <span class="keyword">range</span> engine.consensusFan.GetOutChannel() &#123;</span><br><span class="line">engine.consenter.RecvMsg(msg.Msg, msg.Sender)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> engine, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GetEngine</code>的作用是进行共识模块的初始化，同时启动一个<code>goroutine</code>等待消息进入共识。</p><p>具体的<code>engine.consenter</code>是在<code>consensus/controller/controller.go</code>里进行选择。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// consensus/controller/controller.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConsenter</span><span class="params">(stack consensus.Stack)</span> <span class="title">consensus</span>.<span class="title">Consenter</span></span> &#123;</span><br><span class="line"></span><br><span class="line">plugin := strings.ToLower(viper.GetString(<span class="string">"peer.validator.consensus.plugin"</span>))</span><br><span class="line"><span class="keyword">if</span> plugin == <span class="string">"pbft"</span> &#123;</span><br><span class="line">logger.Infof(<span class="string">"Creating consensus plugin %s"</span>, plugin)</span><br><span class="line"><span class="keyword">return</span> pbft.GetPlugin(stack)</span><br><span class="line">&#125;</span><br><span class="line">logger.Info(<span class="string">"Creating default consensus plugin (noops)"</span>)</span><br><span class="line"><span class="keyword">return</span> noops.GetNoops(stack)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认选择的是<code>noops</code>，如果需要添加自己编写的共识模块需要在这里自行添加判断。</p><blockquote><p><code>noops</code> 只是演示如何编写Fabric共识模块，不要用在生产环境。</p></blockquote><p>如果选择了<code>PBFT</code>则会调用<code>consensus/pbft/pbft.go</code>进行初始化。</p><p>使用<code>PBFT</code>的<code>batch</code>模式启动时会调用<code>newObcBatch</code>进行<code>PBFT</code>算法初始化。</p><blockquote><p>PBFT只有<code>batch</code>一种模式。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// consensus/pbft/batch.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newObcBatch</span><span class="params">(id <span class="keyword">uint64</span>, config *viper.Viper, stack consensus.Stack)</span> *<span class="title">obcBatch</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    op.manager = events.NewManagerImpl()</span><br><span class="line">op.manager.SetReceiver(op)</span><br><span class="line">etf := events.NewTimerFactoryImpl(op.manager)</span><br><span class="line">op.pbft = newPbftCore(id, config, op, etf)</span><br><span class="line">op.manager.Start()</span><br><span class="line">blockchainInfoBlob := stack.GetBlockchainInfoBlob()</span><br><span class="line">op.externalEventReceiver.manager = op.manager</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> op</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>newObcBatch</code>主要做了这几项工作</p><ul><li>初始化了<code>eventLoop</code>的消息队列。</li><li>设置了消息的接收者，用来处理对应的消息。</li><li>创建监听消息超时的定时器。</li><li>初始化<code>pbft</code>算法。</li><li>启动消息队列，不断监听事件的到来并且分发给接收者处理。</li></ul><h3 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h3><p>Fabric的共识消息是通过<code>eventLoop</code>注射给对应处理函数的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// consensus/util/events/events.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendEvent</span><span class="params">(receiver Receiver, event Event)</span></span> &#123;</span><br><span class="line">next := event</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">next = receiver.ProcessEvent(next)</span><br><span class="line"><span class="keyword">if</span> next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(em *managerImpl)</span> <span class="title">Inject</span><span class="params">(event Event)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> em.receiver != <span class="literal">nil</span> &#123;</span><br><span class="line">SendEvent(em.receiver, event)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(em *managerImpl)</span> <span class="title">eventLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> next := &lt;-em.events:</span><br><span class="line">em.Inject(next)</span><br><span class="line"><span class="keyword">case</span> &lt;-em.exit:</span><br><span class="line">logger.Debug(<span class="string">"eventLoop told to exit"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>eventLoop</code>函数不断的从<code>em.events</code>里取出事件，通过<code>Inject</code>注射给对应的接收者，注意，通过<code>SendEvent</code>注射给接收者的<code>ProcessEvent</code>方法。</p><p><code>SendEvent</code>函数实现非常有意思，如果<code>receiver.ProcessEvent</code>的返回不为<code>nil</code>则不断的调用<code>receiver.ProcessEvent</code>直到找到对应的消息处理函数，在<code>ProcessEvent</code>函数中，其余<code>case</code>均为事件处理函数，唯独<code>pbftMessage</code>依赖<code>SendEvent</code>发送消息给其余函数处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// consensus/pbft/pbft-core.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(instance *pbftCore)</span> <span class="title">ProcessEvent</span><span class="params">(e events.Event)</span> <span class="title">events</span>.<span class="title">Event</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> *pbftMessage:</span><br><span class="line"><span class="keyword">return</span> pbftMessageEvent(*et)</span><br><span class="line"><span class="keyword">case</span> pbftMessageEvent:</span><br><span class="line">msg := et</span><br><span class="line">logger.Debugf(<span class="string">"Replica %d received incoming message from %v"</span>, instance.id, msg.sender)</span><br><span class="line">next, err := instance.recvMsg(msg.msg, msg.sender)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> next</span><br><span class="line"><span class="keyword">case</span> *RequestBatch:</span><br><span class="line">err = instance.recvRequestBatch(et)</span><br><span class="line"><span class="keyword">case</span> *PrePrepare:</span><br><span class="line">err = instance.recvPrePrepare(et)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>*pbftMessage</code>和<code>pbftMessageEvent</code>这两个<code>case</code>通过<code>recvMsg</code>的返回值又把消息分发给其余<code>case</code>，非常巧妙。</p><p><code>PBFT</code>算法的不同阶段都会按着上面的流程映射到不同的处理函数往前推进，本质上是一个状态机。</p><p>至此Fabric的<code>Consensus</code>模块主要流程已经梳理清楚，熟悉了这个流程以后再结合<code>PBFT</code>算法的过程就可以很容易在此基础上添加新的功能了。</p>]]></content>
    
    <summary type="html">
    
      联盟链Hyperledger fabric共识模块源码分析
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Fabric" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Fabric/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Fabric" scheme="http://yoursite.com/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>区块链技术的应用场景</title>
    <link href="http://yoursite.com/2018/01/31/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://yoursite.com/2018/01/31/区块链技术的应用场景/</id>
    <published>2018-01-31T15:54:56.000Z</published>
    <updated>2018-04-10T12:50:46.537Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;区块链的一个重要应用场景就是解决不同金融机构交易结算的成本，举个例子~在日常生活中使用微信提现会有24小时到账时间的限制，超过微信免费提现额度还会有一定的手续费，当然这都是建立在微信的支付系统和银行的交易系统正常运行的前提下。</p><a id="more"></a><p>&emsp;&emsp;通过这个例子我们发现了两个问题，提现需要24小时到账，交易过程产生了手续费。</p><p>&emsp;&emsp;将这个例子延伸到跨国，不同组织，对交易实时性要求高的场景下，上面的问题就会更为突出，例如将微信里提现到支付宝，因为微信和支付宝的支付网络不通，必须经过银行等第三方网络(微信和支付宝都信任的支付网络)的流转支持，也就是先由微信转账到银行在转到支付宝。</p><h3 id="交易过程"><a href="#交易过程" class="headerlink" title="交易过程"></a>交易过程</h3><p>&emsp;&emsp;先假定有一枚数字货币，货币的拥有者将货币加上自己的签名与时间戳，向全网广播交易给另一个地址，给向全世界都宣布了这个交易过程，等区块确认交易就成功了 :-D</p><p>&emsp;&emsp;这个交易过程是建立在使用同一个网络的前提下的，如果不同网络那就如同鸡同鸭讲，你的广播对方无法理解所以宣布的交易没有任何意义，如果要转换成对方所能理解的信息自然又得费一番功夫。</p><p>&emsp;&emsp;通过上面的交易过程可以发现因为使用了同一个网络从而避免了交易在不同网络之间交易的成本，避免了不同网络之间因为结算速度，结算方式带来的时间成本。</p><h3 id="信任问题"><a href="#信任问题" class="headerlink" title="信任问题"></a>信任问题</h3><p>&emsp;&emsp;在网购中，买方和卖方表现在不同的平台上可能是一个淘宝账号，可能是一个微信或者是其他的媒介，双方都没有任何的信任基础，你不会先把钱给对方，对方也不可能先给货物，这个时候你们可以找一个双方都信任的平台作为担保，比如淘宝，或者可以查看对方的交易记录，身份凭证来增加你的信任来进行直接交易，但是会有欺诈的风险，因为身份信息可能是伪造的。</p><p>&emsp;&emsp;可以看到第一种方式是中心化的，找到了双方都认可的作为担保。第二种方式则是去中心化的，但是有很高的欺诈风险，显然第一种方式是一种更好的选择。</p><p>&emsp;&emsp;这也就很好的解释了为什么支付宝的支付网络不和微信的支付网络直连，而是要通过第三方的银行来实现结算，银行是以国家信用作为背书的，是双方都可以信赖的。只是列举出支付宝和微信举例，整个网络中的大大小小的网络数不胜数，如果是第二种方式进行交易，整个信任问题简直爆炸。</p><h3 id="区块链原理"><a href="#区块链原理" class="headerlink" title="区块链原理"></a>区块链原理</h3><p>&emsp;&emsp;微信和支付宝的支付网络账本都是私有的，不可能给对方查看，如果微信转账给支付宝而支付宝抵赖说没有收到钱，这个时候微信掏出自己的账本说我确实转了钱，显然单方面的账本没有任何说服力，归根到底还是信任问题。</p><p>&emsp;&emsp;区块链采用分布式账本来解决这个问题，所有的人都在同一个账本记账，所有的交易记录都是可以追溯的，所有的账目都是透明的，每个人都可以保存一个账本的副本，如果出现了上面抵赖的问题大家都知道了这个转账存在过，即使微信抵赖但是绝大部分人都不承认，微信抵赖就是无效的。同时也解决了单一节点失效导致交易不可用的情况，例如微信的账本突然丢失但是其他节点存在非常多个副本，只需要同步一下账本就又可以恢复账户信息了。</p><p>&emsp;&emsp;这个时候就又会产生一个问题，大家的账本都共用一个，我有多少钱我和谁交易大家都知道了，这不是很尴尬，存个私房钱老婆都知道了还存个***啊 :-D</p><p>&emsp;&emsp;到目前为止，我们的区块链网络已经解决了信任问题（依靠大部分人的共识），现在需要解决的问题是如何保证隐私~</p><p>&emsp;&emsp;在区块链网络中的交易主体，如微信，支付宝这些名字带来的信用背书已经没有任何意义，在缺乏信任的环境中我不可能转账给一只猫，一只狗，因为我不知道我转账过去是否能获得我想要的东西，但是在区块链中所有主体的信用背书都是一样的，所以可以将主体抽象成任何东西，在区块链中是一串数字和字符的序列，并且这些东西和主体不是一一对应的，甚至可以一笔交易生成一个匿名序列，这样你知道发生了什么交易，交易是否可行（余额是否够）但是并不知道是交易属于谁。</p><p>&emsp;&emsp;最后我们回顾开始的问题，转账速度和手续费似乎并没有解决~只是把问题都转移到了区块链技术本身，以比特币为代表的第一代区块链为人所诟病的交易确认慢，高昂的手续费仍然存在，但是随着区块链技术的进步比如瑞波网络，Hyperledger（超级账本）等技术的发展已经很大程度上解决了以上问题，在Hyperledger v0.61中已经可以每秒处理1000多笔交易，随着技术的发展区块链交易处理速度还将大幅提高，制约区块链使用的难题逐渐解决以后区块链技术必将再次迎来一波发展。</p>]]></content>
    
    <summary type="html">
    
      区块链应用场景讨论
    
    </summary>
    
      <category term="Blockchain" scheme="http://yoursite.com/categories/Blockchain/"/>
    
      <category term="区块链" scheme="http://yoursite.com/categories/Blockchain/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Blockchain" scheme="http://yoursite.com/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>2017小结</title>
    <link href="http://yoursite.com/2017/12/30/2017%E5%B9%B4%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2017/12/30/2017年小结/</id>
    <published>2017-12-30T12:39:02.000Z</published>
    <updated>2017-12-31T14:14:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;之前没有如此强烈的想写年终的总结的冲动，但是今年经历了太多的事情，不如就此回顾一下2017在展望一下2018吧。</p><a id="more"></a><h2 id="毕业"><a href="#毕业" class="headerlink" title="毕业"></a>毕业</h2><p>&emsp;&emsp;今年六月终于从广东某不知名的一所学校毕业了，说终于倒不是因为不喜欢读书，大学四年的时间真是我这么多年来度过的最开心快乐充实的时光，现在看到朋友圈的师弟师妹发在学校的生活还不经回想起当年的时光，泡在实验室或者是图书馆搞自己喜欢的东西，顺带着晚上跑个外环，简直开心的不行。</p><p>&emsp;&emsp;至于学校的那些课程么~自然是划划水了，其实现在工作以后觉得还是有几门课需要认真学的，毕竟以后用的着而且还蛮有意思的，只不过当时觉得一帮念PPT的教不出个所以然来。</p><p>&emsp;&emsp;毕业也还顺利，拿到手一看读了四年是一个管理学学位，不过也蛮有意思的，高中文科生，大学管理学学士，毕业去搞计算机啦，按我老爸的话说就是能折腾，年轻。从读书到实习都能折腾，实习的折腾后面在说吧，先聊毕业的事。</p><p>&emsp;&emsp;拍毕业照的时候也没什么值得留恋的东西，就和班里人集体例行公事的拍了一下，中间的时间都拉着佳婷拍了，和佳婷坐湖边好好聊了一会，也错过了几次集体的合照，本来也无所谓，我这人在班上也没有什么存在感，照片里少了也没几个人会注意到的，和佳婷聊聊人生谈谈理想，虽然追了挺久也没追到但是这事就翻篇了，大学也就这么糊弄过去了。</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>&emsp;&emsp;先说实习吧，实习这事跨度太大，16年到17年，大三的时候去阿里音乐见识了见识外面的世界，学到了点人生经验，当然也得写写代码换点钱花花，学到了不少开阔了眼界，知道了外面的公司前端是怎么开发的流程是什么样的，当然也暴露了测试的时候没见过那么多的不同牌子的手机，自然测试完我都是要借来摸一遍的。</p><p>&emsp;&emsp;大四的时候闲来无事就又跑去UC实习了，第一次感受到了被切图支配的恐惧（笑:-D) ~  RED部门里设计为主，前端的主要工作就把设计用CSS高度还原以后分装成模块在给另一个前端组实习交互逻辑，当然说的专业点就是前端重构工程师了，大厂流程很规范加班也不少，只是觉得有点枯燥大多都是流程化的操作，一两遍还行你要说天天搞这个我也是不开心，踏实做也能做出点东西，可是还是不太喜欢就跑路喽。</p><p>&emsp;&emsp;后来就这么奇奇怪怪的在年初的时候来了北京，当时是投的Node.Js来的SenseTime，结果来了以后转型后端工程师写起了ruby，等适应以后觉得ruby还是蛮有意思，给社区翻译了一些文档，还试着把Libuv移植到Ruby写一个web服务器结合了一些Puma的代码，自娱自乐倒也很是开心。</p><p><img src="https://raw.githubusercontent.com/Ice-Storm/ice-storm.github.io/master/images/2017review/WechatIMG43.jpeg" alt=""></p><p>&emsp;&emsp;转正以后就慢慢参与公有云管理后台的开发，同事离职以后就全部负责起了这个项目，第一次维护开发一个逻辑很复杂的项目自然是非常开心，学到了不少东西也让我见识真正上线服务很多客户的云是怎么回事，整个管理后台不算前端大概两三万行rails的代码逻辑非常的复杂，集成了各种子系统真是Debug到飞起，现在玩的比较溜以后又可以研究研究其他好玩的东西啦。</p><p>&emsp;&emsp;其他的就是看看ML啊，学习学习计算机组成，折腾一下Golang，玩玩docker，rancher什么的乐在其中。</p><h3 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h3><p>&emsp;&emsp;说旅行有点牵强，但又实实在在的去了很多的地方，湛江，广州，酒泉，北京，天津，苏州，杭州还有一些记不得地方了，去这些地方多多少少都带着点目的，不是单单纯纯的去玩，除去回酒泉也就是家的那次吧。<br>&emsp;&emsp;飘的地方多了反而想安稳一点了，在苏州的女票又总是抱怨我居无定所，算不上流浪法师但至少是够得上流浪码农了，<code>如果有大佬看到这公司在江浙一带又恰好缺一个写代码的，或者需要一个只存在在线上的码农不妨联系我</code>。</p><p><img src="https://raw.githubusercontent.com/Ice-Storm/ice-storm.github.io/master/images/2017review/WechatIMG46.jpeg" alt=""><br><img src="https://raw.githubusercontent.com/Ice-Storm/ice-storm.github.io/master/images/2017review/WechatIMG44.jpeg" alt=""><br><img src="https://raw.githubusercontent.com/Ice-Storm/ice-storm.github.io/master/images/2017review/WechatIMG45.jpeg" alt=""></p><p><img src="https://raw.githubusercontent.com/Ice-Storm/ice-storm.github.io/master/images/2017review/WechatIMG47.jpeg" alt=""><br><img src="https://raw.githubusercontent.com/Ice-Storm/ice-storm.github.io/master/images/2017review/WechatIMG48.jpeg" alt=""></p><h3 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h3><p>砥砺前行~</p><ul><li>深入学习一下Go语言，并且在项目里实践</li><li>Docker，Rancher深入学习</li><li>把Github的坑填完</li><li>初探ML，毕竟公司有大神指导 :-D</li><li>明确一下以后发展的方向，技术和生活两方面</li><li>把叶叶拐回家让父母认识认识这个小呆子</li><li>尤克里里在溜一点，生活气在多一点，就这样吧~</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;之前没有如此强烈的想写年终的总结的冲动，但是今年经历了太多的事情，不如就此回顾一下2017在展望一下2018吧。&lt;/p&gt;
    
    </summary>
    
      <category term="review2017" scheme="http://yoursite.com/categories/review2017/"/>
    
    
      <category term="review2017" scheme="http://yoursite.com/tags/review2017/"/>
    
  </entry>
  
  <entry>
    <title>浅析Node的nextTick</title>
    <link href="http://yoursite.com/2017/07/22/%E6%B5%85%E6%9E%90Node%E7%9A%84nextTick/"/>
    <id>http://yoursite.com/2017/07/22/浅析Node的nextTick/</id>
    <published>2017-07-22T06:48:29.000Z</published>
    <updated>2017-07-22T12:52:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>看thinkjs源码的时候发现下面这段代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cluster.on(<span class="string">'exit'</span>, worker =&gt; &#123;</span><br><span class="line">  think.log(<span class="keyword">new</span> <span class="built_in">Error</span>(think.locale(<span class="string">'WORKER_DIED'</span>, worker.process.pid)), <span class="string">'THINK'</span>);</span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> cluster.fork());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>  这段代码的意思很简单，就是cluster挂了以后重新fork一个。<br>  但是注意到其中的<code>process.nextTick(() =&gt; cluster.fork());</code>这行，刚开始想了一下没有理解为什么不直接<code>fork</code>，后面仔细想了一下，发现如果直接<code>fork</code>，在<code>fork</code>的过程中又出现错误导致进程退出，而<code>cluster</code>又监听到<code>exit</code>的事件，就会不断的重复这个过程，阻塞Node进程。<br>  如果使用<code>process.nextTick(() =&gt; cluster.fork());</code>则不会阻塞Node的事件循环，只会在<code>Event Loop</code>的<code>close callbacks</code>阶段执行<code>fork</code>，即使程序一直<code>fork</code>失败也不会导致程序假死。(如果有疑问可以阅读文章末的扩展阅读)。<br>  下面的Demo说明了为什么使用了<code>nextTick</code>不会导致程序假死。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter; </span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">event.on(<span class="string">'some_event'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  count++;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'some_event 事件触发'</span> + count);</span><br><span class="line">  <span class="keyword">if</span> (count &lt; num) &#123;</span><br><span class="line">    event.emit(<span class="string">'some_event'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">event.emit(<span class="string">'some_event'</span>); </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'what ?'</span>)</span><br></pre></td></tr></table></figure></p><p>运行这段代码就会输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">some_event 事件触发1</span><br><span class="line">some_event 事件触发2</span><br><span class="line">some_event 事件触发3</span><br><span class="line">some_event 事件触发4</span><br><span class="line">some_event 事件触发5</span><br><span class="line">some_event 事件触发6</span><br><span class="line">some_event 事件触发7</span><br><span class="line">some_event 事件触发8</span><br><span class="line">some_event 事件触发9</span><br><span class="line">some_event 事件触发10</span><br><span class="line">what ?</span><br></pre></td></tr></table></figure></p><p>  可以发现 <code>what ?</code> 在最后才输出。如果把num设置的非常大就会报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">internal/process/next_tick.js:148</span><br><span class="line">    nextTickQueue.push(&#123;</span><br><span class="line">                 ^</span><br><span class="line">RangeError: Maximum call stack size exceeded</span><br></pre></td></tr></table></figure></p><p>  V8不断的向事件队列里添加任务，最终导致出现溢出，把<code>event.emit(&#39;some_event&#39;)</code>改写成<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  event.emit(<span class="string">'some_event'</span>) </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>  就会发现输出成了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ome_event 事件触发1</span><br><span class="line">what ?</span><br><span class="line">some_event 事件触发2</span><br><span class="line">some_event 事件触发3</span><br><span class="line">some_event 事件触发4</span><br><span class="line">some_event 事件触发5</span><br><span class="line">some_event 事件触发6</span><br><span class="line">some_event 事件触发7</span><br><span class="line">some_event 事件触发8</span><br><span class="line">some_event 事件触发9</span><br><span class="line">some_event 事件触发10</span><br></pre></td></tr></table></figure></p><p>  <code>what ?</code>并不会被阻塞，而且无论<code>num</code>改成多少，都不会出现栈溢出的错误。<br>  Node的<code>Event loop</code>执行流程如图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">|      nextTick（队列执行）</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">|       nextTick（队列执行）</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      </span><br><span class="line">|      nextTick（队列执行）         ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;─────┤  connections, │</span><br><span class="line">│  └──────────┬────────────┘      |               |</span><br><span class="line">|      nextTick（队列执行）         │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">|       nextTick（队列执行）</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure></p><p>  直接<code>event.emit(&#39;some_event&#39;)</code>的时候，Node不断的把收集到的事件塞到<code>I/O callbacks</code>这个队列，如果有大量的事件塞入就会最终导致溢出，就是上面的<code>Maximum call stack size exceeded</code>错误。<br>  如果加了<code>process.nextTick</code>则会不断的把<code>emit</code>的事件回调加到<code>nextTickQueue</code>队列，在各个主队列切换的时候执行，见上图的 <code>nextTick（队列执行）</code>。上面的那段Demo把<code>event.emit(&#39;some_event&#39;)</code>修改后的执行顺序就是<br>  1、发送事件<br>  2、把事件回调函数添加到<code>nextTickQueue</code>(注意，这个时候<code>nextTickQueue</code>队列里只有一个事件回调函数，如果当前队列尚未执行完毕并且没有发生切换，则<code>nextTickQueue</code>队列里的事件永远不会执行)<br>  3、执行<code>nextTickQueue</code>里的第一个事件回调(当前队列执行完毕或者执行到一定数量发生切换时，事件回调又会重新创建一个新的<code>nextTickQueue</code>队列并添加一个事件回调)<br>  4、然后同上<br>  这样就没有阻塞Node的事件循环，无论num多大都不会撑爆<code>I/O callbacks</code>队列。其实最核心的思想就是将任务拆解到若干次事件循环中，逐步执行。</p><p>扩展阅读<br>  <a href="https://github.com/creeperyang/blog/issues/26" target="_blank" rel="noopener">Node.js的event loop及timer/setImmediate/nextTick</a><br>  <a href="http://www.cnblogs.com/bingooo/p/6720540.html" target="_blank" rel="noopener">Node.js 原理简介</a><br>  <a href="https://yjhjstz.gitbooks.io/deep-into-node/content/" target="_blank" rel="noopener">深入理解Node.js：核心思想与源码分析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看thinkjs源码的时候发现下面这段代码。&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cluster.on(&lt;span class=&quot;string&quot;&gt;&#39;exit&#39;&lt;/span&gt;, worker =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  think.log(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Error&lt;/span&gt;(think.locale(&lt;span class=&quot;string&quot;&gt;&#39;WORKER_DIED&#39;&lt;/span&gt;, worker.process.pid)), &lt;span class=&quot;string&quot;&gt;&#39;THINK&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  process.nextTick(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; cluster.fork());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Node" scheme="http://yoursite.com/categories/Node/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/Node/JavaScript/"/>
    
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Sinatra扩展机制</title>
    <link href="http://yoursite.com/2017/07/22/Sinatra%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2017/07/22/Sinatra扩展机制/</id>
    <published>2017-07-21T16:43:19.000Z</published>
    <updated>2017-07-22T12:38:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Sinatra通过<code>helpers</code>和<code>register</code>函数进行扩展<br>首先看一下<code>helpers</code>函数，用来是来扩展Base类的实例方法。</p><a id="more"></a><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helpers</span><span class="params">(*extensions, &amp;block)</span></span></span><br><span class="line">  class_eval(&amp;block)   <span class="keyword">if</span> block_given?</span><br><span class="line">  <span class="keyword">include</span>(*extensions) <span class="keyword">if</span> extensions.any?</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在看一下<code>register</code>函数,用来扩展Base类的类方法<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(*extensions, &amp;block)</span></span></span><br><span class="line">  extensions &lt;&lt; Module.new(&amp;block) <span class="keyword">if</span> block_given?</span><br><span class="line">  @extensions += extensions</span><br><span class="line">  extensions.each <span class="keyword">do</span> <span class="params">|extension|</span></span><br><span class="line">    extend extension</span><br><span class="line">    extension.registered(<span class="keyword">self</span>) <span class="keyword">if</span> extension.respond_to?(<span class="symbol">:registered</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>两个方法都支持通过代码块扩展，也支持通过Module来扩展。</p><p>两种扩展方法对应Sinatra的两种编程风格。</p><p>Sinatra编程的两种风格:</p><p>经典风格:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span><span class="string">'sinatra'</span></span><br><span class="line"></span><br><span class="line">get <span class="string">'/'</span> <span class="keyword">do</span></span><br><span class="line">  <span class="string">"hello world"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>模块化风格:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span><span class="string">'sinatra/base'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> &lt; Sinatra::Base</span></span><br><span class="line"></span><br><span class="line">  get <span class="string">"/"</span> <span class="keyword">do</span></span><br><span class="line">    <span class="string">"hello world"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  run!</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>为两种风格编写扩展:</p><p>Sinatra扩展也分为两种:</p><p>helper 型<br>dsl 型</p><p>helper型:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'sinatra/base'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Sinatra</span></span></span><br><span class="line">  <span class="class"><span class="keyword">module</span> <span class="title">FormatHelper</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">escape_html</span><span class="params">(text)</span></span></span><br><span class="line">      Rack::Utils.escape_html(text)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  helpers FormatHelper </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>classic style 使用extension</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'sinatra'</span></span><br><span class="line"></span><br><span class="line">get <span class="string">'/'</span> <span class="keyword">do</span></span><br><span class="line">  escape_html(<span class="string">"x &gt; y"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>modular style 使用extension</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'sinatra/base'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> &lt; Sinatra::Base</span></span><br><span class="line"></span><br><span class="line">  helpers Sinatra::FormatHelper</span><br><span class="line"></span><br><span class="line">  get <span class="string">'/'</span> <span class="keyword">do</span></span><br><span class="line">    escape_html(<span class="string">"x &gt; y"</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  run!</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里的<code>helpers</code>其实相当于<code>include</code></p><p>dsl型:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'sinatra/base'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Sinatra</span></span></span><br><span class="line">  <span class="class"><span class="keyword">module</span> <span class="title">Devise</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">authenticate!</span></span></span><br><span class="line">      before &#123;</span><br><span class="line">        halt <span class="number">403</span>, <span class="string">"You Bastards!"</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  register Devise</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>classic style 使用 dsl extension</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'sinatra'</span></span><br><span class="line"></span><br><span class="line">authenticate!</span><br><span class="line"></span><br><span class="line">get <span class="string">'/'</span> <span class="keyword">do</span></span><br><span class="line">  escape_html(<span class="string">"x &gt; y"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>modular style 使用 dsl extension</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'sinatra/base'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> &lt; Sinatra::Base</span></span><br><span class="line">  register Sinatra::Devise</span><br><span class="line"></span><br><span class="line">  authenticate!</span><br><span class="line"></span><br><span class="line">  get <span class="string">'/'</span> <span class="keyword">do</span></span><br><span class="line">    <span class="string">"hello world"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  run!</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上面就是两种扩展的用法，我们在深入一点</p><p>在<code>Sinatra/main</code>的最后几行可以看到<code>extend Sinatra::Delegator</code>，其实当 <code>require &#39;sinatra&#39;</code>的时候就是执行的上面那行代码，作为整个Sinatra的入口。</p><p>看一下<code>Delegator</code>模块,默认的target是<code>Application</code>,也就是<code>helpers</code>和<code>register</code>等Sinatra的一干关键字<code>get post ...</code>等都是通过动态派发给<code>Application</code>类执行的。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Delegator</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">delegate</span><span class="params">(*methods)</span></span></span><br><span class="line">    methods.each <span class="keyword">do</span> <span class="params">|method_name|</span></span><br><span class="line">      define_method(method_name) <span class="keyword">do</span> <span class="params">|*args, &amp;block|</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>(*args, &amp;block) <span class="keyword">if</span> respond_to? method_name</span><br><span class="line">        Delegator.target.send(method_name, *args, &amp;block)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      private method_name</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  delegate <span class="symbol">:get</span>, <span class="symbol">:patch</span>, <span class="symbol">:put</span>, <span class="symbol">:post</span>, <span class="symbol">:delete</span>, <span class="symbol">:head</span>, <span class="symbol">:options</span>, <span class="symbol">:link</span>, <span class="symbol">:unlink</span>,</span><br><span class="line">           <span class="symbol">:template</span>, <span class="symbol">:layout</span>, <span class="symbol">:before</span>, <span class="symbol">:after</span>, <span class="symbol">:error</span>, <span class="symbol">:not_found</span>, <span class="symbol">:configure</span>,</span><br><span class="line">           <span class="symbol">:set</span>, <span class="symbol">:mime_type</span>, <span class="symbol">:enable</span>, <span class="symbol">:disable</span>, <span class="symbol">:use</span>, <span class="symbol">:development?</span>, <span class="symbol">:test?</span>,</span><br><span class="line">           <span class="symbol">:production?</span>, <span class="symbol">:helpers</span>, <span class="symbol">:settings</span>, <span class="symbol">:register</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> &lt;&lt; self</span></span><br><span class="line">    <span class="keyword">attr_accessor</span> <span class="symbol">:target</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">self</span>.target = Application</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><code>Delegator</code>模块功能就是定义派发给<code>Application</code>的函数（不管实现，只是转发）</p><p>整个通过<code>Delegator.delegate</code>注册的方法的实现都在<code>Helper</code>这个模块里，在<code>Base</code>类里<code>include</code>各种方法的实现，然后<code>Application</code>在继承<code>Base</code>,有点绕~。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line">  <span class="keyword">include</span> Rack::Utils</span><br><span class="line">  <span class="keyword">include</span> Helpers</span><br><span class="line">  <span class="keyword">include</span> Templates</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>通过一张图理清楚他们的关系</p><p><img src="https://l.ruby-china.org/photo/2017/767a092d-c6a4-43df-aee0-c20109525e34.jpeg!large" alt=""></p><p>定义自己的关键字，像<code>get post</code>这样。</p><p>扩展方法首先在<code>Delegator</code>模块调用<code>delegate</code>方法的时候添加你扩展的关键字名称，类似<code>delegate :get, :patch, ... , :my_fun</code>, 然后在<code>Helper</code>模块里定义<code>my_fun</code>的实现<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Helpers</span></span></span><br><span class="line">  my_fun</span><br><span class="line">    p <span class="string">"my_fun"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>这样就可以像关键字一样使用my_fun了，当然也可以通过上面介绍的两个方法进行扩展。</p><p>参考  <a href="http://saito.im/note/Sinatra-Extensions/" target="_blank" rel="noopener">http://saito.im/note/Sinatra-Extensions/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Sinatra通过&lt;code&gt;helpers&lt;/code&gt;和&lt;code&gt;register&lt;/code&gt;函数进行扩展&lt;br&gt;首先看一下&lt;code&gt;helpers&lt;/code&gt;函数，用来是来扩展Base类的实例方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Ruby" scheme="http://yoursite.com/categories/Ruby/"/>
    
      <category term="Sinatra" scheme="http://yoursite.com/categories/Ruby/Sinatra/"/>
    
    
      <category term="Ruby" scheme="http://yoursite.com/tags/Ruby/"/>
    
      <category term="Sinatra" scheme="http://yoursite.com/tags/Sinatra/"/>
    
  </entry>
  
</feed>
