<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 以太坊RLP编码 · Qin Yuan's blog</title><meta name="description" content="以太坊RLP编码 - Qin Yuan"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="qyuan.top/atom.xml" title="Qin Yuan's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"><span style="font-size: 20px;margin-left: 20px;margin-top: -46px;display: inline-block;vertical-align: middle;">清源的博客~</span></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">文章</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">关于我</a></li><li class="nav-list-item"><a href="https://github.com/Ice-Storm" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">以太坊RLP编码</h1><div class="post-info"></div><div style="font-size:14px;color:#aaa;">Author: <span style="display:inline-block;margin-left:10px">Qin Yuan</span></div><div style="font-size:14px;color:#aaa;"><span>Date: <span style="display:inline-block;margin-left:21px">May 20, 2019</span></span><div>Tag:<span style="display:inline-block;margin-left:21px"></span><a href="/tags/区块链" class="post-title-link"><span style="margin-left:10px;color:blue">区块链</span></a><a href="/tags/以太坊" class="post-title-link"><span style="margin-left:10px;color:blue">以太坊</span></a></div></div><div class="post-content"><p>&emsp;&emsp;<code>RLP（Recursive Length Prefix）</code>递归长度前缀编码，<code>RLP</code>主要用于以太坊中数据的网络传输和持久化存储。</p>
<a id="more"></a>
<h3 id="为什么需要RLP编码"><a href="#为什么需要RLP编码" class="headerlink" title="为什么需要RLP编码"></a>为什么需要<code>RLP</code>编码</h3><p>&emsp;&emsp;比较常见的序列化方法有<code>JSON</code>，<code>ProtoBuf</code>，但是这些序列化方法在以太坊这样的场景下都有一些问题。</p>
<p>&emsp;&emsp;比如像<code>Json</code>编码，编码后的体积比较大。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Persion <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">uint</span> </span><br><span class="line">&#125;</span><br><span class="line">    p := &amp;Persion&#123;Name: <span class="string">"Tom"</span>, Age: <span class="number">22</span>&#125;</span><br><span class="line">    data, _ := json.Marshal(p)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line"><span class="comment">//  &#123;"Name":"Tom","Age":22&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;从编码后的结果可以看到，其实我们需要的数据是<code>Name</code>, <code>Tom</code>, <code>Age</code>, <code>22</code>，其余的括号和引号都是描述这种格式的，也就是冗余数据。<br>&emsp;&emsp;当然，会有人说可以用<code>protoBuf</code>这样的二进制格式，但是例如<code>JavaScript</code>这样的弱类型语言，是没有<code>int</code>类型的，所有数字都是用<code>Number</code>类型，底层用浮点数来实现，这样就会导致因为语言的不同编码后的数据有一定差异，最后得到的hash值也不同。<br>&emsp;&emsp;针对这些问题，以太坊设计了<code>RLP</code>编码，同时也大幅简化了编码规则。</p>
<h3 id="RLP编码定义"><a href="#RLP编码定义" class="headerlink" title="RLP编码定义"></a><code>RLP</code>编码定义</h3><p><code>RLP</code>简化了编码的类型，只定义了两种类型编码：</p>
<ul>
<li>byte数组</li>
<li>byte数组的数组，也就是列表</li>
</ul>
<h3 id="RLP编码基于上面两种数据类型提出了5条编码规则"><a href="#RLP编码基于上面两种数据类型提出了5条编码规则" class="headerlink" title="RLP编码基于上面两种数据类型提出了5条编码规则;"></a><code>RLP</code>编码基于上面两种数据类型提出了5条编码规则;</h3><h5 id="规则一"><a href="#规则一" class="headerlink" title="规则一"></a>规则一</h5><p>&emsp;&emsp;对于值在[0, 127]之间的单个字节，其编码是其本身；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a的编码是97</span><br></pre></td></tr></table></figure></p>
<h5 id="规则二"><a href="#规则二" class="headerlink" title="规则二"></a>规则二</h5><p>&emsp;&emsp;如果byte数组的长度<code>l&lt;=55</code>，编码的结果是数组本身，再加上<code>128+l</code>作为前缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">空字符串的编码是`128`，即 `128=128+0`</span><br><span class="line">`abc`的编码是`131 97 98 99`，其实`131=128+len(&quot;abc&quot;)`, `97 98 99`依次是`a b c`</span><br></pre></td></tr></table></figure></p>
<h5 id="规则三"><a href="#规则三" class="headerlink" title="规则三"></a>规则三</h5><p>&emsp;&emsp;如果数组长度大于<code>55</code>，编码结果第一个值是<code>183（128+55）</code>加数组长度的编码的长度，然后是数组长度本身的编码，最后是byte数组的编码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编码一个重复1024次&quot;a&quot;的字符串，其结果是`185 4 0 97 97 97 ...`</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;1024按照<code>大端编码</code>是<code>0000 0000 001</code>转换为十进制是<code>0 0 4 0</code>，省略前面的<code>0</code>,长度为2， 因此<code>185 = 183 + 2</code></p>
<h5 id="规则四"><a href="#规则四" class="headerlink" title="规则四"></a>规则四</h5><p>&emsp;&emsp;如果列表长度小于55，编码结果第一位是192加列表长度的编码的长度，然后依次连接各个子列表的编码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`[&quot;abc&quot;, &quot;def&quot;]`的编码结果是`200 131 97 98 99 131 100 101 102`</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;其中<code>abc</code>的编码是<code>131 97 98 99</code>, <code>131 = 128 + l</code>长度是4，<code>def</code>的编码是<code>131 100 101 102</code>，长度是4，总长度为<code>8</code>，编码结果的第一位<code>200 = 192 + 8</code></p>
<h5 id="规则五"><a href="#规则五" class="headerlink" title="规则五"></a>规则五</h5><p>&emsp;&emsp;如果列表的长度超过55，编码结果第一位是<code>247(192 + 55)</code>加列表长度的编码长度，然后是列表本身的编码，最后依次连接子列表的编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;The length of this sentence is more than 55 bytes, &quot;, &quot;I know it because I pre-designed it&quot;]</span><br></pre></td></tr></table></figure></p>
<p>的编码结果是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">248 88 179 84 104 101 32 108 101 110 103 116 104 32 111 102 32 116 104 105 115 32 115 101 110116 101 110 99 101 32 105 115 32 109 111 114 101 32 116 104 97 110 32 53 53 32 98 121 116 101115 44 32 163 73 32 107 110 111 119 32 105 116 32 98 101 99 97 117 115 101 32 73 32 112 114101 45 100 101 115 105 103 110 101 100 32 105 116</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其中前两个字节的计算方式如下：</p>
<ul>
<li><p><code>248 = 247 + 1</code></p>
</li>
<li><p><code>88 = 86 + 2</code>， 在规则3的示例中，长度为86，而在此例中，由于有两个子字符串，每个子字符串本身的长度的编码各占1字节，因此总共占2字节。</p>
</li>
<li><p>第3个字节<code>179</code>依据规则2得出</p>
</li>
</ul>
<p>第55个字节<code>163</code>同样依据规则2得出<code>163=128+35</code></p>
<blockquote>
<p>其中<code>规则三</code>，<code>规则四</code>，<code>规则5</code>是递归定义的，就是可以允许嵌套</p>
</blockquote>
</div></article></div></main><footer><div class="paginator"><a href="/2019/06/02/txpool/" class="prev">上一篇</a><a href="/2019/04/30/BloomFilter/" class="next">下一篇</a></div><div class="copyright"><div><h4>Friends</h4><a href="https://www.xuanzhangjiong.top/">TopJohn's Blog</a><a href="https://dbarobin.com">Robin</a></div><p>© 2017 - 2019 <a href="qyuan.top">Qin Yuan</a> &emsp;<script src="https://s19.cnzz.com/z_stat.php?id=1263032208&amp;web_id=1263032208" language="JavaScript"></script></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>