<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="6A32DaUP6x"><meta name="sogou_site_verification" content="MPOhwuqxBD"><title> EVM深度分析之数据存储(二) · Qin Yuan's blog</title><meta name="description" content="EVM深度分析之数据存储(二) - Qin Yuan"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="qyuan.top/atom.xml" title="Qin Yuan's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"><span style="font-size: 20px;margin-left: 20px;margin-top: -46px;display: inline-block;vertical-align: middle;">清源的博客~</span></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">文章</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">关于我</a></li><li class="nav-list-item"><a href="https://github.com/Ice-Storm" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">EVM深度分析之数据存储(二)</h1><div class="post-info"></div><div style="font-size:14px;color:#aaa;">Author: <span style="display:inline-block;margin-left:10px">Qin Yuan</span></div><div style="font-size:14px;color:#aaa;"><span>Date: <span style="display:inline-block;margin-left:21px">Sep 24, 2019</span></span><div>Tag:<span style="display:inline-block;margin-left:21px"></span><a href="/tags/区块链" class="post-title-link"><span style="margin-left:10px;color:blue">区块链</span></a><a href="/tags/以太坊" class="post-title-link"><span style="margin-left:10px;color:blue">以太坊</span></a></div></div><div class="post-content"><p>&emsp;&emsp;<a href="http://qyuan.top/2019/09/12/evm/">EVM深度分析之数据存储（一）</a>介绍了EVM中不同的数据存储位置的特点，但是并没有对应到具体的存储位置，这篇文章对Storage中的数据是如何被EVM存储做了简要的分析。</p>
<a id="more"></a>
<h3 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h3><p>&emsp;&emsp;Storage初始化的时候是空白的，默认是0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">pragma solidity ^0.5.1;</div><div class="line">contract C &#123;</div><div class="line">    uint256 a;</div><div class="line">    uint256 b;</div><div class="line">    uint256 c;</div><div class="line">    uint256 d;</div><div class="line">    uint256 e;</div><div class="line">    uint256 f;</div><div class="line">    function test() public &#123;</div><div class="line">      f = 0xc0fefe;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;用<code>solc --bin --asm --optimize test.sol</code>编译合约，可以看到；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">tag_5:</div><div class="line">    /* &quot;test.sol&quot;:167:175 0xc0fefe */</div><div class="line">  0xc0fefe</div><div class="line">    /* &quot;test.sol&quot;:163:164 f */</div><div class="line">  0x5</div><div class="line">    /* &quot;test.sol&quot;:163:175 f = 0xc0fefe */</div><div class="line">  sstore</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这段汇编执行的是<code>sstore(0x5, 0xc0fefe)</code>，把0xc0fefe存储到0x5这个位置，在EVM中声明变量不需要成本，EVM会在编译的时候保留位置，但是不会初始化。</p>
<blockquote>
<p>当通过指令<code>sload</code>读取一个未初始化的变量的时候， 不会报错，只会读取到零值0x0。</p>
</blockquote>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>&emsp;&emsp;结构体的初始化和变量是一样的；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">pragma solidity ^0.5.1;</div><div class="line">contract C &#123;</div><div class="line">    struct Tuple &#123;</div><div class="line">      uint256 a;</div><div class="line">      uint256 b;</div><div class="line">      uint256 c;</div><div class="line">      uint256 d;</div><div class="line">      uint256 e;</div><div class="line">      uint256 f;</div><div class="line">    &#125;</div><div class="line">    Tuple t;</div><div class="line">    function test() public &#123;</div><div class="line">      t.f = 0xC0FEFE;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;编译得到；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">tag_5:</div><div class="line">    /* &quot;test.sol&quot;:219:227 0xC0FEFE */</div><div class="line">  0xc0fefe</div><div class="line">    /* &quot;test.sol&quot;:213:216 t.f */</div><div class="line">  0x5</div><div class="line">    /* &quot;test.sol&quot;:213:227 t.f = 0xC0FEFE */</div><div class="line">  sstore</div><div class="line">    /* &quot;test.sol&quot;:182:234 function test() public &#123;... */</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;分析编译后的汇编发现结果和状态变量的行为是一致的。</p>
<h3 id="定长数组"><a href="#定长数组" class="headerlink" title="定长数组"></a>定长数组</h3><p>&emsp;&emsp;定长数组EVM很容易知道类型和长度，所以可以依次排列，就像存储状态变量一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">pragma solidity ^0.5.1;</div><div class="line">contract C &#123;</div><div class="line">    uint256[6] numbers;</div><div class="line">    function test() public &#123;</div><div class="line">      numbers[5] = 0xC0FEFE;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;编译合约，可以看到一样的汇编。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">tag_5:</div><div class="line">    /* &quot;test.sol&quot;:110:118 0xC0FEFE */</div><div class="line">  0xc0fefe</div><div class="line">    /* &quot;test.sol&quot;:105:106 5 */</div><div class="line">  0x5</div><div class="line">    /* &quot;test.sol&quot;:97:118 numbers[5] = 0xC0FEFE */</div><div class="line">  sstore</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;但是使用定长数组就会有越界的问题，EVM会在赋值的时候生成汇编检查，具体的内容在下篇合约分析中讨论。</p>
<p>&emsp;&emsp;固定大小的变量都是尽可能打包成32字节的块然后依次存储的，而一些类型是可以动态扩容的，这个时候就需要更加灵活的存储方式了，这些类型有映射（map），数组（array），字节数组（Byte arrays），字符串(string)。</p>
<h3 id="映射（map）"><a href="#映射（map）" class="headerlink" title="映射（map）"></a>映射（map）</h3><p>&emsp;&emsp;通过一个简单的合约学习map的存储方式；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">pragma solidity ^0.5.1;</div><div class="line"></div><div class="line">contract Test &#123;</div><div class="line">  mapping(uint256 =&gt; uint256) items;</div><div class="line"></div><div class="line">  function test() public &#123;</div><div class="line">      items[0x01] = 0x42;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这个合约很简单，就是创建了一个key和value都是uint256类型的map，并且在用0x01作为key存储了0x42，用<code>solc --bin --asm --optimize test.sol</code>编译合约，得到如下汇编。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">tag_5:</div><div class="line">       /* &quot;test.sol&quot;:119:123 0x01 */</div><div class="line">     0x1</div><div class="line">       /* &quot;test.sol&quot;:113:118 items */</div><div class="line">     0x0</div><div class="line">       /* &quot;test.sol&quot;:113:124 items[0x01] */</div><div class="line">     swap1</div><div class="line">     dup2</div><div class="line">     mstore</div><div class="line">     0x20</div><div class="line">     mstore</div><div class="line">       /* &quot;test.sol&quot;:127:131 0x42 */</div><div class="line">     0x42</div><div class="line">       /* &quot;test.sol&quot;:113:124 items[0x01] */</div><div class="line">     0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7d</div><div class="line">       /* &quot;test.sol&quot;:113:131 items[0x01] = 0x42 */</div><div class="line">     sstore</div><div class="line">       /* &quot;test.sol&quot;:82:136 function test() public &#123;... */</div><div class="line">     jump // out</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;分析一些这段汇编就会发现0x42并不是存储在key是0x01的位置，取而代之的是<code>0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7d</code>这样一段地址，这段地址是通过<code>keccak256( bytes32(0x01) + bytes32(0x00) )</code>计算得到的，0x01就是key，而0x00表示这个合约存储的第一个storage类型变量。<br>&emsp;&emsp;所以key的计算公式就是<code>keccak256(bytes32(key) + bytes32(position))</code></p>
<h5 id="多个映射map"><a href="#多个映射map" class="headerlink" title="多个映射map"></a>多个映射map</h5><p>&emsp;&emsp;假设我们的合约有两个map<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">pragma solidity ^0.5.1;</div><div class="line"></div><div class="line">contract Test &#123;</div><div class="line">  mapping(uint256 =&gt; uint256) itemsA;</div><div class="line">  mapping(uint256 =&gt; uint256) itemsB;</div><div class="line"></div><div class="line">  function test() public &#123;</div><div class="line">    itemsA[0xAAAA] = 0xAAAA;</div><div class="line">    itemsB[0xBBBB] = 0xBBBB;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;编译得到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">tag_5:</div><div class="line">        /* &quot;test.sol&quot;:166:172 0xAAAA */</div><div class="line">      0xaaaa</div><div class="line">        /* &quot;test.sol&quot;:149:163 itemsA[0xAAAA] */</div><div class="line">      0x839613f731613c3a2f728362760f939c8004b5d9066154aab51d6dadf74733f3</div><div class="line">        /* &quot;test.sol&quot;:149:172 itemsA[0xAAAA] = 0xAAAA */</div><div class="line">      sstore</div><div class="line">        /* &quot;test.sol&quot;:195:201 0xBBBB */</div><div class="line">      0xbbbb</div><div class="line">        /* &quot;test.sol&quot;:149:155 itemsA */</div><div class="line">      0x0</div><div class="line">        /* &quot;test.sol&quot;:178:192 itemsB[0xBBBB] */</div><div class="line">      dup2</div><div class="line">      swap1</div><div class="line">      mstore</div><div class="line">        /* &quot;test.sol&quot;:178:184 itemsB */</div><div class="line">      0x1</div><div class="line">        /* &quot;test.sol&quot;:149:163 itemsA[0xAAAA] */</div><div class="line">      0x20</div><div class="line">        /* &quot;test.sol&quot;:178:192 itemsB[0xBBBB] */</div><div class="line">      mstore</div><div class="line">      0x34cb23340a4263c995af18b23d9f53b67ff379ccaa3a91b75007b010c489d395</div><div class="line">        /* &quot;test.sol&quot;:178:201 itemsB[0xBBBB] = 0xBBBB */</div><div class="line">      sstore</div><div class="line">        /* &quot;test.sol&quot;:120:206 function test() public &#123;... */</div><div class="line">      jump // out</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;itemsA的位置是0，key是0xAAAA:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># key = 0xAAAA, position = 0</div><div class="line">keccak256(bytes32(0xAAAA) + bytes32(0))</div><div class="line">&apos;839613f731613c3a2f728362760f939c8004b5d9066154aab51d6dadf74733f3&apos;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;itemsB的位置是1，key是0xBBBB:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># key = 0xBBBB, position = 1</div><div class="line">keccak256(bytes32(0xBBBB) + bytes32(1))</div><div class="line">&apos;34cb23340a4263c995af18b23d9f53b67ff379ccaa3a91b75007b010c489d395&apos;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;用<code>solc --bin --asm --optimize test.sol</code>编译合约，得到如下汇编。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/* &quot;test.sol&quot;:166:172 0xAAAA */</div><div class="line">  0xaaaa</div><div class="line">    /* &quot;test.sol&quot;:149:163 itemsA[0xAAAA] */</div><div class="line">  0x839613f731613c3a2f728362760f939c8004b5d9066154aab51d6dadf74733f3</div><div class="line">    /* &quot;test.sol&quot;:149:172 itemsA[0xAAAA] = 0xAAAA */</div><div class="line">  sstore</div><div class="line">    /* &quot;test.sol&quot;:195:201 0xBBBB */</div><div class="line">  0xbbbb</div><div class="line">    /* &quot;test.sol&quot;:149:155 itemsA */</div><div class="line">  0x0</div><div class="line">    /* &quot;test.sol&quot;:178:192 itemsB[0xBBBB] */</div><div class="line">  dup2</div><div class="line">  swap1</div><div class="line">  mstore</div><div class="line">    /* &quot;test.sol&quot;:178:184 itemsB */</div><div class="line">  0x1</div><div class="line">    /* &quot;test.sol&quot;:149:163 itemsA[0xAAAA] */</div><div class="line">  0x20</div><div class="line">    /* &quot;test.sol&quot;:178:192 itemsB[0xBBBB] */</div><div class="line">  mstore</div><div class="line">  0x34cb23340a4263c995af18b23d9f53b67ff379ccaa3a91b75007b010c489d395</div><div class="line">    /* &quot;test.sol&quot;:178:201 itemsB[0xBBBB] = 0xBBBB */</div><div class="line">  sstore</div><div class="line">    /* &quot;test.sol&quot;:120:206 function test() public &#123;... */</div><div class="line">  jump // out</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;可以看到，存储的地址和我们推到的一样。</p>
<h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><p>&emsp;&emsp;在其他语言中，数组只是连续存储在内存中的一系列相同类型的元素，取值的时候都是采用首地址+偏移量的形式，但是在solidity中，数组是一种映射。数组在存储器中是这样存储的；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">0x290d...e563</div><div class="line">0x290d...e564</div><div class="line">0x290d...e565</div><div class="line">0x290d...e566</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;虽然看起来像是连续存储的，但实际上访问的时候是通过映射来查找的。增加了数组类型的意义在于多了一些数组的方法，便于我们更好的理解和编写代码，增加的特性有；</p>
<ul>
<li>length表示数组的长度，一共有多少元素；</li>
<li>边界检查，当读取或者写入时索引值大于length就会报错；</li>
<li>比映射更加复杂的存储打包行为；</li>
<li>当数组变小时，自动清除未使用的空间；</li>
<li>bytes和string的特殊优化让短数组（小于32字节）存储更加高效；</li>
</ul>
<p>&emsp;&emsp;编译合约<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">pragma solidity ^0.5.1;</div><div class="line">contract C &#123;</div><div class="line">    uint256[] chunks;</div><div class="line">    function test() public &#123;</div><div class="line">      chunks.push(0xAA);</div><div class="line">      chunks.push(0xBB);</div><div class="line">      chunks.push(0xCC);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;使用<code>remix</code>调试合约可以看到storage部分的存储内容；</p>
<p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/evm2/1.jpg?raw=true" width="85%" height="50%"></p>
<p>&emsp;&emsp;因为动态数组在编译期间无法知道数组的长度，提前预留存储空间，所以solidity就用<code>chunks</code>变量的位置存储了动态数组的长度，而具体的数据地址通过计算<code>keccak256(bytes32(0))</code>算得数组首地址，再加数组长度偏移量获得具体的元素。</p>
<blockquote>
<p>这里的 0 表示的是chunks变量的位置哦</p>
</blockquote>
<h3 id="动态数据打包"><a href="#动态数据打包" class="headerlink" title="动态数据打包"></a>动态数据打包</h3><p>&emsp;&emsp;数组与映射相比，有更加优化的打包行为，编译合约；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">pragma solidity ^0.5.1;</div><div class="line">contract C &#123;</div><div class="line">    uint128[] s;</div><div class="line">    function test() public &#123;</div><div class="line">        s.length = 4;</div><div class="line">        s[0] = 0xAA;</div><div class="line">        s[1] = 0xBB;</div><div class="line">        s[2] = 0xCC;</div><div class="line">        s[3] = 0xDD;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;使用<code>remix</code>调试合约可以看到storage部分的存储内容；</p>
<p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/evm2/2.jpg?raw=true" width="85%" height="50%"></p>
<p>&emsp;&emsp;可以发现4个元素并没有占据4个插槽，而只有两个，solidity一个插糟的大小是256bit，s的类型是uint128，编译器做了一个优化，对数据进行了更优化的打包策略，可以最大限度的节约Gas。</p>
<p>&emsp;&emsp;看一些各项操作所花费Gas的表格；</p>
<p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/evm2/3.png?raw=true" width="85%" height="50%"></p>
<p>&emsp;&emsp;其中数据的持久化操作<code>sstore</code>是消耗Gas最多的操作，在合适的场景下使用数组可以利用编译器优化节约大量的Gas。</p>
<h3 id="字节数组和字符串"><a href="#字节数组和字符串" class="headerlink" title="字节数组和字符串"></a>字节数组和字符串</h3><p>&emsp;&emsp;bytes和string是EVM特殊优化的类型；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">pragma solidity ^0.5.1;</div><div class="line">contract C &#123;</div><div class="line">    bytes s;</div><div class="line">    function test() public &#123;</div><div class="line">        s.push(0xAA);</div><div class="line">        s.push(0xBB);</div><div class="line">        s.push(0xCC);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;最后用remix编译得到;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">key: 0x0000000000000000000000000000000000000000000000000000000000000000</div><div class="line">value: 0xaabbcc0000000000000000000000000000000000000000000000000000000006</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;当bytes和string的长度小于31字节的时候可以这样放到一个插槽里，但是当大于31字节的时候，就采用存储动态数组的方式。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;EVM的存储器就是一个健值数据库，当改变里面的任何一点东西，根节点的校验和也会改变，如果两个根节点拥有相同的校验和，存储的数据就能保持一致。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/10/08/statedb/" class="prev">PREV</a><a href="/2019/09/12/evm/" class="next">NEXT</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><div id="gitalk-container"></div><script src="https://unpkg.com/gitalk/dist/gitalk.min.js" crossorigin="anonymous" language="JavaScript"></script><script>var gitalk = new Gitalk({
    clientID: '0dc72a011c85518eff6a',
    clientSecret: '0ae5e09dca1b971dad10c7262e669c9a82ebf3f9',
    repo: 'ice-storm.github.io',
    owner: 'ice-storm',
    admin: ['ice-storm'],
    id: location.pathname,      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
})
gitalk.render('gitalk-container')</script><div class="copyright"><div><h4>Friends</h4><a href="https://www.xuanzhangjiong.top/">TopJohn's Blog</a>&emsp;&emsp;<a href="https://dbarobin.com">Robin</a></div><p>© 2017 - 2021 <a href="qyuan.top">Qin Yuan</a> &emsp;<script src="https://s19.cnzz.com/z_stat.php?id=1263032208&amp;web_id=1263032208" language="JavaScript"></script></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>