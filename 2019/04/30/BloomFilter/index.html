<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 白话布隆过滤器（Bloom Filter） · Qin Yuan's blog</title><meta name="description" content="白话布隆过滤器（Bloom Filter） - Qin Yuan"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Qin Yuan's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"><span style="font-size: 20px;margin-left: 20px;margin-top: -46px;display: inline-block;vertical-align: middle;">清源的博客~</span></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">文章</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">关于我</a></li><li class="nav-list-item"><a href="https://github.com/Ice-Storm" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">白话布隆过滤器（Bloom Filter）</h1><div class="post-info"></div><div style="font-size:14px;color:#aaa;">Author: <span style="display:inline-block;margin-left:10px">Qin Yuan</span></div><div style="font-size:14px;color:#aaa;"><span>Date: <span style="display:inline-block;margin-left:21px">Apr 30, 2019</span></span><div>Tag:<span style="display:inline-block;margin-left:21px"></span><a href="/tags/区块链" class="post-title-link"><span style="margin-left:10px;color:blue">区块链</span></a></div></div><div class="post-content"><p>&emsp;&emsp;要判断一个元素是不是在一个集合里，比较容易想到的方法是用数组，链表这样的数据结构把元素保存起来，然后依次比较来确定。<br>&emsp;&emsp;但是随着集合的变大，上面的这种方法就面临几个问题，首先比较的速度随着数据量的增加而变慢，其次存储集合的空间也越来越大。<br>&emsp;&emsp;为了解决上面的问题，就引入了<code>布隆过滤器（Bloom Filter）</code></p>
<a id="more"></a>
<h3 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h3><p>&emsp;&emsp;布隆过滤器的原理就是当一个元素被加入到集合的时候，用<code>K</code>个<code>Hash</code>函数将元素映射到一个<code>位图</code>中的<code>K</code>个点，并且把这个点的值设置为<code>1</code>，在每次检索的时候我们看一下这个点是不是都是<code>1</code>就知道集合中有没有这个元素了。<br>&emsp;&emsp;这样说可能比较抽象，举个例子：</p>
<p>&emsp;&emsp;我们假设<code>K</code>是<code>2</code>，有<code>Hash1</code>和<code>Hash2</code>两个哈希函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hash1 = n%3</span><br><span class="line">Hash2 = n%8</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;然后我们创建一个名叫<code>bitMap</code>长度是<code>20</code>的<code>位图</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitMap=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这个时候，我们要将7，存入到这个集合中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = 7</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;分别用<code>Hash1</code>和<code>Hash2</code>计算<code>n</code>哈希后的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hash1  -&gt;  1</span><br><span class="line">Hash2  -&gt;  7</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;我们把<code>bitMap</code>对应的值置为1，从0开始<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitMap=[0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这样下次我们来查找<code>7</code>在不在这个集合的时候就可以用<code>Hash1</code>和<code>Hash2</code>计算完以后在<code>bitMap</code>集合中查找对应位置是否都是<code>1</code>，如果都是<code>1</code>则一定在集合中。</p>
<p>&emsp;&emsp;如果再在集合中插入13<br>&emsp;&emsp;分别用<code>Hash1</code>和<code>Hash2</code>计算<code>n</code>哈希后的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n = 13</span><br><span class="line">Hash1  -&gt;  1</span><br><span class="line">Hash2  -&gt;  5</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;我们把<code>bitMap</code>对应的值置为1，从0开始<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitMap=[0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这个时候我们发现<code>1</code>被映射到了两次，但是并不影响我们在集合<code>[7, 13]</code>中快速找到7或者13。</p>
<p>&emsp;&emsp;但是当插入的数据量大幅提升的时候，甚至<code>bitMap</code>全部被置为<code>1</code>的时候问题就很严重了，误识率就非常高了，这个也是根据不同场景实现布隆过滤器所要考虑的问题。</p>
<p>&emsp;&emsp;尽管有这样的问题，但是仍然不能掩盖布隆过滤器的<code>空间利用率</code>和<code>查询时间</code>远超其他算法，插入数据和查询数据的时间复杂度都是<code>O(k)</code></p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>&emsp;&emsp;比较典型的应用场景就是检查垃圾邮箱的地址，比如我建立了一个垃圾邮件的布隆过滤器，当新邮件到来的时候我要快速的判断这封邮件是不是垃圾邮件。<br>&emsp;&emsp;还可以用来判断一个URL是不是恶意链接等等。<br>&emsp;&emsp;以太坊大量的用到了布隆过滤器，用来定位查找日志等。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/05/20/rlp/" class="prev">PREV</a><a href="/2019/04/18/BucketTree/" class="next">NEXT</a></div><div class="copyright"><p>© 2017 - 2019 <a href="http://yoursite.com">Qin Yuan</a> &emsp;<script src="https://s19.cnzz.com/z_stat.php?id=1263032208&amp;web_id=1263032208" language="JavaScript"></script></p><div><h4>Fridens</h4><a href="https://www.xuanzhangjiong.top/">TopJohn's Blog</a></div></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>