<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 分布式一致性协议之Raft(三) · Qin Yuan's blog</title><meta name="description" content="分布式一致性协议之Raft(三) - Qin Yuan"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Qin Yuan's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"><span style="font-size: 20px;margin-left: 20px;margin-top: -46px;display: inline-block;vertical-align: middle;">清源的博客~</span></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">文章</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">关于我</a></li><li class="nav-list-item"><a href="https://github.com/Ice-Storm" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">分布式一致性协议之Raft(三)</h1><div class="post-info"></div><div style="font-size:14px;color:#aaa;">Author: <span style="display:inline-block;margin-left:10px">Qin Yuan</span></div><div style="font-size:14px;color:#aaa;"><span>Date: <span style="display:inline-block;margin-left:21px">Aug 3, 2019</span></span><div>Tag:<span style="display:inline-block;margin-left:21px"></span><a href="/tags/区块链" class="post-title-link"><span style="margin-left:10px;color:blue">区块链</span></a><a href="/tags/分布式" class="post-title-link"><span style="margin-left:10px;color:blue">分布式</span></a></div></div><div class="post-content"><p>&emsp;&emsp;在前两篇文章中已经介绍了<code>Raft</code>算法的正常流程和对异常的处理，但是还有一些问题没有解决，比如当集群中有新的节点加入或者退出的时候，集群又该如何保证安全的提供服务呢？</p>
<a id="more"></a>
<h3 id="增删集群节点"><a href="#增删集群节点" class="headerlink" title="增删集群节点"></a>增删集群节点</h3><p>&emsp;&emsp;最容易想到的方法就是暂停整个集群，更新配置，然后重启集群。但是问题显而易见，在更新配置期间集群是不可用的，而手工操作配置文件，而且是操作多个节点的配置文件，也会造成很大的风险。为了避免发生这些风险，<code>Raft</code>算法添加了自动化配置变更的内容。<br>&emsp;&emsp;从旧的配置直接变更到新的配置的各种方法都是不安全的，其中最大的问题就是容易出现<code>脑裂</code>集群分裂，举个例子；</p>
<p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/raft2/1.png?raw=true" width="70%" height="70%"></p>
<p>&emsp;&emsp;旧配置有 1， 2， 3号节点，<code>候选人</code>只需要两张选票就可以变为<code>领导者</code>，除了自己的一张选票，还需要等待一个节点投票给自己即可，但是当集群增加2个节点的时候，旧节点之间是无法感知有几个节点加入网络的，所以还会按照旧配置投票，即收集到两张选票就可以成为候选人。而新节点是可以感知到集群中是有5个节点的，所以新节点要成为领导者需要3张选票，必然有一个时间点，既可满足旧节点的候选人选举要求，又可满足新节点的选举要求，<code>脑裂</code>就这样发生了。</p>
<p>&emsp;&emsp;显而易见，出现<code>脑裂</code>的问题是由于同一时间新旧配置节点各自单方面的作出了选<code>领导者</code>的决定。</p>
<p>&emsp;&emsp;停集群，更新配置，重启集群其实目的就是保证了同一时间只有一种状态，为了解决集群的可用性，<code>Raft</code>采取了两段提交来保证安全的变更日志。</p>
<h4 id="配置变更流程"><a href="#配置变更流程" class="headerlink" title="配置变更流程"></a>配置变更流程</h4><p>&emsp;&emsp;首先当一个<code>领导者</code>收到一个改变配置从<code>C-old</code>到<code>C-new</code>的请求时，它会<code>merge(C-old, C-new)</code>并且保存到自己的日志中，然后复制到集群中的其他节点，在<code>C-new</code>提交之前，所有节点的决定都会基于<code>C-old,new</code>的配置做决定。<br>&emsp;&emsp;在<code>C-old, new</code>被提交以后，<code>领导者</code>创建一条<code>C-new</code>的配置复制到集群，当<code>C-new</code>被提交以后，就旧配置指定的节点就无关紧要了，在集群中不可见了，可以从集群移除。</p>
<p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/raft2/2.png?raw=true" width="70%" height="70%"></p>
<h4 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h4><h5 id="节点宕机"><a href="#节点宕机" class="headerlink" title="节点宕机"></a>节点宕机</h5><p>&emsp;&emsp;但是在这个过程中还是会有节点宕机的异常情况发生，<code>Raft</code>又是如何保证整个增删节点过程的安全性呢？<br>&emsp;&emsp;如果领导者在复制包含配置文件的日志时候崩溃了，跟随者节点只有两种配置状态，<code>C-old,new</code>或者<code>C-old</code>，主要观察<code>C-old,new</code>是否能被复制到了大多数节点。但是无论哪种状态，<code>C-new</code>都不会单方面做出决定。</p>
<h5 id="空白节点加入"><a href="#空白节点加入" class="headerlink" title="空白节点加入"></a>空白节点加入</h5><p>&emsp;&emsp;当一个新的服务器加入集群，新服务器本身是没有存储任何日志，是无法提交集群中的任何一条日志的，需要一段时间来追赶，<code>Raft</code>为了避免这种可用性的时间间隔太长，采取了节点静默加入集群，但是没有投票权，只是同步日志，当新节点已经可以跟上集群日志的时候再投票加入集群。</p>
<h5 id="旧节点干扰"><a href="#旧节点干扰" class="headerlink" title="旧节点干扰"></a>旧节点干扰</h5><p>&emsp;&emsp;当<code>C-new</code>被提交以后，就需要移除不在<code>C-new</code>中的节点。在<code>C-new</code>被提交后，需要移除的节点就接收不到<code>领导者</code>的心跳消息，这个时候这些节点认为<code>领导者</code>可能出现了故障，会发起选举，正常执行的<code>领导者</code>收到投票请求后会退回到<code>跟随者</code>状态等待新<code>领导者</code>被选出，虽然最终正确的<code>领导者</code>会被选出，但是频繁的选举流程会扰乱集群的可用性。<br>&emsp;&emsp;为了避免这个问题，<code>Raft</code>采用了<code>最小选举超时时间</code>的机制，当服务器在当前最小选举超时时间内收到一个请求投票 RPC，他不会更新当前的任期号或者投出选票，这样就避免了频繁的状态切换。</p>
<h5 id="领导者不在新集群中"><a href="#领导者不在新集群中" class="headerlink" title="领导者不在新集群中"></a>领导者不在新集群中</h5><p>&emsp;&emsp;还有一种可能是<code>领导者</code>不在新集群中，当配置文件从<code>C-old,new</code>变更到<code>C-new</code>时，领导者不在<code>C-new</code>中，这个时候就会在一段时间内发生旧节点管理新集群的情况。<br>&emsp;&emsp;<code>Raft</code>中解决方法很简单，当提交<code>C-new</code>成功的时候，自己的状态变为<code>跟随者</code>，这样<code>领导者</code>节点就只能在新集群中选出。</p>
<h3 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h3><p>&emsp;&emsp;<code>Raft</code>算法在运行的过程中，日志是不断累积的，但是在实际的系统中，无论是从日志占用的磁盘空间，还是新节点加入集群，同步日志的网络消耗来看，日志都不能无限的增长。<br>&emsp;&emsp;<code>Raft</code>采用快照的方法来压缩日志，快照时间点前的日志全部丢弃。</p>
<p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/raft2/3.png?raw=true" width="70%" height="70%"></p>
<p>&emsp;&emsp;每个服务器根据已经提交的日志，独立创建快照，快照中包含；</p>
<ul>
<li>状态机最后应用的日志；</li>
<li>状态机最后应用日志的任期号；</li>
<li>状态机最后应用的配置文件内容；</li>
</ul>
<p>&emsp;&emsp;<code>领导者</code>周期性的发送一些快照给<code>跟随者</code>，与<code>领导者</code>，保持同步的节点已经提交了快照的内容，会直接丢弃，而运行缓慢或者新加入集群的服务器则不会有这个条目，就会接受并且应用的自己的状态机中。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/08/13/pbft-1/" class="prev">PREV</a><a href="/2019/07/16/raft-1/" class="next">NEXT</a></div><div class="copyright"><p>© 2017 - 2019 <a href="http://yoursite.com">Qin Yuan</a> &emsp;<script src="https://s19.cnzz.com/z_stat.php?id=1263032208&amp;web_id=1263032208" language="JavaScript"></script></p><div><h4>Fridens</h4><a href="https://www.xuanzhangjiong.top/">TopJohn's Blog</a></div></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>