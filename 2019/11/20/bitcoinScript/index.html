<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="6A32DaUP6x"><meta name="sogou_site_verification" content="MPOhwuqxBD"><title> 深入理解比特币脚本 · Qin Yuan's blog</title><meta name="description" content="深入理解比特币脚本 - Qin Yuan"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="qyuan.top/atom.xml" title="Qin Yuan's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"><span style="font-size: 20px;margin-left: 20px;margin-top: -46px;display: inline-block;vertical-align: middle;">清源的博客~</span></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">文章</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">关于我</a></li><li class="nav-list-item"><a href="https://github.com/Ice-Storm" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">深入理解比特币脚本</h1><div class="post-info"></div><div style="font-size:14px;color:#aaa;">Author: <span style="display:inline-block;margin-left:10px">Qin Yuan</span></div><div style="font-size:14px;color:#aaa;"><span>Date: <span style="display:inline-block;margin-left:21px">Nov 20, 2019</span></span><div>Tag:<span style="display:inline-block;margin-left:21px"></span><a href="/tags/区块链" class="post-title-link"><span style="margin-left:10px;color:blue">区块链</span></a><a href="/tags/比特币" class="post-title-link"><span style="margin-left:10px;color:blue">比特币</span></a></div></div><div class="post-content"><p>每一笔交易除了铸币交易（coinbase）外，每一笔交易都拥有至少一个输入（TxIn）和至少一个输出（TxOut），和我们直觉上理解的交易的TxIn和TxOut应该是数字不太一样，在比特币中是以脚本的形式存在。</p>
<a id="more"></a>
<h3 id="比特币脚本"><a href="#比特币脚本" class="headerlink" title="比特币脚本"></a>比特币脚本</h3><p>比特币脚本是一种基于栈的脚本语言，不是图灵完备的，在比特币没有账户的概念，谁拥有这笔交易的输出谁就可以花费这笔交易中的比特币，为了证明拥有这笔交易的输出就需要提供密钥接受验证，验证通过就可以花费这笔交易的输出。</p>
<blockquote>
<p>其基本的设计思路是，谁能提供一个签名和一个公钥，让这个脚本运行通过，谁就能花费交易中包含的BTC。</p>
</blockquote>
<p>执行的脚本由输入和输出拼接而成，如下图所示；<br><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/bitcoinScript/1.jpg?raw=true" width="110%" height="50%"></p>
<p>比特币提供了三种输入输入脚本的形式，分别是<code>Pay to Publish Key</code>，<code>Pay to Publish Key Hash</code>和<code>Pay to Script Hash</code>。</p>
<h5 id="公钥支付（Pay-to-Publish-Key）"><a href="#公钥支付（Pay-to-Publish-Key）" class="headerlink" title="公钥支付（Pay to Publish Key）"></a>公钥支付（Pay to Publish Key）</h5><p>输出脚本直接给出了收款人的公钥，输入脚本提供了用私钥对整个交易的签名，最后通过<code>OP_CHECKSIG</code>验证。<br>我们知道签名算法是私钥签名公钥验证，如果通过验证，则证明这个行为确实是私钥拥有者所为，在这个例子中，通过私钥对花费BTC的交易签名，而上一笔交易输出的公钥对这笔交易的私钥验证通过后，就可以证明这个交易确实是私钥拥有者做出的，并非冒牌。</p>
<p>在比特币脚本中是这样表示的；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">input script:</div><div class="line">    OP_PUSHDATA(Sig)</div><div class="line">output script:</div><div class="line">    OP_PUSHDATA(PubKey)</div><div class="line">    OP_CHECKSIG</div></pre></td></tr></table></figure></p>
<p>首先 <code>OP_PUSHDATA(Sig)</code>和<code>OP_PUSHDATA(PubKey)</code>将Sig和PubKey压入栈中</p>
<p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/bitcoinScript/2.png?raw=true" width="110%" height="50%"></p>
<p>接着 <code>OP_CHECKSIG</code> 弹出栈顶两个元素验证签名</p>
<p><img src="https://github.com/Ice-Storm/ice-storm.github.io/blob/master/images/bitcoinScript/3.png?raw=true" width="110%" height="50%"></p>
<p>栈中结果是True，证明私钥拥有者同时也拥有花费这笔交易Out的权利。</p>
<h5 id="公钥哈希支付（Pay-to-Public-Key-Hash）"><a href="#公钥哈希支付（Pay-to-Public-Key-Hash）" class="headerlink" title="公钥哈希支付（Pay to Public Key Hash）"></a>公钥哈希支付（Pay to Public Key Hash）</h5><p>在<code>Pay to Publish Key</code>中，输出脚本中直接暴露了下一笔交易花费者的公钥，显然是不太合理的，于是又有了第二种输出脚本的类型<code>Pay to Public Key Hash</code>。<br><code>Pay to Public Key Hash</code>类型的输出脚本直接给出了收款人公钥的哈希，输入脚本提供了用私钥对整个交易的签名，同时也提供了自己的公钥用作验证，整个过程大同小异。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">input script:</div><div class="line">    OP_PUSHDATA(Sig)  //压入签名</div><div class="line">    OP_PUSHDATA(PublicKey)  //压入公钥</div><div class="line">output script:</div><div class="line">    OP_DUP  //复制栈顶元素，再压入栈</div><div class="line">    OP_HASH160  //弹出栈顶元素，取哈希在压入栈</div><div class="line">    OP_PUSHDATA(PubKeyHash)  //压入输出脚本提供的公钥哈希</div><div class="line">    OP_EQUALVERIFY   //弹出栈顶元素，比较是否相等</div><div class="line">    OP_CHECKSIG   //公钥检查签名是否正确</div></pre></td></tr></table></figure></p>
<h5 id="脚本哈希支付（Pay-to-Script-Hash）"><a href="#脚本哈希支付（Pay-to-Script-Hash）" class="headerlink" title="脚本哈希支付（Pay to Script Hash）"></a>脚本哈希支付（Pay to Script Hash）</h5><p>这种形式的输出脚本是收款人提供脚本（redeemScript）的哈希，到时候收款人要花费这笔交易的时候需要输入脚本的内容和签名，验证的时候分两步；</p>
<ul>
<li>验证输入脚本的哈希是否与输出脚本中的哈希值匹配</li>
<li>反序列化并执行redeemScript，验证input script给出的签名是否正确</li>
</ul>
<blockquote>
<p>采用BIP16的方案<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">input script:</div><div class="line">    ...</div><div class="line">    OP_PUSHDATA(Sig)          </div><div class="line">    ...</div><div class="line">    OP_PUSHDATA(serialized redeemScript)  </div><div class="line">output script:</div><div class="line">    OP_HASH160                   </div><div class="line">    OP_PUSHDATA(redeemScriptHash)  </div><div class="line">    OP_EQUAL</div></pre></td></tr></table></figure></p>
</blockquote>
<p>其实可以用<code>Pay to Script Hash</code>实现<code>Pay to Public Key</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">redeemScript:</div><div class="line">    PUSHDATA(PubKey)</div><div class="line">    CHECKSIG   </div><div class="line">input script</div><div class="line">    PUSHDATA(Sig)</div><div class="line">    PUSHDATA(serialized redeemScript)</div><div class="line">output script:</div><div class="line">    HASH160</div><div class="line">    PUSDHDATA(redeemScriptHash)</div><div class="line">    EQUAL</div></pre></td></tr></table></figure></p>
<p><code>Pay to Script Hash</code>在比特币最初版本是没有的，后期软分叉加入，最重要的一点是对多重签名的支持。</p>
<blockquote>
<p>多重签名中，只要提超过供指定数量即可，容忍了一定程度的私钥丢失</p>
</blockquote>
<p>原来的多重签名需要外部用户提供一一对应的公钥，一共有多少公钥，几个公钥通过验证就可以完成交易，对用户比较繁琐，现在使用<code>Pay to Script Hash</code>将整个过程打包到脚本中，对外部用户来说降低了多重签名的复杂性，将复杂性转移到了系统中。</p>
<h5 id="Proof-of-Burn"><a href="#Proof-of-Burn" class="headerlink" title="Proof of Burn"></a>Proof of Burn</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">output script</div><div class="line">    RETURN</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>包含了这样的output script的output被称为Provably Unspendable/Prunable Outputs。<br>假如有一个交易的input指向这个output，不论input里的input script如何设计，执行到RETURN这个命令之后都会直接返回false，RETURN后面的其他指令也就不会执行了，所以这个output无法再被花出去，对应的UTXO也就可以被剪枝了，无需全节点继续保存。</p>
<p>应用场景；</p>
<ul>
<li>永久存储一些信息，比如在某个时间证明存在某些事情，比如在2019年1月1日把知识产权的哈希放到链上，当以后产生纠纷的时候，你把知识产权公布出来，知识产权的哈希在特定时间已经上链，就可以证明你在特定时间已经知道了这个知识产权。</li>
<li>代币转换，比如你把一些比特币转换成其他数字货币，你需要通过这种方式来证明你付出了一些代价。</li>
<li>销毁比特币。</li>
</ul>
<p>其中在比特币脚本中已经出现了智能合约的雏形。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/11/11/mining-algo/" class="next">NEXT</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><div id="gitalk-container"></div><script src="https://unpkg.com/gitalk/dist/gitalk.min.js" crossorigin="anonymous" language="JavaScript"></script><script>var gitalk = new Gitalk({
    clientID: '0dc72a011c85518eff6a',
    clientSecret: '0ae5e09dca1b971dad10c7262e669c9a82ebf3f9',
    repo: 'ice-storm.github.io',
    owner: 'ice-storm',
    admin: ['ice-storm'],
    id: location.pathname,      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
})
gitalk.render('gitalk-container')</script><div class="copyright"><div><h4>Friends</h4><a href="https://www.xuanzhangjiong.top/">TopJohn's Blog</a>&emsp;&emsp;<a href="https://dbarobin.com">Robin</a></div><p>© 2017 - 2019 <a href="qyuan.top">Qin Yuan</a> &emsp;<script src="https://s19.cnzz.com/z_stat.php?id=1263032208&amp;web_id=1263032208" language="JavaScript"></script></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>